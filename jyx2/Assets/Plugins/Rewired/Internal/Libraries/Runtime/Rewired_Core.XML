<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Rewired_Core</name>
    </assembly>
    <members>
        <member name="T:Rewired.ActionIdPropertyAttribute">
            <summary>
            A PropertyAttribute for an InputAction id.
            Use on a serialized int field to allow selecting of Rewired Actions from a popup in the Unity inspector.
            Usage: [ActionIdProperty(typeof(MyType)]
            Type should be a class that contains public const int fields, each of which corresponds to a Rewired Input Action id.
            </summary>
        </member>
        <member name="M:Rewired.ActionIdPropertyAttribute.#ctor(System.Type)">
            <summary>
            Creates an instance of the class.
            </summary>
            <param name="type">Type containing public const int fields or a System.Enum:int.</param>
        </member>
        <member name="T:Rewired.Utils.Attributes.BitmaskAttribute">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Attributes.BitmaskToggleAttribute">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Attributes.FieldRangeAttribute">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Attributes.PreserveAttribute">
            <exclude></exclude>
            <summary>
            Use to preserve things from IL2CPP stripping.
            Usage:
            - Assembly: preserves all types in the assembly (as if a preserve attribute were on each type)
            - Type: preserves the type and its default constructor
            - Method: preserves the methods declaring type, return type, and a the types of all of its arguments
            - Property, Field, Event: preserves the declaring type and return type
            </summary>
        </member>
        <member name="T:Rewired.Utils.Attributes.SerializationTypeAttribute">
            <exclude></exclude>
            <summary>
            Used for overriding automatic serialization type.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Attributes.SerializationTypeAttribute.SerializationType">
            <exclude></exclude>
        </member>
        <member name="F:Rewired.Utils.Attributes.SerializationTypeAttribute.SerializationType.Default">
            <summary>
            Use default serialization type.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Attributes.SerializationTypeAttribute.SerializationType.Object">
            <summary>
            Force class to be serialized as an object.
            </summary>
        </member>
        <member name="T:Rewired.PlayerIdPropertyAttribute">
            <summary>
            A PropertyAttribute for a Player id.
            Use on a serialized int field to allow selecting of Rewired Players from a popup in the Unity inspector.
            Usage: [PlayerIdProperty(typeof(MyType)]
            Type should be a class that contains public const int fields, each of which corresponds to a Rewired Player id.
            </summary>
        </member>
        <member name="M:Rewired.PlayerIdPropertyAttribute.#ctor(System.Type)">
            <summary>
            Creates an instance of the class.
            </summary>
            <param name="type">Type containing public const int fields or a System.Enum:int.</param>
        </member>
        <member name="T:Rewired.ControllerStatusChangedEventArgs">
            <summary>
            Event args returned by controller connect and disconnect events.
            Contains information about the controller that was changed.
            </summary>
        </member>
        <member name="M:Rewired.ControllerStatusChangedEventArgs.#ctor(System.String,System.Int32,Rewired.ControllerType)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The name of the controller.</param>
            <param name="uniqueId">The id of the controller.</param>
            <param name="controllerType">The type of the controller.</param>
        </member>
        <member name="P:Rewired.ControllerStatusChangedEventArgs.name">
            <summary>
            The name of the controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerStatusChangedEventArgs.controllerId">
            <summary>
            The id of the controller. This can be used along with controllerType to get the controller.
            For joysticks, this is equal to Joystick.id.
            </summary>
        </member>
        <member name="P:Rewired.ControllerStatusChangedEventArgs.controllerType">
            <summary>
            The type of the controller. This can be used along with controllerId to get the controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerStatusChangedEventArgs.controller">
            <summary>
            The Controller. This will be null if the Controller was already disconnected.
            </summary>
        </member>
        <member name="T:Rewired.ControllerAssignmentChangedEventArgs">
            <summary>
            Event args returned by controller assignment and unassignment events in Players.
            Contains information about the controller that was changed.
            </summary>
        </member>
        <member name="P:Rewired.ControllerAssignmentChangedEventArgs.state">
            <summary>
            The assignment state change that took place.
            True = the Controller was assigned to the Player.
            False = the Controller was unassigned from the Player.
            </summary>
        </member>
        <member name="P:Rewired.ControllerAssignmentChangedEventArgs.controller">
            <summary>
            The Controller whose assignment status changed.
            </summary>
        </member>
        <member name="P:Rewired.ControllerAssignmentChangedEventArgs.player">
            <summary>
            The Player to which the Controller was assigned or unassigned.
            </summary>
        </member>
        <member name="T:Rewired.InputActionEventData">
            <summary>
            Event data returned by an Input Action update event. Use this to get information about the input event.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventData.playerId">
            <summary>
            The Player Id of the Player that generated this event.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventData.actionId">
            <summary>
            The Action Id of Action this event is for.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventData.updateLoop">
            <summary>
            The update loop this event was called in.
            </summary>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxis">
            <summary>
            Gets the axis value of an Action.
            </summary>
            <returns>The axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisPrev">
            <summary>
            Gets the axis value of an Action during the previous frame.
            </summary>
            <returns>The previous axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisDelta">
            <summary>
            Gets the change in axis value of an Action since the previous frame.
            </summary>
            <returns>The change in axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisTimeActive">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active. Returns 0 if the axis is not currently active.
            </summary>
            <returns>The duration the axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisTimeInactive">
            <summary>
            Gets the length of time in seconds that an axis has been inactive. Returns 0 if the axis is currently active.
            </summary>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRaw">
            <summary>
            Gets the raw axis value of an Action. The raw value excludes any digital axis simulation modification by the Input Behavior assigned to this Action.
            This raw value is modified by deadzone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <returns>The raw axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawDelta">
            <summary>
            Gets the change in raw axis value of an Action since the previous frame. The raw value excludes any digital axis simulation modification by the Input Behavior assigned to this Action.
            This raw value is modified by deadzone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <returns>The change in raw axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawPrev">
            <summary>
            Gets the raw axis value of an Action during the previous frame. The raw value excludes any digital axis simulation modification by the Input Behavior assigned to this Action.
            This raw value is modified by deadzone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <returns>The previous raw axis value.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawTimeActive">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active as calculated from the raw value. Returns 0 if the axis is not currently active.
            </summary>
            <returns>The duration the raw axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawTimeInactive">
            <summary>
            Gets the length of time in seconds that an axis has been inactive as calculated from the raw value. Returns 0 if the axis is currently active.
            </summary>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisCoordinateMode">
            Gets the current coordinate mode of the axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisCoordinateModePrev">
            Gets the coordinate mode of the axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawCoordinateMode">
            Gets the current coordinate mode of the raw axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetAxisRawCoordinateModePrev">
            Gets the coordinate mode of the raw axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButton">
            <summary>
            Gets the button held state of an Action. This will return TRUE as long as the button is held.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonPrev">
            <summary>
            Gets the button held state of an Action during the previous frame.
            </summary>
            <returns>The previous button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonDown">
            <summary>
            Gets the button just pressed state of an Action. This will only return TRUE only on the first frame the button is pressed or for the duration of the Button Down Buffer time limit if set in the Input Behavior assigned to this Action.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonUp">
            <summary>
            Get the button just released state for an Action. This will only return TRUE for the first frame the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The button just released state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonSinglePressHold" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonSinglePressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonSinglePressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonDoublePressDown" -->
        <member name="M:Rewired.InputActionEventData.GetButtonDoublePressDown(System.Single)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just pressed state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonDoublePressHold" -->
        <member name="M:Rewired.InputActionEventData.GetButtonDoublePressHold(System.Single)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetButtonDoublePressUp" -->
        <member name="M:Rewired.InputActionEventData.GetButtonDoublePressUp(System.Single)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimedPress(System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimedPress(System.Single,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimedPressDown(System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimedPressUp(System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimedPressUp(System.Single,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonShortPress">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            The button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonShortPressDown">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes being used as buttons.
            The button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonShortPressUp">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            The button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonLongPress">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            The button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonLongPressDown">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes being used as buttons.
            The button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonLongPressUp">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            The button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonRepeating">
            <summary>
            Gets the repeating button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the Input Behavior assigned to the Action.
            This also applies to axes being used as buttons.
            </summary>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimePressed">
            <summary>
            Gets the length of time in seconds that a button has been continuously held down. Returns 0 if the button is not currently pressed.
            </summary>
            <returns>The duration of the button hold.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetButtonTimeUnpressed">
            <summary>
            Gets the length of time in seconds that a button has not been pressed. Returns 0 if the button is currently pressed.
            </summary>
            <returns>The duration of the button inactivity.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButton">
            <summary>
            Gets the negative button held state of an Action. This will return TRUE as long as the negative button is held.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonPrev">
            <summary>
            Gets the negative button held state of an Action during the previous frame.
            </summary>
            <returns>The previous negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonDown">
            <summary>
            Gets the negative button just pressed state of an Action. This will only return TRUE only on the first frame the negative button is pressed or for the duration of the Button Down Buffer time limit if set in the Input Behavior assigned to this Action.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonUp">
            <summary>
            Get the negative button just released state for all Actions. This will only return TRUE for the first frame the negative button is released.
            This will return TRUE each time any negative button is released even if others are being held down.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The negative button just released state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonSinglePressHold" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonSinglePressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonSinglePressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonDoublePressDown" -->
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonDoublePressDown(System.Single)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonDoublePressHold" -->
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonDoublePressHold(System.Single)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.InputActionEventData.GetNegativeButtonDoublePressUp" -->
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonDoublePressUp(System.Single)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimedPress(System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimedPress(System.Single,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimedPressDown(System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimedPressUp(System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimedPressUp(System.Single,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonShortPress">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonShortPressDown">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonShortPressUp">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonLongPress">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonLongPressDown">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonLongPressUp">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the Input Behavior assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonRepeating">
            <summary>
            Gets the repeating negative button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the Input Behavior assigned to the Action.
            This also applies to axes being used as buttons.
            </summary>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimePressed">
            <summary>
            Gets the length of time in seconds that a negative button has been continuously held down. Returns 0 if the negative button is not currently pressed.
            </summary>
            <returns>The duration of the negative button hold.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetNegativeButtonTimeUnpressed">
            <summary>
            Gets the length of time in seconds that a negative button has not been pressed. Returns 0 if the negative button is currently pressed.
            </summary>
            <returns>The duration of the negative button inactivity.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.GetCurrentInputSources">
            <summary>
            Gets a list of all the input sources that contributed to the value of the Action in the current frame.
            </summary>
            <returns>Input source data</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.IsCurrentInputSource(Rewired.ControllerType)">
            <summary>
            Checks whether any controller of type contributed input to this Action in the current frame.
            </summary>
            <param name="controllerType">Type of the controller</param>
            <returns>Whether any controller of type contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.IsCurrentInputSource(Rewired.ControllerType,System.Int32)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="controllerType">Type of the controller</param>
            <param name="controllerId">Id of the Controller</param>
            <returns>Whether the controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.InputActionEventData.IsCurrentInputSource(Rewired.Controller)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="controller">Controller</param>
            <returns>Whether the controller contributed to the Action this frame.</returns>
        </member>
        <member name="P:Rewired.InputActionEventData.eventType">
            <summary>
            The event type of this event.
            </summary>
        </member>
        <member name="P:Rewired.InputActionEventData.player">
            <summary>
            The Player that generated this event.
            </summary>
        </member>
        <member name="P:Rewired.InputActionEventData.actionName">
            <summary>
            The scripting name of the input Action of this event.
            </summary>
        </member>
        <member name="P:Rewired.InputActionEventData.actionDescriptiveName">
            <summary>
            The descriptive name of the input Action of this event.
            </summary>
        </member>
        <member name="T:Rewired.ControllerPollingInfo">
            <summary>
            Contains polling information recieved from a controller element polling request.
            Use this to determine which controller element was activated for use in control remapping.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.success">
            <summary>
            Was user input detected? If false, no user input was detected.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.playerId">
            <summary>
            The player id that generated this input. This value is only valid if the controller is assigned to a Player and polling was called on or through Player.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.controllerId">
            <summary>
            The id of the controller that returned input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.controllerName">
            <summary>
            The name of the controller that returned input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.controllerType">
            <summary>
            The type of the controller that returned input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.elementType">
            <summary>
            The type of element on the controller that returned input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.elementIndex">
            <summary>
            The index to the controller element that returned input. In combination with controllerType, this can be used to determine the exact button or axis index.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.axisPole">
            <summary>
            The pole of the axis that was activated (+/-). This is only relevant if elementType is Axis.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.elementIdentifierName">
            <summary>
            The name of the element identifier on the controller that returned input. This gives you the human-readable name of the element such as Left Stick X -.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.elementIdentifierId">
            <summary>
            The id of the element identifier on the controller that returned input. This points back to the human-readable element identifier on a controller such as Left Stick X.
            This is used when creating an ActionElementMap in a ControllerMap to associate a controller element with an Action.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.keyboardKey">
            <summary>
            The keyboard key that returned input. This is only valid if controllerType is Keyboard.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.player">
            <summary>
            The Player that generated this input. This value is only valid if the controller is assigned to a Player and polling was called on or through Player.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.controller">
            <summary>
            The controller that returned input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerPollingInfo.elementIdentifier">
            <summary>
            The controller element identifier that returned input.
            </summary>
        </member>
        <member name="T:Rewired.ElementAssignmentConflictInfo">
            <summary>
            Information about a controller element assignment conflict.
            </summary>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictInfo.#ctor(System.Boolean,System.Boolean,System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Int32,Rewired.ControllerElementType,System.Int32,UnityEngine.KeyCode,Rewired.ModifierKeyFlags)">
            <summary>
            Creates a new ElementAssignmentConflictInfo.
            </summary>
            <param name="isConflict">Was an assignment conflict found?</param>
            <param name="isUserAssignable">Is the Map Category of this Action user assignable?</param>
            <param name="playerId">The id of the Player that contains the map that has the conflicting assignment.</param>
            <param name="controllerType">The controller type of the controller that contains the conflict.</param>
            <param name="controllerId">The id of the controller that contains the conflict. Use with controllerType to get the Controller.</param>
            <param name="controllerMapId">The unique id of the ControllerMap that contains the conflict.</param>
            <param name="elementMapId">The unique id of the ActionElementMap with the assignment conflict.</param>
            <param name="actionId">The Action Id assigned to the ActionElementMap with the conflict.</param>
            <param name="elementType">The controller element type of the conflicting ActionElementMap.</param>
            <param name="elementIdentifierId">The element identifier id of the conflicting ActionElementMap.</param>
            <param name="keyCode">The key code of the keyboard key assignment that is conflicting. (Only applies to keyboard maps.)</param>
            <param name="modifierKeyFlags">The modifier key flags of the keyboard key assignment that is conflicting. (Only applies to keyboard maps.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictInfo.#ctor(Rewired.ElementAssignmentConflictInfo)">
            <summary>
            Creates a clone of an ElementAssignmentConflictInfo.
            </summary>
            <param name="source">ElementAssignmentConflictInfo to clone.</param>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.isConflict">
            <summary>
            Was an assignment conflict found?
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.isUserAssignable">
            <summary>
            Is the Map Category of this Action user assignable?
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.playerId">
            <summary>
            The id of the Player that contains the map that has the conflicting assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.controllerType">
            <summary>
            The controller type of the controller that contains the conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.controllerId">
            <summary>
            The id of the controller that contains the conflict. Use with controllerType to get the Controller.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.controllerMapId">
            <summary>
            The unique id of the ControllerMap that contains the conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementMapId">
            <summary>
            The unique id of the ActionElementMap with the assignment conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementType">
            <summary>
            The controller element type of the conflicting ActionElementMap.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementIdentifierId">
            <summary>
            The element identifier id of the conflicting ActionElementMap.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.keyCode">
            <summary>
            The key code of the keyboard key assignment that is conflicting. (Only applies to keyboard maps.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.modifierKeyFlags">
            <summary>
            The modifier key flags of the keyboard key assignment that is conflicting. (Only applies to keyboard maps.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.actionId">
            <summary>
            The Action Id assigned to the ActionElementMap with the conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.player">
            <summary>
            The Player that contains the map that has the conflicting assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.action">
            <summary>
            The Action assigned to the ActionElementMap with the conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.controller">
            <summary>
            The controller that the conflicting assignment is on.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.controllerMap">
            <summary>
            The Controller Map that contains the conflicting assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementIdentifier">
            <summary>
            The element identifier of the conflicting ActionElementMap.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementMap">
            <summary>
            The ActionElementMap with the assignment conflict.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictInfo.elementDisplayName">
            <summary>
            The display name of the element with the conflicting assignment.
            </summary>
        </member>
        <member name="T:Rewired.ElementAssignmentConflictCheck">
            <summary>
            A struct for performing a controller element assignment conflict check.
            </summary>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for complete assignment.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementAssignmentType">The type of the desired assignment.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for complete assignment to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementAssignmentType">The type of the desired assignment.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for complete assignment.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementType"></param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for complete assignment to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementType"></param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a full axis.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a full axis to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="invert">Is the axis inverted? (Only used for full axis assignments.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a split axis.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a split axis to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="axisRange">The range of the axis that is being assigned. (Only used for axis assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a button.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a button to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="elementIdentifierId">The element identifier id of the controller element that is being assigned.</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a keyboard key.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(System.Int32,Rewired.ControllerType,System.Int32,System.Int32,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment conflict checking.
            Overload for assignment of a keyboard key to replace an existing element map.
            </summary>
            <param name="playerId">The Player that is being assigned to.</param>
            <param name="controllerType">The type of controller that is being assigned to.</param>
            <param name="controllerId">The id of the controller that is being assigned to.</param>
            <param name="controllerMapId">The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.</param>
            <param name="keyboardKey">The keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="modifierKeyFlags">The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)</param>
            <param name="actionId">The id of the Action being assigned.</param>
            <param name="axisContribution">The positive / negative contribution for the assignment. (Only used for split axes and buttons.)</param>
            <param name="elementMapId"></param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.#ctor(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Creates a copy of an ElementAssignmentConflictCheck object.
            </summary>
            <param name="source">The ElementAssignmentConflictCheck to clone.</param>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.ToElementAssignment">
            <summary>
            Converts ElementAssignmentConflictCheck into an ElementAssignment.
            Can be used to make an element assignment.
            </summary>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.ToFullAxisAssignment">
            <summary>
            Converts ElementAssignmentConflictCheck into an ElementAssignment for a full axis assignment.
            Can be used to make an element assignment.
            </summary>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.ToSplitAxisAssignment">
            <summary>
            Converts ElementAssignmentConflictCheck into an ElementAssignment for a split axis assignment.
            Can be used to make an element assignment.
            </summary>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.ToButtonAssignment">
            <summary>
            Converts ElementAssignmentConflictCheck into an ElementAssignment for a button assignment.
            Can be used to make an element assignment.
            </summary>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignmentConflictCheck.ToKeyboardKeyAssignment">
            <summary>
            Converts ElementAssignmentConflictCheck into an ElementAssignment for a keyboard key assignment.
            Can be used to make an element assignment.
            </summary>
            <returns>ElementAssignment</returns>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.elementAssignmentType">
            <summary>
            The type of the desired assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.playerId">
            <summary>
            The Player that is being assigned to.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.controllerType">
            <summary>
            The type of controller that is being assigned to.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.controllerId">
            <summary>
            The id of the controller that is being assigned to.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.controllerMapId">
            <summary>
            The unique id of the controller map that is being assigned to. Corresponds to ControllerMap.id.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.controllerMapCategoryId">
            <summary>
            The map category id of the controller map that is being assigned to. (Optional)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.elementMapId">
            <summary>
            The unique id of the ActionElementMap that is being assigned to. Only used if replacing an assignment. (Optional)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.elementIdentifierId">
            <summary>
            The element identifier id of the controller element that is being assigned.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.axisRange">
            <summary>
            The range of the axis that is being assigned. (Only used for axis assignments.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.keyboardKey">
            <summary>
            The keyboard key that is being assigned. (Only used for keyboard assignments.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.modifierKeyFlags">
            <summary>
            The modifiers keys for the keyboard key that is being assigned. (Only used for keyboard assignments.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.actionId">
            <summary>
            The id of the Action being assigned.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.axisContribution">
            <summary>
            The positive / negative contribution for the assignment. (Only used for split axes and buttons.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentConflictCheck.invert">
            <summary>
            Is the axis inverted? (Only used for full axis assignments.)
            </summary>
        </member>
        <member name="T:Rewired.ElementAssignment">
            <summary>
            A struct for making a controller element assignement.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.type">
            <summary>
            The type of the element assignment.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.elementMapId">
            <summary>
            The id of the ActionElementMap that this assignment will be replacing. (Optional)
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.elementIdentifierId">
            <summary>
            The element identifier id the Action will be bound to.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.axisRange">
            <summary>
            The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.keyboardKey">
            <summary>
            The keyboard key the Action will be bound to. Only used for keyboard maps.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.modifierKeyFlags">
            <summary>
            The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.actionId">
            <summary>
            The id of the Action that will be bound to the controller element.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.axisContribution">
            <summary>
            Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.
            </summary>
        </member>
        <member name="F:Rewired.ElementAssignment.invert">
            <summary>
            Is the axis inverted? Used only for axis assignments.
            </summary>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for complete assignment to replace an existing element map.
            </summary>
            <param name="elementAssignmentType">The type of the element assignment.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(Rewired.ControllerType,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for complete assignment to replace an existing element map.
            </summary>
            <param name="controllerType">The controller type of the controller this assignment is for.</param>
            <param name="elementType">The type of element this assignment is for.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            A struct for use in element assignment.
            Overload for complete new assignment.
            </summary>
            <param name="elementAssignmentType">The type of the element assignment.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(Rewired.ControllerType,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            A struct for use in element assignment.
            Overload for complete new assignment.
            </summary>
            <param name="controllerType">The controller type of the controller this assignment is for.</param>
            <param name="elementType">The type of element this assignment is for.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a full axis.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a full axis to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a split axis.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a split axis to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a button.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(System.Int32,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a button to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a keyboard key.
            </summary>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
        </member>
        <member name="M:Rewired.ElementAssignment.#ctor(UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            A struct for use in element assignment.
            Overload for assignment of a keyboard key to replace an existing element map.
            </summary>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
        </member>
        <member name="M:Rewired.ElementAssignment.CompleteAssignment(Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For complete assignment to replace an existing element map.
            </summary>
            <param name="elementAssignmentType">The type of the element assignment.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.CompleteAssignment(Rewired.ControllerType,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For complete assignment to replace an existing element map.
            </summary>
            <param name="controllerType">The controller type of the controller this assignment is for.</param>
            <param name="elementType">The type of element this assignment is for.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.CompleteAssignment(Rewired.ElementAssignmentType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            Creates a struct for use in element assignment.
            For complete new assignment.
            </summary>
            <param name="elementAssignmentType">The type of the element assignment.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.CompleteAssignment(Rewired.ControllerType,Rewired.ControllerElementType,System.Int32,Rewired.AxisRange,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Boolean)">
            <summary>
            Creates a struct for use in element assignment.
            For complete new assignment.
            </summary>
            <param name="controllerType">The controller type of the controller this assignment is for.</param>
            <param name="elementType">The type of element this assignment is for.</param>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.FullAxisAssignment(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a full axis.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.FullAxisAssignment(System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a full axis to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="invert">Is the axis inverted? Used only for axis assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.SplitAxisAssignment(System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a split axis.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.SplitAxisAssignment(System.Int32,Rewired.AxisRange,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a split axis to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="axisRange">The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.ButtonAssignment(System.Int32,System.Int32,Rewired.Pole)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a button.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.ButtonAssignment(System.Int32,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a button to replace an existing element map.
            </summary>
            <param name="elementIdentifierId">The element identifier id the Action will be bound to.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.KeyboardKeyAssignment(UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a keyboard key.
            </summary>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.KeyboardKeyAssignment(UnityEngine.KeyCode,Rewired.ModifierKeyFlags,System.Int32,Rewired.Pole,System.Int32)">
            <summary>
            Creates a struct for use in element assignment.
            For assignment of a keyboard key to replace an existing element map.
            </summary>
            <param name="keyboardKey">The keyboard key the Action will be bound to. Only used for keyboard maps.</param>
            <param name="modifierKeyFlags">The keyboard modifiers the Action will be bound to. Use this in combination with keyboardKey to make a modified key assignment. Only used for keyboard maps.</param>
            <param name="actionId">The id of the Action that will be bound to the controller element.</param>
            <param name="axisContribution">Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.</param>
            <param name="elementMapId">The id of the ActionElementMap that this assignment will be replacing. (Optional)</param>
            <returns>ElementAssignment</returns>
        </member>
        <member name="M:Rewired.ElementAssignment.ToElementAssignmentConflictCheck">
            <summary>
            Converts this ElementAssignment to an ElementAssignmentConflictCheck struct. Can be used for conflict checking.
            You may need to provide additional data to the resulting ElementAssignmentConflictCheck before performing the conflict check.
            </summary>
            <returns>ElementAssignmentConflictCheck</returns>
        </member>
        <member name="T:Rewired.ElementAssignmentInfo">
            <summary>
            Describes a pending element assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.player">
            <summary>
            The Player this assignment is for.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.action">
            <summary>
            The Action that will be bound to the controller element.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.controller">
            <summary>
            The controller that the assignment is for.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.controllerType">
            <summary>
            The controller type of the controller the assignment is for.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.controllerId">
            <summary>
            The controller id of the controller the assignment is for.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.controllerMap">
            <summary>
            The ControllerMap that will recieve the assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.elementIdentifier">
            <summary>
            The element identifier of the assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.elementMap">
            <summary>
            The ActionElementMap that this assignment will be replacing.
            Null if not a replacement assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.elementType">
            <summary>
            The controller element type.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.axisContribution">
            <summary>
            Does this Action contribute positive or negative values to the final Action's input value? Used for split axis and button/key assignments.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.axisRange">
            <summary>
            The range of the axis of this assignment. Use Positive or Negative to assign a split axis or Full for a single unified axis assignment.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.invert">
            <summary>
            Is the axis inverted? Used only for axis assignments.
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.keyCode">
            <summary>
            The key code of the keyboard key assignment. (Only applies to keyboard maps.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.modifierKeyFlags">
            <summary>
            The modifier key flags of the keyboard key assignment. (Only applies to keyboard maps.)
            </summary>
        </member>
        <member name="P:Rewired.ElementAssignmentInfo.elementDisplayName">
            <summary>
            The display name of the element in this assignment.
            </summary>
        </member>
        <member name="T:Rewired.InputActionSourceData">
            <summary>
            Provides information about the current sources contributing to the value of an Input Action.
            </summary>
        </member>
        <member name="P:Rewired.InputActionSourceData.controller">
            <summary>
            Gets the Controller that contributed to the value of the Action.
            </summary>
        </member>
        <member name="P:Rewired.InputActionSourceData.controllerType">
            <summary>
            Gets the type of the Controller that contributed to the value of the Action.
            </summary>
        </member>
        <member name="P:Rewired.InputActionSourceData.controllerMap">
            <summary>
            Gets the ControllerMap that contributed to the value of the Action.
            </summary>
        </member>
        <member name="P:Rewired.InputActionSourceData.actionElementMap">
            <summary>
            Gets the ActionElementMap that contributed to the value of the Action.
            </summary>
        </member>
        <member name="P:Rewired.InputActionSourceData.elementIdentifierName">
            <summary>
            Gets the element identifier name of the element that contributed to the value of the Action.
            </summary>
        </member>
        <member name="T:Rewired.ControllerIdentifier">
            <summary>
            Information to identify a Controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.controllerId">
            <summary>
            The session id of the Controller.
            Get this value from <see cref="F:Rewired.Controller.id"/>.
            This should be set to -1 if the Controller is not currently connected or you don't know the current id.
            Setting this value to 0 or greater will cause the controller session id to be used for selection.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.controllerType">
            <summary>
            The controller type of the Controller.
            Get this value from <see cref="P:Rewired.Controller.type"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.hardwareTypeGuid">
            <summary>
            The hardwre type GUID of the Controller.
            Get this value from <see cref="P:Rewired.Controller.hardwareTypeGuid"/>.
            This value is used to identify recognized Controllers.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.hardwareIdentifier">
            <summary>
            The hardware identifier of the Controller.
            Get this value from <see cref="P:Rewired.Controller.hardwareIdentifier"/>.
            This is used primarily by Unknown Controllers to identify the controller using various information gathered from the controller.
            This value varies depending on the platform, input source in use, and the device.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.deviceInstanceGuid">
            <summary>
            The device instance GUID of the Controller.
            Get this value from <see cref="P:Rewired.Controller.deviceInstanceGuid"/>.
            Use this to target a specific persistant device instance across sessions.
            </summary>
        </member>
        <member name="P:Rewired.ControllerIdentifier.Blank">
            <summary>
            A blank ControllerIdentifier.
            </summary>
        </member>
        <member name="T:Rewired.ControllerSetSelector">
            <summary>
            Used for selecting Controllers based on the specified criteria.
            See static factory methods for construction.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Interfaces.IDeepCloneable">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.ControllerSetSelector.#ctor(Rewired.ControllerSetSelector.Type)">
            <summary>
            Creates an instance of the class.
            </summary>
            <param name="type">The selector type</param>
        </member>
        <member name="M:Rewired.ControllerSetSelector.#ctor">
            <summary>
            Creates an instance of the class.
            </summary>
        </member>
        <member name="M:Rewired.ControllerSetSelector.#ctor(Rewired.ControllerSetSelector)">
            <summary>
            Creates a copy of an instance.
            </summary>
        </member>
        <member name="M:Rewired.ControllerSetSelector.#ctor(Rewired.ControllerSetSelector.Type,Rewired.ControllerType,System.String,System.String,System.Int32)">
            <summary>
            Creates an instance of the class.
            </summary>
        </member>
        <member name="M:Rewired.ControllerSetSelector.Matches(Rewired.Controller)">
            <summary>
            Determines if the specified Controller is matched by the selector.
            </summary>
            <param name="controller">The Controller.</param>
            <returns>True if the Controller matches the selection criteria, false if not.</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectAll">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.All"/> selector type.
            </summary>
            <returns>Entry</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectControllerType(Rewired.ControllerType)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.ControllerType"/> selector type.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectHardwareType(Rewired.ControllerType,System.Guid,System.String)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.HardwareType"/> selector type.
            </summary>
            <param name="controllerType">The Controller Type</param>
            <param name="hardwareTypeGuid">The hardware type GUID</param>
            <param name="hardwareIdentifier">The hardware identifier</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectHardwareType(Rewired.Controller)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.HardwareType"/> selector type.
            Necessary properties will be populated from the Controller.
            </summary>
            <param name="controller">The Controller</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectControllerTemplateType(Rewired.ControllerType,System.Guid)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.ControllerTemplateType"/> selector type.
            </summary>
            <param name="controllerType">The Controller Type</param>
            <param name="controllerTemplateTypeGuid">The Controller Template type GUID</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectControllerTemplateType(Rewired.IControllerTemplate)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.ControllerTemplateType"/> selector type.
            Necessary properties will be populated from the Controller Template.
            </summary>
            <param name="controllerTemplate">The Controller Template</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectPersistentControllerInstance(Rewired.ControllerType,System.Guid)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.PersistentControllerInstance"/> selector type.
            </summary>
            <param name="controllerType">The Controller Type</param>
            <param name="deviceInstanceGuid">The device instance GUID</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectPersistentControllerInstance(Rewired.Controller)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.PersistentControllerInstance"/> selector type.
            Necessary properties will be populated from the Controller.
            </summary>
            <param name="controller">The Controller</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectSessionControllerInstance(Rewired.ControllerType,System.Int32)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.SessionControllerInstance"/> selector type.
            </summary>
            <param name="controllerType">The Controller Type</param>
            <param name="controllerId">The id of the Controller</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="M:Rewired.ControllerSetSelector.SelectSessionControllerInstance(Rewired.Controller)">
            <summary>
            Creates an entry with a <see cref="F:Rewired.ControllerSetSelector.Type.SessionControllerInstance"/> selector type.
            Necessary properties will be populated from the Controller.
            </summary>
            <param name="controller">The Controller</param>
            <returns>ControllerSelector</returns>
        </member>
        <member name="P:Rewired.ControllerSetSelector.type">
            <summary>
            Determines selection method used to find the devices the entry applies to.
            Depending on the value chosen, one or more other properties must be set.
            The required fields for each mode are as follows:
            <see cref="F:Rewired.ControllerSetSelector.Type.All"/>: None.
            <see cref="F:Rewired.ControllerSetSelector.Type.ControllerType"/>: <see cref="P:Rewired.ControllerSetSelector.controllerType"/>.
            <see cref="F:Rewired.ControllerSetSelector.Type.HardwareType"/>: <see cref="P:Rewired.ControllerSetSelector.controllerType"/>, <see cref="P:Rewired.ControllerSetSelector.hardwareTypeGuid"/>, <see cref="P:Rewired.ControllerSetSelector.hardwareIdentifier"/>.
            <see cref="F:Rewired.ControllerSetSelector.Type.ControllerTemplateType"/>: <see cref="P:Rewired.ControllerSetSelector.controllerType"/>, <see cref="P:Rewired.ControllerSetSelector.controllerTemplateTypeGuid"/>.
            <see cref="F:Rewired.ControllerSetSelector.Type.PersistentControllerInstance"/>: <see cref="P:Rewired.ControllerSetSelector.controllerType"/>, <see cref="P:Rewired.ControllerSetSelector.deviceInstanceGuid"/>.
            <see cref="F:Rewired.ControllerSetSelector.Type.SessionControllerInstance"/>: <see cref="P:Rewired.ControllerSetSelector.controllerType"/>, <see cref="P:Rewired.ControllerSetSelector.controllerId"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.controllerType">
            <summary>
            The Controller Type the entry applies to.
            This is required for all Device Selector Type modes except <see cref="F:Rewired.ControllerSetSelector.Type.All"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.hardwareTypeGuid">
            <summary>
            The hardware type Guid of the Controller this entry applies to.
            This is only used if <see cref="P:Rewired.ControllerSetSelector.type"/> is set to <see cref="F:Rewired.ControllerSetSelector.Type.HardwareType"/>.
            This targets all Controllers that match a specific recognized hardware type such as all Xbox 360 controllers.
            You should set both <see cref="P:Rewired.ControllerSetSelector.hardwareTypeGuid"/> and <see cref="P:Rewired.ControllerSetSelector.hardwareIdentifier"/> with the values supplied by
            <see cref="P:Rewired.Controller.hardwareTypeGuid"/> and <see cref="P:Rewired.Controller.hardwareIdentifier"/> so both recognized and
            unrecognized Controllers will be handled.
            This value can be obtained from <see cref="P:Rewired.Controller.hardwareTypeGuid"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.hardwareIdentifier">
            <summary>
            The hardware identifier of the Controller this entry applies to.
            This is only used if <see cref="P:Rewired.ControllerSetSelector.type"/> is set to <see cref="F:Rewired.ControllerSetSelector.Type.HardwareType"/>.
            This targets all Controllers that match a specific unrecognized hardware type such as for a Joystick that has no controller definition built into Rewired.
            You should set both <see cref="P:Rewired.ControllerSetSelector.hardwareTypeGuid"/> and <see cref="P:Rewired.ControllerSetSelector.hardwareIdentifier"/> with the values supplied by
            <see cref="P:Rewired.Controller.hardwareTypeGuid"/> and <see cref="P:Rewired.Controller.hardwareIdentifier"/> so both recognized and
            unrecognized Joysticks will be handled.
            This value can be obtained from <see cref="P:Rewired.Controller.hardwareIdentifier"/>.
            If no <see cref="P:Rewired.Controller.hardwareTypeGuid"/> is specified and this value is blank, it will match all Unknown Controllers.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.controllerTemplateTypeGuid">
            <summary>
            The Controller Template type this entry applies to.
            This is only used if <see cref="P:Rewired.ControllerSetSelector.type"/> is set to <see cref="F:Rewired.ControllerSetSelector.Type.ControllerTemplateType"/>.
            This targets all Controllers that match the specified Controller Template type.
            This value can be obtained from <see cref="P:Rewired.IControllerTemplate.typeGuid"/> or the concrete static class of the Controller
            Template such as GamepadTemplate.typeGuid.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.deviceInstanceGuid">
            <summary>
            The device instance guid of the Controller this entry applies to.
            This is only used if <see cref="P:Rewired.ControllerSetSelector.type"/> is set to <see cref="F:Rewired.ControllerSetSelector.Type.PersistentControllerInstance"/>.
            This targets all a single, specific Controller instance that may be valid across sessions.
            This value can be obtained from <see cref="P:Rewired.Controller.deviceInstanceGuid"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerSetSelector.controllerId">
            <summary>
            The <see cref="F:Rewired.Controller.id"/> of the Controller this entry applies to.
            This is only used if <see cref="P:Rewired.ControllerSetSelector.type"/> is set to <see cref="F:Rewired.ControllerSetSelector.Type.SessionControllerInstance"/>.
            This targets all a single, specific Controller instance that is only valid for the current session..
            This value can be obtained from <see cref="P:Rewired.Controller.deviceInstanceGuid"/>.
            </summary>
        </member>
        <member name="T:Rewired.ControllerSetSelector.Type">
            <summary>
            The Controller selector type.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.All">
            <summary>
            Selects all Controllers.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.ControllerType">
            <summary>
            Selects all Controllers that match a specific ControllerType.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.HardwareType">
            <summary>
            Selects all Controllers that match a specific hardware type guid and/or hardware identifier.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.ControllerTemplateType">
            <summary>
            Selects all Controllers that match a specific Controller Template type.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.PersistentControllerInstance">
            <summary>
            Selects a single, specific <see cref="T:Rewired.Controller"/> instance that persists across sessions.
            This uses <see cref="P:Rewired.Controller.deviceInstanceGuid"/> to identify the <see cref="T:Rewired.Controller"/>.
            This relies on the ability to get a persistent device id for the device which
            may not be available or reliable on all platforms and input sources.
            </summary>
        </member>
        <member name="F:Rewired.ControllerSetSelector.Type.SessionControllerInstance">
            <summary>
            Selects a single, specific <see cref="T:Rewired.Controller"/> instance that is valid only for the current session.
            This uses <see cref="F:Rewired.Controller.id"/> to identify the <see cref="T:Rewired.Controller"/>. <see cref="F:Rewired.Controller.id"/> is not consistent across
            application sessions and should not be saved or loaded.
            </summary>
        </member>
        <member name="P:Rewired.ButtonStateRecorder.lastTimeStateChangedToPressed">
            <summary>
            Returns the last time the button state became pressed exactly.
            Does not return 0 when the button is currently pressed like above.
            </summary>
        </member>
        <member name="P:Rewired.ButtonStateRecorder.lastTimeStateChangedToUnpressed">
            <summary>
            Returns the the last time the button state became unpressed exactly.
            Does not return 0 when the button is currently unpressed like above.
            </summary>
        </member>
        <member name="F:Rewired.PlatformInputManager._DeviceConnectedEvent">
            Events
        </member>
        <member name="M:Rewired.Interfaces.IInputSource.SystemDeviceConnected">
            <summary>
            Only for input sources that get their device connections from without
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IInputSource.SystemDeviceDisconnected">
            <summary>
            Only for input sources that get their device connections from without
            </summary>
        </member>
        <member name="E:Rewired.Interfaces.IInputSource.DeviceChangedEvent">
            <summary>
            Only for input sources that get their device connections from within
            </summary>
        </member>
        <member name="P:Rewired.TouchInfo.isValid">
            <summary>
            Does this contain valid touch data?
            </summary>
        </member>
        <member name="F:Rewired.HardwareControllerMapIdentifier.inputSource">
            <summary>
            This is not necessarily the actual input source of the map if fallbacks happened.
            </summary>
        </member>
        <member name="F:Rewired.HardwareControllerMapIdentifier.actualInputPlatform">
            <summary>
            This is the true specific input platform based on the matched map or default map. This does not necessarily match the inputSource or even the platform!
            </summary>
        </member>
        <member name="M:Rewired.ThreadSafeUnityInput.PostInitialize">
            <summary>
            Runs after this.Initialize and after Input Manager constructors but before they initialize.
            </summary>
        </member>
        <member name="M:Rewired.ThreadSafeUnityInput.Update">
            <summary>
            This should only be called on the main thread.
            </summary>
        </member>
        <member name="T:Rewired.ThreadSafeUnityInput.Keyboard">
            <summary>
            Any class that accesses this MUST call Monitor(true) on initialization and Monitor(false) when finished.
            Monitor acts as a ref count to determine if Unity should be polled.
            </summary>
        </member>
        <member name="T:Rewired.ThreadSafeUnityInput.Mouse">
            <summary>
            Any class that accesses this MUST call Monitor(true) on initialization and Monitor(false) when finished.
            Monitor acts as a ref count to determine if Unity should be polled.
            </summary>
        </member>
        <member name="M:Rewired.LowLevelInputEvent.GetButtonValue(System.Int32)">
            <summary>
            This method is slower than SetButtonsBitMask if checking more than one button value.
            </summary>
            <param name="index">The button index.</param>
            <returns>Button value.</returns>
        </member>
        <member name="T:Rewired.UI.UIAnchor">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.UI.UIPivot">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Internal.GUIText">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.ComponentControls.ComponentControl">
            <summary>
            The base class for component controls.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.ComponentControl.OnUpdate">
            Use instead of Update.
            Update is driven by Controller.
        </member>
        <member name="T:Rewired.ComponentControls.ComponentController">
            <summary>
            The base class for component controllers.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Interfaces.IRegistrar`1">
            <exclude></exclude>
        </member>
        <member name="P:Rewired.ComponentControls.ComponentController.initialized">
            <summary>
            Is the controller initialized?
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.CustomController">
            <summary>
            A component wrapper for a Custom Controller.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.CustomController.InputSourceUpdateEvent">
            <summary>
            Event fired when Rewired's input source update event fires.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.rewiredInputManager">
            <summary>
            (Optional) Link the Rewired Input Manager here for easier access to Custom Controller elements, etc.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.customControllerSelector">
            <summary>
            Contains search parameters to find a particular Custom Controller.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.createCustomControllerSettings">
            <summary>
            Settings for creating a Custom Controller on start.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.CreateCustomControllerSettings.createCustomController">
            <summary>
            If true, a new Custom Controller will be created. Otherwise, an existing Custom Controller will be found using the selector properties.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.CreateCustomControllerSettings.customControllerSourceId">
            <summary>
            The source id of the Custom Controller to create. Get this from the Rewired Input Manager.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.CreateCustomControllerSettings.assignToPlayerId">
            <summary>
            The Player that will be assigned this Custom Controller when it is created.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.CustomController.CreateCustomControllerSettings.destroyCustomController">
            <summary>
            If true, the Custom Controller created by this component will be destroyed when this component is destroyed.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.CustomControllerControl">
            <summary>
            A component control for a Custom Controller.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerElementTarget">
            <summary>
            Used to send input data to a particular Custom Controller element.
            This is mostly useful for allowing the user to select search and 
            other parameters in the inspector.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTarget.element">
            <summary>
            The Custom Controller element.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTarget.valueContribution">
            <summary>
            When feeding a split float value into a Custom Controller Axis, this determines whether the final value is positive or negative.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTarget.invert">
            <summary>
            When feeding a float value into a Custom Conroller Axis, this determines whether the final value is inverted.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerElementTargetSet">
            <summary>
            Used to send input data to a particular Custom Controller element.
            This is mostly useful for allowing the user to select search and 
            other parameters in the inspector.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForBoolean">
            <summary>
            Used to send input data to a particular Custom Controller element.
            This is mostly useful for allowing the user to select search and 
            other parameters in the inspector.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForBoolean.target">
            <summary>
            The target element.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForFloat">
            <summary>
            Used to send input data to a particular Custom Controller element.
            This is mostly useful for allowing the user to select search and 
            other parameters in the inspector.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForFloat.splitValue">
            <summary>
            Splits the value into positive and negative sides which can be assigned to different Custom Controller elements.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForFloat.target">
            <summary>
            The target element. This is unused if splitValue is true.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForFloat.positiveTarget">
            <summary>
            The positive target element. This is unused if splitValue is false.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementTargetSetForFloat.negativeTarget">
            <summary>
            The negative target element. This is unused if splitValue is false.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerElementSelector">
            <summary>
            Provides a means of selecting a particular Custom Controller element.
            This is mostly useful for allowing the user to select search parameters in the inspector.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.Data.CustomControllerElementSelector.GetElementIndex(Rewired.CustomController)">
            <summary>
            Finds the element index for this element in a Custom Controller.
            </summary>
            <param name="customController">The Custom Controller in which to search for the element.</param>
            <returns>Element index</returns>
        </member>
        <member name="M:Rewired.ComponentControls.Data.CustomControllerElementSelector.GetSelectorFormattedString">
            <summary>
            Gets a formatted string for the selector type.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.elementType">
            <summary>
            The target Custom Controller element type.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.selectorType">
            <summary>
            The method to use to look up the target Custom Controller element.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.elementName">
            <summary>
            The target Custom Controller element name.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.elementIndex">
            <summary>
            The target Custom Controller element index.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.elementId">
            <summary>
            The target Custom Controller element id.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerElementSelector.isAssigned">
            <summary>
            Is an element assigned to the selector?
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Data.CustomControllerSelector">
            <summary>
            Provides a means of selecting a particular Custom Controller.
            This is mostly useful for allowing the user to select search parameters in the inspector.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.Data.CustomControllerSelector.GetCustomController">
            <summary>
            Gets the Custom Controller using the current selection parameters.
            </summary>
            <returns>CustomController</returns>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.findUsingSourceId">
            <summary>
            If true, the Custom Controller will be searched for by its source controller id.
            This can be used with findInPlayer and/or findUsingTag to further refine the search parameters.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.sourceId">
            <summary>
            The source id of the Custom Controller. This is used to find the Custom Controller if findUsingSourceId is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.findUsingTag">
            <summary>
            If true, the Custom Controller will be found using the tag specified here.
            This can be used with findInPlayer and/or findUsingSourceId to further refine the search parameters.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.tag">
            <summary>
            The tag on the Custom Controller you wish to use. This is used to find the Custom Controller.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.findInPlayer">
            <summary>
            If true, the Custom Controller will be searched for in the Player specified in the Player Id field.
            This can be used with Find Using Source Id and/or Find Using Tag to further refine the search parameters.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Data.CustomControllerSelector.playerId">
            <summary>
            The Player Id of the Player that owns the Custom Controller.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TiltControl">
            <summary>
            A basic tilt control.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TiltControl.SetAccelerationSourceCallback(System.Func{UnityEngine.Vector3})">
            <summary>
            Replaces the default input source for the acceleration value.
            Sets the delegate callback which will be invoked to retrieve the acceleration value.
            </summary>
            <param name="callback">The callback delegate.</param>
        </member>
        <member name="M:Rewired.ComponentControls.TiltControl.SetRestOrientation">
            <summary>
            Sets the current horizontal and forward rest angles to the current orientation of the device.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.axesToUse">
            <summary>
            The axis directions in which movement is allowed. You can restrict movement to one or both axes.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.horizontalTiltCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from the X axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.horizontalTiltLimit">
            <summary>
            The maximum horizontal tilt angle in degrees. When the device is tilted to this angle or further in either direction, the axis will return a value of 1/-1.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.horizontalRestAngle">
            <summary>
            The offset angle from horizontal which will be considered the resting angle. This represents the angle at which the user holds the device without generating tilt.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.forwardTiltCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from the Y axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.forwardTiltLimit">
            <summary>
            The maximum forward tilt angle in degrees. When the device is tilted to this angle or further in either direction, the axis will return a value of 1/-1.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.forwardRestAngle">
            <summary>
            The offset angle from vertical which will be considered the resting angle. This represents the angle at which the user holds the device without generating tilt. A typical value would be around 40 degrees.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.horizontalAxisCalibration">
            <summary>
            The calibration settings for the horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.verticalAxisCalibration">
            <summary>
            The calibration settings for the vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.deadZoneType">
            <summary>
            The calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TiltControl.axis2DCalibration">
            <summary>
            The calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Effects.RotateAroundAxis">
            <summary>
            Rotates the GameObject around a particular axis.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.Effects.RotateAroundAxis.SetSpeed(Rewired.ComponentControls.Effects.RotateAroundAxis.Speed)">
            <summary>
            Sets the current speed.
            </summary>
            <param name="speed"></param>
        </member>
        <member name="M:Rewired.ComponentControls.Effects.RotateAroundAxis.SetSpeed(System.Int32)">
            <summary>
            Sets the current speed as an integer.
            This method only exists because the Unity event system
            could not call a method with an enum in Unity 5.0.
            </summary>
            <param name="speed">Speed enum as an integer.</param>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.speed">
            <summary>
            The current speed of rotation.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.slowRotationSpeed">
            <summary>
            The speed of rotation when speed is set to Speed.Slow.
            This measured in degrees per second.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.fastRotationSpeed">
            <summary>
            The speed of rotation when speed is set to Speed.Fast.
            This measured in degrees per second.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.rotateAroundAxis">
            <summary>
            The axis around which rotation will occur.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.relativeTo">
            <summary>
            The space in which rotation will occur.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.RotateAroundAxis.reverse">
            <summary>
            Reverses the rotation direction.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Effects.TouchInteractableTransitioner">
            <summary>
            Allows synchronization of transition states between a Touch Interactable and a Graphic.
            Add this component to children of touch controls that need transition states or visibility to remain in sync with the parent.
            This is useful for Text or Image components parented underneath a touch control for example. This allows you to add graphics, text, or other
            decorations on your touch control and have them animate colors, sprite transitions, etc. in sync with the parent control.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchInteractable">
            <summary>
            Base class for interactable touch controls.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchControl">
            <summary>
            The base class for touch controls.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchInteractable.IsTouching(System.Int32)">
            <summary>
            Reteurns whether the pointer id represents a touch/pointer that is actively touching somewhere on the screen.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.InteractionStateSetEvent">
            <summary>
            Event sent when the Interaction State changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.VisibilityChangedEvent">
            <summary>
            Event sent when visibility changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.InteractionStateChangedToNormal">
            <summary>
            Event sent when interaction state changes to Normal.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.InteractionStateChangedToHighlighted">
            <summary>
            Event sent when interaction state changes to Highlighted.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.InteractionStateChangedToPressed">
            <summary>
            Event sent when interaction state changes to Pressed.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchInteractable.InteractionStateChangedToDisabled">
            <summary>
            Event sent when interaction state changes to Disabled.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.interactable">
            <summary>
            Can the control can be interacted with by the user?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.visible">
            <summary>
            Is the control visible? An invisible control can still be interacted with. This property only has any effect when used with an Image Component.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.hideWhenIdle">
            <summary>
            Sets visibility to False when the control is idle. When the control is no longer idle, visibility will be set to True again.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.allowedMouseButtons">
            <summary>
            The mouse buttons that are allowed to interact with this control.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.transitionType">
            <summary>
            The transition type(s) to be used when transitioning to various states. Multiple transition types can be used simultaneously. Denote multiple transition types using bitwise operations.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.transitionColorTint">
            <summary>
            Settings using for Color Tins transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.transitionSpriteState">
            <summary>
            Settings using for Sprite State transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.transitionAnimationTriggers">
            <summary>
            Settings using for Animation Trigger transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.targetGraphic">
            <summary>
            The target Graphic component for interaction state transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.image">
            <summary>
            Gets the Target Graphic as an Image. If the Target Graphic is not an Image, this will return null.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.animator">
            <summary>
            Gets the Animator component on this GameObject. Returns null if no Animator component is found.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchInteractable.interactionState">
            <summary>
            The current interaction state.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.visible">
            <summary>
            Is the control visible? An invisible control can still be interacted with. This property only has any effect when used with an Image Component.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.transitionType">
            <summary>
            The transition type(s) to be used when transitioning to various states. Multiple transition types can be used simultaneously. Denote multiple transition types using bitwise operations.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.transitionColorTint">
            <summary>
            Settings using for Color Tins transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.transitionSpriteState">
            <summary>
            Settings using for Sprite State transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.transitionAnimationTriggers">
            <summary>
            Settings using for Animation Trigger transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.targetGraphic">
            <summary>
            The target Graphic component for interaction state transitions.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.syncFadeDurationWithTransitionEvent">
            <summary>
            Toggles whether the fade duration is set by incoming transition events. If enabled, the duration of fades for visibility and Color Tint transitions will be synchronized with the event sender.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.syncColorTintWithTransitionEvent">
            <summary>
            Toggles whether the color tint is set by incoming transition events. If enabled, the color tint transition of the event sender will override any color tint setting here.
            This setting overrides syncFadeDurationWithTransitionEvent.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.image">
            <summary>
            Gets the Target Graphic as an Image. If the Target Graphic is not an Image, this will return null.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchInteractableTransitioner.animator">
            <summary>
            Gets the Animator component on this GameObject. Returns null if no Animator component is found.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator">
            <summary>
            A visual indicator of the current direction of the joystick.
            This can be used to make arrows or other visual elements light up
            when the joystick is pressed in different directions.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchJoystick">
            <summary>
            A touch joystick control.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.GetValue">
            <summary>
            Gets the calibrated value of the joystick.
            </summary>
            <returns>Calibrated joystick value.</returns>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.GetRawValue">
            <summary>
            Gets the raw value of the joystick.
            </summary>
            <returns>Raw joystick value.</returns>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.SetRawValue(UnityEngine.Vector2)">
            <summary>
            Set the raw value of the joystick.
            </summary>
            <param name="value">Raw joystick value.</param>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.SetDefaultPosition">
            <summary>
            Record the current anchored position as the joystick's default position.
            The joystick will return to this position when released when using a
            Touch Region with moveToTouchPosition set to True.
            If you move the joystick's position and want it to return there next time,
            you should record the new default position by calling this method.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.SetDefaultAnchoredPosition(UnityEngine.Vector2)">
            <summary>
            Set the joystick's default position.
            The joystick will return to this position when released when using a
            Touch Region with moveToTouchPosition set to True.
            If you move the joystick's position and want it to return there next time,
            you should record the new default position by calling this method.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.ReturnToDefaultPosition(System.Boolean)">
            <summary>
            Moves the joystick to the default position.
            </summary>
            <param name="instant">Snap to the position immediately, otherwise use movement animation settings.</param>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.ReturnToDefaultPosition">
            <summary>
            Moves the joystick to the default position.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchJoystick.OnClear">
            <summary>
            Clears the control completely including all internal states.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.horizontalAxisCustomControllerElement">
            <summary>
            The Custom Controller element(s) that will receive input values from the joystick's X axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.verticalAxisCustomControllerElement">
            <summary>
            The Custom Controller element(s) that will receive input values from the joystick's Y axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.tapCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from taps.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.stickTransform">
            <summary>
            The Rect Transform of the stick disc. This is moved around by the user when manipulating the joystick.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.joystickMode">
            <summary>
            The joystick's mode of operation. Set this to Digital to simulate a D-Pad which has only On/Off states. If you want mimic a real D-Pad, you should also set Snap Directions to 8.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.digitalModeDeadZone">
            <summary>
            A dead zone which is applied when Stick Mode is set to Digital. This is used to filter out tiny stick movements near 0, 0.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.stickRange">
            <summary>
            The range of movement of the stick in Canvas pixels. The larger the number, the further the stick must be moved from center to register movement.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.scaleStickRange">
            <summary>
            If enabled, the stick range will scale with parent controls. Otherwise, the stick range will remain constant.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.stickBounds">
            <summary>
            The shape of the range of movement of the joystick.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.axesToUse">
            <summary>
            The axis directions in which movement is allowed. You can restrict movement to one or both axes.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.snapDirections">
            <summary>
            Snaps joystick movement to a fixed number of directions. This can be used to create a D-Pad, for example, setting it to 4 or 8 directions. If you want a true D-Pad, Stick Mode should be set to digital.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.snapStickToTouch">
            <summary>
            If true, the stick disc will snap immediately to the touch position when initially touched. This results in the stick disc being centered to the touch position.
            This will cause the stick to generate input immediately when touched if not touched perfectly centered.
            If false, the stick disc will remain in its current position on touch, and when dragged will retain the same offset.
            The stick's center point will be set to the position of the touch. The initial touch will not cause the stick to pop in any direction.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.centerStickOnRelease">
            <summary>
            If true, the stick will return to the center after it is released. Otherwise, the stick will remain in the last position and continue to return input.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.activateOnSwipeIn">
            <summary>
            If true, the joystick can be activated by a touch swipe that began in an area outside the joystick region. If false, the joystick can only be activated by a direct touch.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.stayActiveOnSwipeOut">
            <summary>
            If true, the joystick will stay engaged even if the touch that activated it moves outside the joystick region.
            If false, the joystick will be released once the touch that activated it moves outside the joystick region.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.allowTap">
            <summary>
            Should taps on the touch pad be processed?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.tapTimeout">
            <summary>
            The maximum touch duration allowed for the touch to be considered a tap.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.tapDistanceLimit">
            <summary>
            The maximum movement distance allowed in pixels since the touch began for the touch to be considered a tap. [-1 = no limit]
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.touchRegion">
            <summary>
            Optional external region to use for hover/click/touch detection. If set, this region will be used for touch detection instead of or in addition to the joystick's RectTransform. This can be useful if you want a larger area of the screen to act as a joystick.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.useTouchRegionOnly">
            <summary>
            If True, hovers/clicks/touches on the local joystick will be ignored and only Touch Region touches will be used. Otherwise, both touches on the joystick and on the Touch Region will be used. This also applies to mouse hover. This setting has no effect if no Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.moveToTouchPosition">
            <summary>
            If True, the joystick will move to the location of the current touch in the Touch Region. This can be used to designate an area of the screen as a hot-spot for a joystick and have the joystick graphics follow the users touches. This only has an effect if a Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.returnOnRelease">
            <summary>
            If Move To Touch Position is enabled, this will make the joystick return to its original position after the press is released. This only has an effect if a Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.followTouchPosition">
            <summary>
            If True, the joystick will follow the touch around until released. This setting overrides Move To Touch Position.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.animateOnMoveToTouch">
            <summary>
            Should the joystick animate when moving to the touch point? This only has an effect if Move To Touch Position is True and a Touch Region is set. This setting is ignored if Follow Touch Position is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.moveToTouchSpeed">
            <summary>
            The speed at which the joystick will move toward the touch position measured in screens per second (based on the larger of width and height). [1.0 = Move 1 screen/sec]. This only has an effect if Move To Touch Position is True, Animate On Move To Touch is true, and a Touch Region is set. This setting is ignored if Follow Touch Position is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.animateOnReturn">
            <summary>
            Should the joystick animate when moving back to its original position? This only has an effect if Follow Touch Position is True, or if Move To Touch Position is True and a Touch Region is set, and Return on Release is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.returnSpeed">
            <summary>
            The speed at which the joystick will move back toward its original position measured in screens per second (based on the larger of width and height). [1.0 = Move 1 screen/sec]. This only has an effect if Follow Touch Position is True, or if Move To Touch Position is True and a Touch Region is set, and Return on Release and Animate on Return are both True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.manageRaycasting">
            <summary>
            If True, it will attempt to automatically manage Graphic component raycasting for best results based on your current settings.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.horizontalAxisCalibration">
            <summary>
            The calibration settings for the horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.verticalAxisCalibration">
            <summary>
            The calibration settings for the vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.deadZoneType">
            <summary>
            The calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.axis2DCalibration">
            <summary>
            The calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.pointerId">
            <summary>
            The pointer id that currently has control of this joystick. If there is no pointer id, the value is TouchControl.POINTER_ID_NULL.
            Only one pointer id (touch, mouse, etc.) may be in control of this joystick at any time.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.hasPointer">
            <summary>
            Is this joystick currently being controlled by a touch or pointer?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchJoystick.axis2D">
            <summary>
            The underlying 2D axis.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchJoystick.ValueChangedEvent">
            <summary>
            Event sent when the joystick value changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchJoystick.StickPositionChangedEvent">
            <summary>
            Event sent when the joystick's stick position changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchJoystick.TapEvent">
            <summary>
            Event sent when the touch pad is tapped.
            This event will only be sent if allowTap is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.visible">
            <summary>
            Is the effect visible?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.targetAngleFromRotation">
            <summary>
            If enabled, the target angle will be determined by the transform's Local Rotation Z. Otherwise, the activation angle must be manually set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.targetAngle">
            <summary>
            The joystick angle at which this object should be considered fully active.\n0 = up with negative values increase rotating clockwise. Example: -45 degrees = up-right.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.fadeWithValue">
            <summary>
            If enabled, the color will fade in and out based on the current joystick value.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.fadeWithAngle">
            <summary>
            If enabled, the color will fade in and out based on the current joystick angle. As the angle approaches the Target Angle, the color will become more intense.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.fadeRange">
            <summary>
            The angle of rotation away from the Target Angle where the color fully fades out. If Fade with Angle is enabled, this is used to determine when the color will fully fade out when the joystick angle rotates away from the the Target Angle.
            This should be set to 1/2 of the complete rotation arc. Example: A value of 45 degrees would make the color fully fade out when the joystick angle is 45 degrees away from the Target Angle on either side, giving a complete arc of 90 degrees.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.activeColor">
            <summary>
            The color when fully active.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.normalColor">
            <summary>
            The color when not active.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.image">
            <summary>
            Gets the Image attached to this GameObject.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.currentSprite">
            <summary>
            Gets the current Sprite being used by the Image component. If an Override Sprite is set, that is returned. Otherwise, the Sprite is returned.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickAngleIndicator.rectTransform">
            <summary>
            Gets the RectTransform attached to this GameObject.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator">
            <summary>
            Arranges child TouchJoystickAngleIndicator objects in a radial pattern.
            It is useful for displaying direction indicators for a Touch Joystick in a radial pattern.
            Assists with scaling and sizing of the child images.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.scale">
            <summary>
            If enabled, the indicators will be scaled based on the size of the RectTransform.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.preserveSpriteAspectRatio">
            <summary>
            If enabled, the aspect ratio will be determined from the Sprite's texture.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.scaleRatio">
            <summary>
            The scale ratio of the indicators to the current RectTransform's height.
            A ratio of 0.1 means the indicator will be 0.1 times the size of the RectTransform's height.
            This is useful if you need to be able to scale the transform and have the indicators also scale with it.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.aspectRatioX">
            <summary>
            The horizontal component of the desired aspect ratio of the indicator.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.aspectRatioY">
            <summary>
            The vertical component of the desired aspect ratio of the indicator.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.offset">
            <summary>
            Offsets the indicator position up by this proportion of its height. 1.0 = 1 unit high offset.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.Effects.TouchJoystickRadialIndicator.rectTransform">
            <summary>
            Gets the RectTransform attached to this GameObject.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchButton">
            <summary>
            A touch button control.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.SetRawValue(System.Single)">
            <summary>
            Set the raw value in the button's axis.
            </summary>
            <param name="value">Raw value</param>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.SetDefaultPosition">
            <summary>
            Record the current anchored position as the button's default position.
            The button will return to this position when released when using a
            Touch Region with moveToTouchPosition set to True.
            If you move the button's position and want it to return there next time,
            you should record the new default position by calling this method.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.SetDefaultAnchoredPosition(UnityEngine.Vector2)">
            <summary>
            Set the button's default position.
            The button will return to this position when released when using a
            Touch Region with moveToTouchPosition set to True.
            If you move the button's position and want it to return there next time,
            you should record the new default position by calling this method.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.ReturnToDefaultPosition(System.Boolean)">
            <summary>
            Moves the button to the default position.
            </summary>
            <param name="instant">Snap to the position immediately, otherwise use movement animation settings.</param>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.ReturnToDefaultPosition">
            <summary>
            Moves the button to the default position.
            </summary>
        </member>
        <member name="M:Rewired.ComponentControls.TouchButton.OnClear">
            <summary>
            Clears the control completely including all internal states.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchButton.AxisValueChangedEvent">
            <summary>
            Event sent when the axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchButton.ButtonValueChangedEvent">
            <summary>
            Event sent when the button value changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchButton.ButtonDownEvent">
            <summary>
            Event sent when the button is pressed.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchButton.ButtonUpEvent">
            <summary>
            Event sent when the button is released
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.targetCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from this control.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.buttonType">
            <summary>
            The type of button.\nStandard = A momentary switch. Returns True while the button is pressed down.\nToggle Switch = Alternately turns on and off with each press.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.activateOnSwipeIn">
            <summary>
            If true, the button can be turned on by a touch swipe that began in an area outside the button region. If false, the button can only be turned on by a direct press.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.stayActiveOnSwipeOut">
            <summary>
            If true, the button will stay on even if the touch that activated it moves outside the button region. If false, the button will turn off once the touch that activated it moves outside the button region.
            If Follow Touch Position is True, this will always return True except in the case of using a Touch Region with Use Touch Region Only set to True also.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.useDigitalAxisSimulation">
            <summary>
            Makes the axis value gradually change over time based on gravity and sensitivity as the button is pressed.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.digitalAxisGravity">
            <summary>
            Speed (units/sec) that the axis value falls toward 0 when not pressed. A value of 1.0 means an axis value of 1 will drain to 0 over 1 second. A value of 3 equates to 1/3 of a second, and so on.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.digitalAxisSensitivity">
            <summary>
            Speed to move toward an axis value of 1.0 in units/sec when pressed. A value of 1.0 means an axis value of 0 will reach 1 over 1 second. A value of 3 equates to 1/3 of a second, and so on.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.touchRegion">
            <summary>
            Optional external region to use for hover/click/touch detection. If set, this region will be used for touch detection instead of or in addition to the button's RectTransform. This can be useful if you want a larger area of the screen to act as a button.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.useTouchRegionOnly">
            <summary>
            If True, hovers/clicks/touches on the local button will be ignored and only Touch Region touches will be used. Otherwise, both touches on the button and on the Touch Region will be used. This also applies to mouse hover. This setting has no effect if no Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.moveToTouchPosition">
            <summary>
            If True, the button will move to the location of the current touch in the Touch Region. This can be used to designate an area of the screen as a hot-spot for a button and have the button graphics follow the users touches. This only has an effect if a Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.returnOnRelease">
            <summary>
            If Move To Touch Position is enabled, this will make the button return to its original position after the press is released. This only has an effect if a Touch Region is set.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.followTouchPosition">
            <summary>
            If True, the button will follow the touch around until released. This setting overrides Move To Touch Position.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.animateOnMoveToTouch">
            <summary>
            Should the button animate when moving to the touch point? This only has an effect if Move To Touch Position is True and a Touch Region is set. This setting is ignored if Follow Touch Position is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.moveToTouchSpeed">
            <summary>
            The speed at which the button will move toward the touch position measured in screens per second (based on the larger of width and height). [1.0 = Move 1 screen/sec]. This only has an effect if Move To Touch Position is True, Animate On Move To Touch is true, and a Touch Region is set. This setting is ignored if Follow Touch Position is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.animateOnReturn">
            <summary>
            Should the button animate when moving back to its original position? This only has an effect if Follow Touch Position is True, or if Move To Touch Position is True and a Touch Region is set, and Return on Release is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.returnSpeed">
            <summary>
            The speed at which the button will move back toward its original position measured in screens per second (based on the larger of width and height). [1.0 = Move 1 screen/sec]. This only has an effect if Follow Touch Position is True, or if Move To Touch Position is True and a Touch Region is set, and Return on Release and Animate on Return are both True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.manageRaycasting">
            <summary>
            If True, it will attempt to automatically manage Graphic component raycasting for best results based on your current settings.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.pointerId">
            <summary>
            The pointer id that currently has control of this button. If there is no pointer id, the value is TouchControl.POINTER_ID_NULL.
            Only one pointer id (touch, mouse, etc.) may be in control of this button at any time.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.hasPointer">
            <summary>
            Is this button currently being controlled by a touch or pointer?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.axis">
            <summary>
            The internal axis of the button. The axis is used for all value calculations.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.axisValue">
            <summary>
            The axis value of the button.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.axisValuePrev">
            <summary>
            The previous axis value of the button. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.buttonValue">
            <summary>
            The value of the button.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchButton.buttonValuePrev">
            <summary>
            The previous value of the button. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchButton.ButtonType">
            <summary>
            Button type
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchButton.ButtonType.Standard">
            <summary>
            A momentary switch. Returns True while the button is pressed down.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchButton.ButtonType.ToggleSwitch">
            <summary>
            Alternately turns on and off with each press.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchController">
            <summary>
            Responsible for managing touch controls and sending data to a Custom Controller.
            A Touch Controller component must exist as the parent of all touch controls.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchController.disableMouseInputWhenEnabled">
            <summary>
            If true, disables mouse input when the Touch Controller script is enabled or GameObject is activated and re-enables mouse input when the script is disabled or GameObject is deactivated. This is useful for disabling Mouse Look controls when using touch controls in an FPS for example.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchController.useCustomController">
            <summary>
            If true, a Custom Controller will be populated with the data from this controller.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchPad">
            <summary>
            A touch pad control.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchPad.ValueChangedEvent">
            <summary>
            Event sent when the value changes.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchPad.TapEvent">
            <summary>
            Event sent when the touch pad is tapped.
            This event will only be sent if allowTap is True.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchPad.PressDownEvent">
            <summary>
            Event sent when the touch pad is initally pressed. This event is for the Press button simulation which must be enabled by setting Press Allowed to True.
            This event will only be sent if allowPress is True.
            </summary>
        </member>
        <member name="E:Rewired.ComponentControls.TouchPad.PressUpEvent">
            <summary>
            Event sent when the touch pad is released after a press. This event is for the Press button simulation which must be enabled by setting Press Allowed to True.
            This event will only be sent if allowPress is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.horizontalAxisCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from the touch pad's X axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.verticalAxisCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from the touch pad's Y axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.tapCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from touch pad taps.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.pressCustomControllerElement">
            <summary>
            The Custom Controller element that will receive input values from touch pad presses.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.axesToUse">
            <summary>
            The axis directions in which movement is allowed. You can restrict movement to one or both axes.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.touchPadMode">
            <summary>
            The mode of the touch pad.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.valueFormat">
            <summary>
            The format of the resulting data generated by the touch pad.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.useInertia">
            <summary>
            If enabled, when swiped and released, the value will slowly fall toward zero based on the Friction value. This only has an effect if touchPadMode is set to TouchPadMode.PositionDelta.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.inertiaFriction">
            <summary>
            Determines how quickly a swipe value will fall toward zero when useInertia is True.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.activateOnSwipeIn">
            <summary>
            If true, the touch pad can be activated by a touch swipe that began in an area outside the touch pad region. If false, the touch pad can only be activated by a direct touch.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.stayActiveOnSwipeOut">
            <summary>
            If true, the touch pad will stay engaged even if the touch that activated it moves outside the touch pad region.
            If false, the touch pad will be released once the touch that activated it moves outside the touch pad region.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.allowTap">
            <summary>
            Should taps on the touch pad be processed?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.tapTimeout">
            <summary>
            The maximum touch duration allowed for the touch to be considered a tap.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.tapDistanceLimit">
            <summary>
            The maximum movement distance allowed in pixels since the touch began for the touch to be considered a tap. [-1 = no limit]
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.allowPress">
            <summary>
            Should presses (continual press like a button) on the touch pad be processed?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.pressStartDelay">
            <summary>
            Time the touch pad must be touched before it will be considered a press.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.pressDistanceLimit">
            <summary>
            The maximum movement distance allowed in pixels since the touch began for the touch to be considered a press. Any movement beyond this value will cancel the press. [-1 = no limit]
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.hideAtRuntime">
            <summary>
            If enabled, the control will be hidden when gameplay starts.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.pointerId">
            <summary>
            The pointer id that currently has control of this control. If there is no pointer id, the value is TouchControl.POINTER_ID_NULL.
            Only one pointer id (touch, mouse, etc.) may be in control of this button at any time.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.hasPointer">
            <summary>
            Is this control currently being controlled by a touch or pointer?
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.touchStartPosition">
            <summary>
            The position of the initial touch.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.touchPosition">
            <summary>
            The current position of the touch.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.horizontalAxisCalibration">
            <summary>
            The calibration settings for the horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.verticalAxisCalibration">
            <summary>
            The calibration settings for the vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.axis2DCalibration">
            <summary>
            The calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchPad.axis2D">
            <summary>
            The underlying 2D axis.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.TouchPadMode.Delta">
            <summary>
            Returns the change in position of the touch from the previous to the current frame.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.TouchPadMode.ScreenPosition">
            <summary>
            Returns the absolute position of the touch on the screen.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.TouchPadMode.VectorFromCenter">
            <summary>
            Returns a vector from the center of the Touch Pad to the current touch position.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.TouchPadMode.VectorFromInitialTouch">
            <summary>
            Returns a vector from the intial touch position to the current touch position.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.ValueFormat.Pixels">
            <summary>
            Screen pixels.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.ValueFormat.Screen">
            <summary>
            The proportion of the value to screen size in the corresponding dimension.
            1 unit = 1 screen length (width for X, height for Y).
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.ValueFormat.Physical">
            <summary>
            1 unit = 1/100th of an inch.
            The resulting value will be consistent across different screen resolutions and sizes.
            IMPORTANT: This relies on the value returned by UnityEngine.Screen.dpi. If the device does not return a value, a reference resolution of 96 dpi will be used.
            </summary>
        </member>
        <member name="F:Rewired.ComponentControls.TouchPad.ValueFormat.Direction">
            <summary>
            A normalized direction vector.
            </summary>
        </member>
        <member name="T:Rewired.ComponentControls.TouchRegion">
            <summary>
            A Touch Region is a control which is used to activate another control remotely.
            This allows you to specify an area of the canvas to be used to activate the control.
            </summary>
        </member>
        <member name="P:Rewired.ComponentControls.TouchRegion.hideAtRuntime">
            <summary>
            If enabled, the Touch Region will be hidden when gameplay starts.
            </summary>
        </member>
        <member name="T:Rewired.Components.ComponentWrapper`1">
            <summary>
            Base class for Component Wrappers.
            This is a MonoBehaviour wrapper for a Rewired object.
            </summary>
            <typeparam name="T">Source object type</typeparam>
        </member>
        <member name="T:Rewired.Components.PlayerController">
            <summary>
            A controller that uses Player Actions as the input sources for controller elements.
            This is a component wrapper for Player Controller which can be added to a GameObject.
            </summary>
        </member>
        <member name="T:Rewired.IPlayerController">
            <summary>
            Interface for a Player Controller.
            </summary>
        </member>
        <member name="M:Rewired.IPlayerController.GetButton(System.Int32)">
            <summary>
            Gets the current value of the button.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The current value of the button.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetButtonDown(System.Int32)">
            <summary>
            Gets the down state of the button. Returns True only on the first frame the button was pressed.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The down state of the button.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetButtonUp(System.Int32)">
            <summary>
            Gets the up state of the button. Returns True only on the first frame the button was released.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The up state of the button.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetAxis(System.Int32)">
            <summary>
            Gets the current axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current axis value.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetAxisRaw(System.Int32)">
            <summary>
            Gets the current raw axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current raw axis value.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetElement(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index.</returns>
        </member>
        <member name="M:Rewired.IPlayerController.GetElement``1(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index or it is not the correct type.</returns>
        </member>
        <member name="P:Rewired.IPlayerController.enabled">
            <summary>
            Is the virtual controller enabled?
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.playerId">
            <summary>
            The Player id of the Player used for the source of input.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.buttons">
            <summary>
            The list of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.axes">
            <summary>
            The list of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.elements">
            <summary>
            The list of Elements of all types in the controller.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.buttonCount">
            <summary>
            The number of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.axisCount">
            <summary>
            The number of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerController.elementCount">
            <summary>
            The number of Elements of all types in the controller.
            </summary>
        </member>
        <member name="E:Rewired.IPlayerController.ButtonStateChangedEvent">
            <summary>
            Triggered the first frame the button is pressed or released.
            </summary>
        </member>
        <member name="E:Rewired.IPlayerController.AxisValueChangedEvent">
            <summary>
            Triggered when the axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.IPlayerController.EnabledStateChangedEvent">
            <summary>
            Triggered when the controller is enabled or disabled.
            </summary>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetButton(System.Int32)">
            <summary>
            Gets the current value of the button.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The current value of the button.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetButtonDown(System.Int32)">
            <summary>
            Gets the down state of the button. Returns True only on the first frame the button was pressed.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The down state of the button.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetButtonUp(System.Int32)">
            <summary>
            Gets the up state of the button. Returns True only on the first frame the button was released.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The up state of the button.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetAxis(System.Int32)">
            <summary>
            Gets the current axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current axis value.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetAxisRaw(System.Int32)">
            <summary>
            Gets the current raw axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current raw axis value.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetElement(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index.</returns>
        </member>
        <member name="M:Rewired.Components.PlayerController.GetElement``1(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index or it is not the correct type.</returns>
        </member>
        <member name="P:Rewired.Components.PlayerController.playerId">
            <summary>
            The Player id of the Player used for the source of input.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.buttons">
            <summary>
            The list of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.axes">
            <summary>
            The list of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.elements">
            <summary>
            The list of Elements of all types in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.buttonCount">
            <summary>
            The number of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.axisCount">
            <summary>
            The number of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerController.elementCount">
            <summary>
            The number of Elements in the controller.
            </summary>
        </member>
        <member name="E:Rewired.Components.PlayerController.ButtonStateChangedEvent">
            <summary>
            Triggered the first frame the button is pressed or released.
            </summary>
        </member>
        <member name="E:Rewired.Components.PlayerController.AxisValueChangedEvent">
            <summary>
            Triggered when the axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.Components.PlayerController.EnabledStateChangedEvent">
            <summary>
            Triggered when the controller is enabled or disabled.
            </summary>
        </member>
        <member name="T:Rewired.Components.PlayerMouse">
            <summary>
            A virtual mouse that can be used to drive a sprite or software mouse pointer.
            It uses a Rewired Player to move the pointer position and as the source for
            the buttons and axes.
            This is a component wrapper for Player Mouse which can be added to a GameObject.
            </summary>
        </member>
        <member name="T:Rewired.IPlayerMouse">
            <summary>
            Interface for a Player Mouse.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.defaultToCenter">
            <summary>
            If enabled, the screen position will default to the center of the allowed movement area.
            Otherwise, it will default to the lower-left corner of the allowed movement area.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.movementArea">
            <summary>
            The allowed movement area for the mouse pointer.
            Set <see cref="P:Rewired.IPlayerMouse.movementAreaUnit"/> to determine the data format of this value.
            This rect is a screen-space rect with 0, 0 at the lower-left corner.
            If you pass a UnityEngine.Rect in which represents 0, 0 as the upper-left corner, Y will automatically be flipped.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.movementAreaUnit">
            <summary>
            The unit format of the movement area.
            This is used to determine the data format of <see cref="P:Rewired.IPlayerMouse.movementArea"/>.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.screenPosition">
            <summary>
            The screen position on the current frame.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.screenPositionPrev">
            <summary>
            The screen position on the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.screenPositionDelta">
            <summary>
            The change in screen position since the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.xAxis">
            <summary>
            The horizontal axis or the first axis.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.yAxis">
            <summary>
            The vertical axis or the second axis.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.wheel">
            <summary>
            The wheel (or the first wheel if multiple exist.)
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.leftButton">
            <summary>
            The left or first button.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.rightButton">
            <summary>
            The right or second button.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.middleButton">
            <summary>
            The middle or third button.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.pointerSpeed">
            <summary>
            The pointer speed. This does not affect the speed of input from the mouse x/y axes if
            useHardwarePointerPosition is enabled. It only affects the speed
            from input sources other than mouse x/y or if mouse x/y are mapped to Actions
            assigned to Axes.
            </summary>
        </member>
        <member name="P:Rewired.IPlayerMouse.useHardwarePointerPosition">
            <summary>
            If enabled, the hardware pointer position will be used for mouse input.
            Otherwise, the position of the pointer will be calculated only from
            the Axis Action values.
            The Player that owns this Player Mouse must have the physical mouse assigned to it in order for the hardware position to be used, ex: player.controllers.hasMouse == true.
            </summary>
        </member>
        <member name="E:Rewired.IPlayerMouse.ScreenPositionChangedEvent">
            <summary>
            Triggers when the screen position changes.
            </summary>
        </member>
        <member name="T:Rewired.UI.IMouseInputSource">
            <summary>
            Interface for a mouse input source for UI interaction.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.defaultToCenter">
            <summary>
            If enabled, the screen position will default to the center of the allowed movement area.
            Otherwise, it will default to the lower-left corner of the allowed movement area.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.clampToMovementArea">
            <summary>
            If enabled, movement will be clamped to the <see cref="P:Rewired.Components.PlayerMouse.movementArea"/>.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.movementArea">
            <summary>
            The allowed movement area for the mouse pointer.
            Set <see cref="P:Rewired.Components.PlayerMouse.movementAreaUnit"/> to determine the data format of this value.
            This rect is a screen-space rect with 0, 0 at the lower-left corner.
            If you pass a UnityEngine.Rect in which represents 0, 0 as the upper-left corner, Y will automatically be flipped.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.movementAreaUnit">
            <summary>
            The unit format of the movement area.
            This is used to determine the data format of <see cref="P:Rewired.Components.PlayerMouse.movementArea"/>.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.screenPosition">
            <summary>
            The screen position on the current frame.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.screenPositionPrev">
            <summary>
            The screen position on the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.screenPositionDelta">
            <summary>
            The change in screen position since the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.xAxis">
            <summary>
            The horizontal axis or the first axis.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.yAxis">
            <summary>
            The vertical axis or the second axis.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.wheel">
            <summary>
            The wheel (or the first wheel if multiple exist.)
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.leftButton">
            <summary>
            The left or first button.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.rightButton">
            <summary>
            The right or second button.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.middleButton">
            <summary>
            The middle or third button.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.pointerSpeed">
            <summary>
            The pointer speed. This does not affect the speed of input from the mouse x/y axes if
            useHardwarePointerPosition is enabled. It only affects the speed
            from input sources other than mouse x/y or if mouse x/y are mapped to Actions
            assigned to Axes.
            </summary>
        </member>
        <member name="P:Rewired.Components.PlayerMouse.useHardwarePointerPosition">
            <summary>
            If enabled, the hardware pointer position will be used for mouse input.
            Otherwise, the position of the pointer will be calculated only from
            the Axis Action values.
            </summary>
        </member>
        <member name="E:Rewired.Components.PlayerMouse.ScreenPositionChangedEvent">
            <summary>
            Triggers when the screen position changes.
            </summary>
        </member>
        <member name="T:Rewired.Config.UpdateLoopSetting">
            <summary>
            The update loop(s) in which input will be updated.
            </summary>
        </member>
        <member name="F:Rewired.Config.UpdateLoopSetting.None">
            <summary>
            Does not update.
            </summary>
        </member>
        <member name="F:Rewired.Config.UpdateLoopSetting.Update">
            <summary>
            Updates in the Update loop.
            </summary>
        </member>
        <member name="F:Rewired.Config.UpdateLoopSetting.FixedUpdate">
            <summary>
            Updates in the FixedUpdate loop.
            </summary>
        </member>
        <member name="F:Rewired.Config.UpdateLoopSetting.OnGUI">
            <summary>
            Updates in the OnGUI loop.
            </summary>
        </member>
        <member name="T:Rewired.Config.ThrottleCalibrationMode">
            <summary>
            Throttle calibration mode.
            </summary>
        </member>
        <member name="F:Rewired.Config.ThrottleCalibrationMode.ZeroToOne">
            <summary>
            Throttles are calibrated to a range of 0 to +1 with 0 being in the fully disengaged position.
            </summary>
        </member>
        <member name="F:Rewired.Config.ThrottleCalibrationMode.NegativeOneToOne">
            <summary>
            Throttles are calibrated to a range of -1 to +1 with 0 being in the center position.
            </summary>
        </member>
        <member name="T:Rewired.Config.LogLevelFlags">
            <summary>
            Log level flags for logging.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevelFlags.Off">
            <summary>
            Nothing is logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevelFlags.Info">
            <summary>
            Information is logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevelFlags.Warning">
            <summary>
            Warnings are logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevelFlags.Error">
            <summary>
            Errors are logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevelFlags.Debug">
            <summary>
            Debug information is logged.
            </summary>
        </member>
        <member name="T:Rewired.Config.LogLevel">
            <exclude></exclude>
            <summary>
            Log levels for logging.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevel.Info">
            <summary>
            Information is logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevel.Warning">
            <summary>
            Warnings are logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevel.Error">
            <summary>
            Errors are logged.
            </summary>
        </member>
        <member name="F:Rewired.Config.LogLevel.Debug">
            <summary>
            Debug information is logged.
            </summary>
        </member>
        <member name="F:Rewired.Consts._keyboardKeyNames">
            <summary>
            /// DO NOT MODIFY THE ORDER OF ELEMENTS OR INSERT ANY! THIS IS USED TO CREATE ELEMENT IDENTIFIER IDS IN SEQUENCE!
            </summary>
        </member>
        <member name="F:Rewired.Consts._keyboardKeyValues">
            <summary>
            Original array! DO NOT WRITE TO THIS!
            DO NOT MODIFY THE ORDER OF ELEMENTS OR INSERT ANY! THIS IS USED TO CREATE ELEMENT IDENTIFIER IDS IN SEQUENCE!
            </summary>
            <exclude></exclude>
        </member>
        <member name="P:Rewired.Consts.unknownJoystickElementIdentifiers_orig">
            <summary>
            Original array! DO NOT WRITE TO THIS!
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Controller">
            <summary>
            The base class for all controllers.
            </summary>
        </member>
        <member name="F:Rewired.Controller.id">
            <summary>
            Rewired unique id of this controller. This is not an index.
            The id is unique among controllers of a specific controller type.
            </summary>
        </member>
        <member name="M:Rewired.Controller.GetElementById(System.Int32)">
            <summary>
            Gets the Element with the specified element identifier id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>The Element with the specified element idenfitier id. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonIndexById(System.Int32)">
            <summary>
            Gets the index of the Button with the specified element idenfitier id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>The index of the Button with the specified element idenfitier id. Returns -1 if not found.</returns>
        </member>
        <member name="M:Rewired.Controller.GetElementIdentifierById(System.Int32)">
            <summary>
            Gets a Controller Element Identifier by id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>Controller Element Identifier with the specified id. Returns null if none found.</returns>
        </member>
        <member name="M:Rewired.Controller.GetButton(System.Int32)">
            <summary>
            Gets the button held state of the hardware button at the specified index. This will return TRUE as long as the button is held.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="index">Button index</param>
            <returns>Button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDown(System.Int32)">
            <summary>
            Gets the button just pressed state of the hardware button at the specified index. This will only return TRUE only on the first frame the button is pressed
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="index">Button index</param>
            <returns>Button just pressed state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonUp(System.Int32)">
            <summary>
            Gets the button just released state of the hardware button at the specified index. This will only return TRUE only on the first frame the button is released
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="index">Button index</param>
            <returns>Button just released state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonChanged(System.Int32)">
            <summary>
            Returns true if the button has changed state from the previous frame to the current.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="index">Button index</param>
            <returns>Button changed state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonPrev(System.Int32)">
            <summary>
            Gets the previous button held state of the hardware button at the specified index. This will return TRUE if the button was held in the previous frame.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="index">Button index</param>
            <returns>Previous button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressHold(System.Int32)">
            <summary>
            Gets the double press and hold state of the button at the specified index.
            This will return TRUE after the double press is detected and for as long as the button is held thereafter.
            This will use the default double press speed.
            </summary>
            <param name="index">Button index</param>
            <returns>Button double press and hold state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressHold(System.Int32,System.Single)">
            <summary>
            Gets the double press and hold state of the button at the specified index.
            This will return TRUE after the double press is detected and for as long as the button is held thereafter.
            </summary>
            <param name="index">Button index</param>
            <param name="speed">Double press speed in seconds</param>
            <returns>Button double press and hold state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressDown(System.Int32)">
            <summary>
            Gets the double press down state of the button at the specified index.
            This will return TRUE only on the first frame the double press is detected.
            This will use the default double press speed.
            </summary>
            <param name="index">Button index</param>
            <returns>Button double press down state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressDown(System.Int32,System.Single)">
            <summary>
            Gets the double press down state of the button at the specified index.
            This will return TRUE only on the first frame the double press is detected.
            </summary>
            <param name="index">Button index</param>
            <param name="speed">Double press speed in seconds</param>
            <returns>Button double press down state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonTimePressed(System.Int32)">
            <summary>
            Gets the length of time the button at index has been active.
            </summary>
            <param name="index">index</param>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonTimeUnpressed(System.Int32)">
            <summary>
            Gets the length of time the button at index has been inactive.
            </summary>
            <param name="index">index</param>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonLastTimePressed(System.Int32)">
            <summary>
            Gets the last timestamp the button at index was active.
            </summary>
            <param name="index">index</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonLastTimeUnpressed(System.Int32)">
            <summary>
            Gets the last timestamp the button at index was inactive.
            </summary>
            <param name="index">index</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetAnyButton">
            <summary>
            Gets the button held state of any hardware button. This will return TRUE as long as any button is held.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <returns>Button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetAnyButtonDown">
            <summary>
            Gets the button just pressed state of any hardware button. This will only return TRUE only on the first frame the button is pressed
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <returns>Button just pressed state</returns>
        </member>
        <member name="M:Rewired.Controller.GetAnyButtonUp">
            <summary>
            Gets the button just released state of any hardware button. This will only return TRUE only on the first frame the button is released
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <returns>Button just released state</returns>
        </member>
        <member name="M:Rewired.Controller.GetAnyButtonPrev">
            <summary>
            Gets the previous button held state of any hardware button. This will return TRUE if any button was held in the previous frame.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <returns>Previous button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetAnyButtonChanged">
            <summary>
            Returns true if any button has changed state from the previous frame to the current.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <returns>Button changed state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonById(System.Int32)">
            <summary>
            Gets the button held state of the hardware button at the specified element identifier id. This will return TRUE as long as the button is held.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDownById(System.Int32)">
            <summary>
            Gets the button just pressed state of the hardware button at the specified element identifier id. This will only return TRUE only on the first frame the button is pressed
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Button just pressed state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonUpById(System.Int32)">
            <summary>
            Gets the button just released state of the hardware button at the specified element identifier id. This will only return TRUE only on the first frame the button is released
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Button just released state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressHoldById(System.Int32,System.Single)">
            <summary>
            Gets the double press and hold state of the button at the specified element identifier id.
            This will return TRUE after the double press is detected and for as long as the button is held thereafter.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <param name="speed">Double press speed in seconds</param>
            <returns>Button double press and hold state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressDownById(System.Int32,System.Single)">
            <summary>
            Gets the double press down state of the button at the specified element identifier id.
            This will return TRUE only on the first frame the double press is detected.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <param name="speed">Double press speed in seconds</param>
            <returns>Button double press down state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressHoldById(System.Int32)">
            <summary>
            Gets the double press and hold state of the button at the specified element identifier id.
            This will return TRUE after the double press is detected and for as long as the button is held thereafter.
            This will use the default double press speed.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Button double press and hold state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonDoublePressDownById(System.Int32)">
            <summary>
            Gets the double press down state of the button at the specified element identifier id.
            This will return TRUE only on the first frame the double press is detected.
            This will use the default double press speed.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Button double press down state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonPrevById(System.Int32)">
            <summary>
            Gets the previous button held state of the hardware button at the specified element identifier id. This will return TRUE if the button was held in the previous frame.
            This does not take into acount any controller mapping or Actions -- this is the unmapped physical button value only.
            Use the Player class to get button values mapped to Actions.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Previous button held state</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonTimePressedById(System.Int32)">
            <summary>
            Gets the length of time the button with the element identifier id has been active.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonTimeUnpressedById(System.Int32)">
            <summary>
            Gets the length of time the button with the element identifier id has been inactive.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonLastTimePressedById(System.Int32)">
            <summary>
            Gets the last timestamp the button with the element identifier id was active.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetButtonLastTimeUnpressedById(System.Int32)">
            <summary>
            Gets the last timestamp the button with the element identifier id was inactive.
            </summary>
            <param name="elementIdentifierId">Element identifier id</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeActive">
            <summary>
            Gets the last timestamp any button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeActive(System.Boolean)">
            <summary>
            Gets the last timestamp any button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <param name="useRawValues">Use raw axis values</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeAnyElementChanged">
            <summary>
            Gets the last timestamp any element changed state.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeAnyElementChanged(System.Boolean)">
            <summary>
            Gets the last timestamp any element changed state.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            <param name="useRawValues">Use raw axis values</param>
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeAnyButtonPressed">
            <summary>
            Gets the last timestamp any button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetLastTimeAnyButtonChanged">
            <summary>
            Gets the last timestamp any button's state changed.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.Controller.GetExtension``1">
            <summary>
            Gets an object used to access controller and platform-specific controller functions.
            </summary>
            <typeparam name="T">Type</typeparam>
            <returns>Extension</returns>
        </member>
        <member name="M:Rewired.Controller.GetTemplate(System.Guid)">
            <summary>
            Gets a Controller Template by type GUID.
            </summary>
            <param name="typeGuid">Controller Template type GUID</param>
            <returns>Returns the Controller Template if it exists in the Controller, null if it does not.</returns>
        </member>
        <member name="M:Rewired.Controller.GetTemplate(System.Type)">
            <summary>
            Gets a Controller Template by type.
            </summary>
            <param name="type">Controller Template type</param>
            <returns>Returns the Controller Template if it exists in the Controller, null if it does not.</returns>
        </member>
        <member name="M:Rewired.Controller.GetTemplate``1">
            <summary>
            Gets the first Controller Template that implements the specified type.
            Note that it is possible to have multiple Controller Templates that implement a specific type of interface
            such as IControllerTemplate. You should use the most specific interface type possible such as IDualAnalogGamepadTemplate instead,
            which would be guaranteed to only apply to a single Controller Template.
            </summary>
            <typeparam name="T">Controller Template interface type</typeparam>
            <returns>Returns the Controller Template if it exists in the Controller, null if it does not.</returns>
        </member>
        <member name="M:Rewired.Controller.ImplementsTemplate(System.Guid)">
            <summary>
            Determines if the Controller implements a Controller Template by type GUID.
            </summary>
            <param name="typeGuid">Controller Template type GUID</param>
            <returns>True if the Controller implements the Controller Template type, false if it does not.</returns>
        </member>
        <member name="M:Rewired.Controller.ImplementsTemplate(System.Type)">
            <summary>
            Determines if the Controller implements a Controller Template by type.
            </summary>
            <param name="type">Controller Template type</param>
            <returns>True if the Controller implements the Controller Template type, false if it does not.</returns>
        </member>
        <member name="M:Rewired.Controller.ImplementsTemplate``1">
            <summary>
            Determines if the Controller implements a Controller Template by type.
            </summary>
            <typeparam name="T">Controller Template type</typeparam>
            <returns>True if the Controller implements the Controller Template type, false if it does not.</returns>
        </member>
        <member name="P:Rewired.Controller.enabled">
            <summary>
            Is the controller enabled? Disabled controllers return no input.
            </summary>
        </member>
        <member name="P:Rewired.Controller.name">
            <summary>
            The name of the controller. This is drawn from the controller definition for recognized controllers. For unrecognized controllers, the name returned by the hardware is used instead.
            </summary>
        </member>
        <member name="P:Rewired.Controller.tag">
            <summary>
            The tag assigned to the controller. Can be used for find a controller by tag.
            </summary>
        </member>
        <member name="P:Rewired.Controller.hardwareName">
            <summary>
            The name the controller hardware returns.
            </summary>
        </member>
        <member name="P:Rewired.Controller.type">
            <summary>
            The type of this controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.hardwareTypeGuid">
            <summary>
            The Rewired GUID associated with this device. A GUID of all zeros is an Unknown Controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.deviceInstanceGuid">
            <summary>
            The unique persistent instance GUID of this device.
            This is an id generated for the device that may stay constant between application sessions and system restarts.
            This can be used for device assignment persistence between runs. The specific platform and input sources in use
            affects the reliability of this value for device assignment persistence.
            A value of Guid.Empty means the device or input source has no reliable unique identifier so persistant assignment
            isn't possible using this value. Even if a Guid is provided, reliability when multiple identical controllers are
            attached depends greatly on the platform and input source(s) currently in use.
            </summary>
        </member>
        <member name="P:Rewired.Controller.identifier">
            <summary>
            Gets identifying information about the Controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.isConnected">
            <summary>
            Is the controller connected?
            </summary>
        </member>
        <member name="P:Rewired.Controller.hardwareIdentifier">
            <summary>
            String of information from the controller used for identifying unknown controller maps for saving/loading.
            </summary>
        </member>
        <member name="P:Rewired.Controller.mapTypeString">
            <summary>
            String representation of the controller map type. Can be used for saving/loading.
            </summary>
        </member>
        <member name="P:Rewired.Controller.elementCount">
            <summary>
            The Element count in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.buttonCount">
            <summary>
            The Button count in the controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Elements">
            <summary>
            List of all Elements in this controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Buttons">
            <summary>
            List of Buttons in this controller.
            </summary>
        </member>
        <member name="P:Rewired.Controller.extension">
            <summary>
            Gets an object used to access controller and platform-specific controller functions.
            </summary>
        </member>
        <member name="P:Rewired.Controller.ElementIdentifiers">
            <summary>
            Gets a list of all element identifiers of all types.
            </summary>
        </member>
        <member name="P:Rewired.Controller.ButtonElementIdentifiers">
            <summary>
            Gets a list of all Button element identifiers.
            There is always one element identifier per Button
            which is at the same index as the corresponding Button.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Templates">
            <summary>
            The Controller Templates that the Controller implements.
            </summary>
        </member>
        <member name="P:Rewired.Controller.templateCount">
            <summary>
            The Template count in the controller.
            </summary>
        </member>
        <member name="T:Rewired.Controller.Element">
            <summary>
            The base class for all controller elements.
            </summary>
        </member>
        <member name="F:Rewired.Controller.Element.id">
            <summary>
            The element identifier id.
            </summary>
        </member>
        <member name="F:Rewired.Controller.Element.name">
            <summary>
            The element name.
            </summary>
        </member>
        <member name="F:Rewired.Controller.Element.type">
            <summary>
            The element type.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Element.elementIdentifier">
            <summary>
            The controller element identifier.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Element.isMemberElement">
            <summary>
            Returns True if the element is a member of a compound element such as an Axis2D.
            </summary>
        </member>
        <member name="T:Rewired.Controller.Axis">
            <summary>
            An Axis controller element.
            </summary>
        </member>
        <member name="M:Rewired.Controller.Axis.GetCalibratedValueForPolling(Rewired.UpdateLoopType,Rewired.AxisCalibration)">
            <summary>
            Ignores sensitivity settings and Axis2D calibration is not applied.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeActive">
            <summary>
            Gets the last time the axis was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeActiveRaw">
            <summary>
            Gets the last time the axis was active based on raw value.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeInactive">
            <summary>
            Gets the last time the axis was inactive.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeInactiveRaw">
            <summary>
            Gets the last time the axis was inactive based on raw value.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeValueChanged">
            <summary>
            Gets the last time the axis value changed.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.lastTimeValueChangedRaw">
            <summary>
            Gets the last time the axis value changed based on raw value.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.timeActive">
            <summary>
            The time in seconds this axis has been active.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.timeActiveRaw">
            <summary>
            The time in seconds this axis has been active based on raw value.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.timeInactive">
            <summary>
            The time in seconds this axis has been ainctive.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.timeInactiveRaw">
            <summary>
            The time in seconds this axis has been inactive based on raw value.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis.pollingDeadZone">
            <summary>
            The polling dead zone used when polling the axis.
            In order for the axis to be detected when polling, the change in absolute value
            of the axis over the polling period must be greater than this amount.
            Do not set this value extremely low or noisy axes will be detected when at rest.
            A value of -1 means the default global polling dead zone will be used instead.
            [Default = -1]
            </summary>
        </member>
        <member name="T:Rewired.Controller.Button">
            <summary>
            A Button controller element.
            </summary>
        </member>
        <member name="M:Rewired.Controller.Button.DoublePressedAndHeld(System.Single)">
            <summary>
            Was this button double pressed and then held? Returns true until released.
            <param name="speed">Required double press speed in seconds for a double press to be registered.</param>
            <returns>Boolean</returns>
            </summary>
        </member>
        <member name="M:Rewired.Controller.Button.JustDoublePressed(System.Single)">
            <summary>
            Was this button just double pressed this frame? Returns true for only one frame.
            <param name="speed">Required double press speed in seconds for a double press to be registered.</param>
            <returns>Boolean</returns>
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.valuePrev">
            <summary>
            The state of the button in the previous frame
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.value">
            <summary>
            The current state of the button.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.pressure">
            <summary>
            The current pressure on the button. [0.0 - 1.0]
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.pressurePrev">
            <summary>
            The pressure on the button in the previous frame. [0.0 - 1.0]
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.isPressureSensitive">
            <summary>
            Is this button pressure sensitive?
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.justPressed">
            <summary>
            Was this button just pressed this frame? Returns true for only one frame. Functions the same as GetButtonDown.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.justReleased">
            <summary>
            Was this button just released this frame? Returns true for only one frame. Functions the same as GetButtonUp.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.justChangedState">
            <summary>
            Returns true if the button was just pressed or just released. Returns true for only one frame.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.doublePressedAndHeld">
            <summary>
            Was this button double pressed and then held? Returns true until released.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.justDoublePressed">
            <summary>
            Was this button just double pressed this frame? Returns true for only one frame.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.timePressed">
            <summary>
            The time in seconds this button has been active.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.timeUnpressed">
            <summary>
            The time in seconds this button has been inactive.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.lastTimePressed">
            <summary>
            Gets the last time the button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.lastTimeUnpressed">
            <summary>
            Gets the last time the button was inactive.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.lastTimeStateChanged">
            <summary>
            Gets the last time the button changed state.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Button.state">
            <summary>
            Gets the button state flags.
            </summary>
        </member>
        <member name="T:Rewired.Controller.CompoundElement">
            <summary>
            Base class for compound elements. Compound elements are a combination of existing elements such as 2 axes making up an Axis 2D.
            Compound elements have no value in and of themselves, but combine values from their member elements to produce a result.
            Compound elements cannot be mapped with an ActionElementMap. Instead, the component axes are each mapped individually.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.id">
            <summary>
            The element identifier id.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.name">
            <summary>
            The name of this element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.type">
            <summary>
            The type of this element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.hasElements">
            <summary>
            Does this compound element have any member elements?
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.elementCount">
            <summary>
            The number of member elements in this compound element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.elementCapacity">
            <summary>
            The maximum capacity of memober elements in this compound element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.CompoundElement.elementIdentifier">
            <summary>
            The controller element identifier.
            </summary>
        </member>
        <member name="T:Rewired.Controller.Axis2D">
            <summary>
            Axis 2D is a combination of values from two individual Axes. This is primarily used for analog sticks.
            A radial deadzone is applied to the combined values. The deazone is the larger of the two deadzones set in the individual axes.
            Axis 2D cannot be mapped with an ActionElementMap. Instead, the component axes are each mapped individually.
            When two Axes are combined into an Axis2D, the values of the individual Axes are changed to reflect the radial deadzone applied by the parent Axis2D.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.elementCapacity">
            <summary>
            The maximum number of member Axes of Axis2D.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.xAxis">
            <summary>
            The X Axis element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.yAxis">
            <summary>
            The Y Axis element.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.value">
            <summary>
            The combined current value of the X and Y axes.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.valuePrev">
            <summary>
            The combined value of the X and Y axes from the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.valueRaw">
            <summary>
            The combined current raw value of the X and Y axes.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Axis2D.valueRawPrev">
            <summary>
            The combined raw value of the X and Y axes from the previous frame.
            </summary>
        </member>
        <member name="T:Rewired.Controller.Hat">
            <summary>
            A hat is a compound element made up of 4 or 8 individual buttons.
            If this is a 4-way hat, only up, down, right, and left are supported. Corner presses will activate the two cardinal directions.
            If this is an 8-way hat, all 8 directions are supported. Corner presses will activate the corner buttons.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.elementCapacity">
            <summary>
            The maximum number of member Buttons of the Hat.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.force4Way">
            <summary>
            Force this hat to behave as a 4-way hat. This only has any effect if the hat is an 8-way hat.
            If enabled, the corner directions will activate the adjacent 2 cardinal direction buttons instead of the corner button.
            This is useful if you need the hat to behave like a D-Pad instead of an 8-way hat.
            If the global ReInput.configuration.force4WayHats is enabled, setting this to false will have no effect as the global flag overrides this value.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.directionCount">
            <summary>
            The number of directions supported by this hat.
            This can be 4, 8, or 0.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.Buttons">
            <summary>
            Gets the list of member buttons.
            There is one entry for each possible direction button in this hat.
            Check directionCount to determine whether this is a 4 or 8-way hat.
            Entries may be null if no button is assigned to a direction.
            The order of the buttons starts at up and rotates clockwise.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonUp">
            <summary>
            The button for the up direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonRight">
            <summary>
            The button for the right direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonDown">
            <summary>
            The button for the down direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonLeft">
            <summary>
            The button for the left direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonUpRight">
            <summary>
            The button for the up-right direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonDownRight">
            <summary>
            The button for the down-right direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonDownLeft">
            <summary>
            The button for the down-left direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Controller.Hat.buttonUpLeft">
            <summary>
            The button for the up-left direction. This value may be null if no button is assigned.
            </summary>
        </member>
        <member name="T:Rewired.Controller.Extension">
            <summary>
            A class that can be used as a base class to allow for special controller or platform-specific functions in a controller.
            </summary>
        </member>
        <member name="M:Rewired.Controller.Extension.GetController``1">
            <summary>
            Gets the parent controller.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Rewired.Controller.Extension.SetController(Rewired.Controller)">
            <summary>
            Sets the parent controller of the controller extension. This can only be set once.
            </summary>
            <param name="controller">Parent controller</param>
        </member>
        <member name="P:Rewired.Controller.Extension.controller">
            <summary>
            The parent controller of this extension.
            </summary>
        </member>
        <member name="T:Rewired.ControllerWithAxes">
            <summary>
            A controller with buttons and axes.
            </summary>
        </member>
        <member name="T:Rewired.ControllerWithMap">
            <summary>
            The contents of this class have been moved into Conroller.
            This class no longer serves any purpose and may be removed in the future.
            </summary>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetElementById(System.Int32)">
            <summary>
            Gets the Element with the specified element identifier id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>The Element with the specified element idenfitier id. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisIndexById(System.Int32)">
            <summary>
            Gets the index of the Axis with the specified element idenfitier id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>The index of the Axis with the specified element idenfitier id. Returns -1 if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxis(System.Int32)">
            <summary>
            Gets the current axis value.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisPrev(System.Int32)">
            <summary>
            Gets the axis value from the previous frame.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisRaw(System.Int32)">
            <summary>
            Gets the current raw axis value. Excludes calibration.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisRawPrev(System.Int32)">
            <summary>
            Gets the raw axis value from the previous frame.. Excludes calibration.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisById(System.Int32)">
            <summary>
            Gets the current axis value.
            </summary>
            <param name="elementIdentifierId">Element identifier id of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisPrevById(System.Int32)">
            <summary>
            Gets the axis value from the previous frame.
            </summary>
            <param name="elementIdentifierId">Element identifier id of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisRawById(System.Int32)">
            <summary>
            Gets the current raw axis value. Excludes calibration.
            </summary>
            <param name="elementIdentifierId">Element identifier id of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxisRawPrevById(System.Int32)">
            <summary>
            Gets the raw axis value from the previous frame.. Excludes calibration.
            </summary>
            <param name="elementIdentifierId">Element identifier id of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxis2D(System.Int32)">
            <summary>
            Gets the current 2D axis value.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>2D Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxis2DPrev(System.Int32)">
            <summary>
            Gets the 2D axis value from the previous frame.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>2D Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxis2DRaw(System.Int32)">
            <summary>
            Gets the current raw 2D axis value. Excludes calibration.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>2D Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetAxis2DRawPrev(System.Int32)">
            <summary>
            Gets the raw 2D axis value from the previous frame.. Excludes calibration.
            </summary>
            <param name="index">Index of Axis</param>
            <returns>Axis value [-1.0 to 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeActive">
            <summary>
            Gets the last timestamp any axis or button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeActive(System.Boolean)">
            <summary>
            Gets the last timestamp any axis or button was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <param name="useRawValues">Use raw axis values</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyElementChanged">
            <summary>
            Gets the last timestamp any element changed state.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyElementChanged(System.Boolean)">
            <summary>
            Gets the last timestamp any element changed state.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            <param name="useRawValues">Use raw axis values</param>
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyAxisActive">
            <summary>
            Gets the last timestamp any axis was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyAxisActive(System.Boolean)">
            <summary>
            Gets the last timestamp any axis was active.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <param name="useRawValues">Use raw axis values</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyAxisChanged">
            <summary>
            Gets the last timestamp any axis changed value.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.GetLastTimeAnyAxisChanged(System.Boolean)">
            <summary>
            Gets the last timestamp any axis changed value.
            NOTE: If comparing time against current time, always compare to ReInput.time.unscaledTime.
            </summary>
            <param name="useRawValues">Use raw axis values</param>
            <returns>Timestamp</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.ImportCalibrationMapFromXmlString(System.String)">
            <summary>
            Imports a Calibration Map from XML.
            </summary>
            <param name="xmlString">The XML string.</param>
            <returns>Returns true on success, false on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerWithAxes.ImportCalibrationMapFromJsonString(System.String)">
            <summary>
            Imports a Calibration Map from JSON.
            </summary>
            <param name="jsonString">The JSON string.</param>
            <returns>Returns true on success, false on failure.</returns>
        </member>
        <member name="P:Rewired.ControllerWithAxes.axisCount">
            <summary>
            The axis count in the controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerWithAxes.axis2DCount">
            <summary>
            The Axis2D count in the controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerWithAxes.Axes">
            <summary>
            List of axes in this controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerWithAxes.Axes2D">
            <summary>
            List of Axis2Ds in this controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerWithAxes.calibrationMap">
            <summary>
            The Calibration Map in this controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerWithAxes.AxisElementIdentifiers">
            <summary>
            Gets a list of all Axis element identifiers.
            There is always one element identifier per Axis
            which is at the same index as the corresponding Axis.
            </summary>
        </member>
        <member name="T:Rewired.CustomController">
            <summary>
            A virtual controller with a user-defined input source.
            </summary>
        </member>
        <member name="M:Rewired.CustomController.SetAxisValue(System.Int32,System.Single)">
            <summary>
            Sets the value of an Axis by index.
            </summary>
            <param name="index">The index of the Axis</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetAxisValue(System.String,System.Single)">
            <summary>
            Sets the value of an Axis by name.
            </summary>
            <param name="elementName">The name of the Axis.</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetAxisValueById(System.Int32,System.Single)">
            <summary>
            Sets the value of an Axis by id.
            </summary>
            <param name="elementId">The id of the Axis. The id can be found in the Rewired Input Manager Custom Controller properties.</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetButtonValue(System.Int32,System.Boolean)">
            <summary>
            Sets the value of a Button by index.
            </summary>
            <param name="index">The index of the Button</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetButtonValue(System.String,System.Boolean)">
            <summary>
            Sets the value of an Button by name.
            </summary>
            <param name="elementName">The name of the Button</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetButtonValueById(System.Int32,System.Boolean)">
            <summary>
            Sets the value of an Button by id.
            </summary>
            <param name="elementId">The id of the Button. The id can be found in the Rewired Input Manager Custom Controller properties.</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Rewired.CustomController.SetAxisUpdateCallback(System.Func{System.Int32,System.Single})">
            <summary>
            Sets the callback delegate which is invoked when an Axis is updated.
            </summary>
            <param name="callback">The callback delegate</param>
        </member>
        <member name="M:Rewired.CustomController.SetButtonUpdateCallback(System.Func{System.Int32,System.Boolean})">
            <summary>
            Sets the callback delegate which is invoked when a Button is updated.
            </summary>
            <param name="callback">The callback delegate</param>
        </member>
        <member name="M:Rewired.CustomController.ClearAxisValue(System.Int32)">
            <summary>
            Clears the Axis value.
            </summary>
            <param name="index">The index of the Axis.</param>
        </member>
        <member name="M:Rewired.CustomController.ClearAxisValue(System.String)">
            <summary>
            Clears the Axis value.
            </summary>
            <param name="elementName">The name of the Axis.</param>
        </member>
        <member name="M:Rewired.CustomController.ClearAxisValueById(System.Int32)">
            <summary>
            Clears the Axis value.
            </summary>
            <param name="elementId">The id of the Axis. The id can be found in the Rewired Input Manager Custom Controller properties.</param>
        </member>
        <member name="M:Rewired.CustomController.ClearButtonValue(System.Int32)">
            <summary>
            Clears the Button value.
            </summary>
            <param name="index">The index of the Button.</param>
        </member>
        <member name="M:Rewired.CustomController.ClearButtonValue(System.String)">
            <summary>
            Clears the Button value.
            </summary>
            <param name="elementName">The name of the Button.</param>
        </member>
        <member name="M:Rewired.CustomController.ClearButtonValueById(System.Int32)">
            <summary>
            Clears the Button value.
            </summary>
            <param name="elementId">The id of the Button. The id can be found in the Rewired Input Manager Custom Controller properties.</param>
        </member>
        <member name="P:Rewired.CustomController.deviceInstanceGuid">
            <summary>
            The unique persistent instance GUID of this device.
            This is an id generated for the device that may stay constant between application sessions and system restarts.
            This can be used for device assignment persistence between runs. The specific platform and input sources in use
            affects the reliability of this value for device assignment persistence.
            A value of Guid.Empty means the device or input source has no reliable unique identifier so persistant assignment
            isn't possible using this value. Even if a Guid is provided, reliability when multiple identical controllers are
            attached depends greatly on the platform and input source(s) currently in use.
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualSenseMicrophoneLightMode">
            <summary>
            Dual Sense controller microphone light mode.
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseMicrophoneLightMode.Off">
            <summary>
            Off
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseMicrophoneLightMode.On">
            <summary>
            On
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseMicrophoneLightMode.Flash">
            <summary>
            Flash
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualSenseOtherLightBrightness">
            <summary>
            Dual Sense controller player and microphone light brightness.
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseOtherLightBrightness.Low">
            <summary>
            Low
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseOtherLightBrightness.Medium">
            <summary>
            Medium
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSenseOtherLightBrightness.High">
            <summary>
            High
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualSensePlayerLightFlags">
            <summary>
            Dual Sense controller player light flags.
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.One">
            <summary>
            Light #1
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.Two">
            <summary>
            Light #2
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.Three">
            <summary>
            Light #3
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.Four">
            <summary>
            Light #4
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualSensePlayerLightFlags.Five">
            <summary>
            Light #5
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualSenseExtension">
            <summary>
            Allows access to controller-specific functions such as vibration.
            </summary>
        </member>
        <member name="T:Rewired.Interfaces.IControllerVibrator">
            <summary>
            Interface for controller vibration.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Interfaces.IControllerVibrator.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="P:Rewired.Interfaces.IControllerVibrator.vibrationMotorCount">
            <summary>
            Number of vibration motors in the controller.
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.IDualShock4Extension">
            <summary>
            Common interface for PS4 platform and desktop platform DualShock 4 Controller Extensions.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetAccelerometerValue">
            <summary>
            Gets the value from the accelerometer converted to Unity's coordinate system.
            The value returned could be thought of as a gravity vector and user acceleration combined.
            If using this value to apply a force in the direction of the vector, invert each axis first.
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetAccelerometerValueRaw">
            <summary>
            Gets the raw value from the accelerometer as reported by the device.
            Note: Device coordinate system does not match Unity's.
            </summary>
            <returns>Raw accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetGyroscopeValueRaw">
            <summary>
            Gets the raw value from the gyroscope as reported by the device.
            Note: Device coordinate system does not match Unity's.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetGyroscopeValue">
            <summary>
            Gets the value from the gyroscope converted to Unity's coordinate system.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetOrientation">
            <summary>
            Gets the orientation converted to Unity's coordinate system.
            </summary>
            <returns>Orientation</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.ResetOrientation">
            <summary>
            Resets the orientation.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.SetLightColor(UnityEngine.Color)">
            <summary>
            Sets the light color. Alpha can be used to set intensity.
            </summary>
            <param name="color">Light color</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.SetLightColor(System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.SetLightColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
            <param name="intensity">Intensity [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetTouchId(System.Int32)">
            <summary>
            Gets the touch id for the touch at the specified index.
            </summary>
            <param name="index">Index of the touch</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetTouchPosition(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.GetTouchPositionByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.IsTouching(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="index">The index of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.IsTouchingByTouchId(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="touchId">The id of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.IDualShock4Extension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="leftMotorDuration">Length of time in seconds to activate the left motor before it stops. [0 = Infinite]</param>
            <param name="rightMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="P:Rewired.ControllerExtensions.IDualShock4Extension.maxTouches">
            <summary>
            Number of simultaneous touches supported by this device.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.IDualShock4Extension.touchCount">
            <summary>
            The current touch count.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetVibration(Rewired.ControllerExtensions.DualShock4MotorType)">
            <summary>
            Gets vibration level for a specific motor.
            </summary>
            <param name="motor">Motor type</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="leftMotorDuration">Length of time in seconds to activate the left motor before it stops. [0 = Infinite]</param>
            <param name="rightMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetLightColor">
            <summary>
            Gets the current light color.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetLightColor(UnityEngine.Color)">
            <summary>
            Sets the light color. Alpha can be used to set intensity.
            </summary>
            <param name="color">Light color</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetLightColor(System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.SetLightColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
            <param name="intensity">Intensity [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetAccelerometerValueRaw">
            <summary>
            Gets the raw value from the accelerometer as reported by the device.
            Reported device coordinates do not match Unity's coordinate system.
            Format: 1G = 8192f
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Raw accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetAccelerometerValue">
            <summary>
            Gets the value from the accelerometer and processes it so that 1G = 1.0 and so that coordinates match Unity coordinate system.
            The value returned could be thought of as a gravity vector and user acceleration combined.
            If using this value to apply a force in the direction of the vector, invert each axis first.
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetLastGyroscopeValueRaw">
            <summary>
            Gets the last raw value from the gyroscope as reported by the device.
            Reported device coordinates do not match Unity's coordinate system.
            The sensor can return more than one value per frame.
            This represents only the last measurement recorded, not an accumulated value.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetLastGyroscopeValue">
            <summary>
            Gets the last value from the gyroscope processed into Unity's coordinate system and adjusted for sensitivity.
            The sensor can return more than one value per frame.
            This represents only the last measurement recorded, not an accumulated value.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetGyroscopeValueRaw">
            <summary>
            Gets the raw value from the gyroscope as reported by the device accumulated over time since the last update.
            Reported device coordinates do not match Unity's coordinate system.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetGyroscopeValue">
            <summary>
            Gets the value from the gyroscope processed into Unity's coordinate system, adjusted for sensitivity, and accumulated over time since the last update.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetOrientation">
            <summary>
            Gets the orientation of the controller in Unity coordinates.
            This is only an estimate because accelerometer + gyroscope is not accurate enough to perfectly determine orientation at all angles.
            Drift can occur on the world Y axis over time. The orientation can be reset by calling ResetOrientation().
            Note: Orientation is not very reliable when connected via Bluetooth due to the possibility of dropped gyro data.
            </summary>
            <returns>Orientation</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.ResetOrientation">
            <summary>
            Resets the orientation to zero state. (Controller laying on back with buttons facing up and the top edge of the controller facing the screen.)
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetTouchId(System.Int32)">
            <summary>
            Gets the touch id for the touch at the specified index.
            </summary>
            <param name="index"></param>
            <returns>Touch id. Returns -1 if there is no current touch at the specified index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetTouchPosition(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetTouchPositionByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetTouchPositionAbsolute(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.GetTouchPositionAbsoluteByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.IsTouching(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="index">The index of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualSenseExtension.IsTouchingByTouchId(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="touchId">The id of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.vibrationMotorCount">
            <summary>
            The number of vibration motors in this controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.lightColorRed">
            <summary>
            Light color red channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.lightColorGreen">
            <summary>
            Light color green channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.lightColorBlue">
            <summary>
            Light color blue channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.microphoneLightMode">
            <summary>
            Microphone light mode.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.otherLightBrightness">
            <summary>
            Player and microphone light brightness level.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.playerLights">
            <summary>
            Player lights.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.maxTouches">
            <summary>
            Number of simultaneous touches supported by this device.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.touchCount">
            <summary>
            The current touch count.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.batteryLevel">
            <summary>
            Battery level as a percentage. [0 - 100]
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualSenseExtension.batteryCharging">
            <summary>
            Is the battery charging?
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualShock4Extension">
            <summary>
            Allows access to controller-specific functions such as vibration.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetVibration(Rewired.ControllerExtensions.DualShock4MotorType)">
            <summary>
            Gets vibration level for a specific motor.
            </summary>
            <param name="motor">Motor type</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(Rewired.ControllerExtensions.DualShock4MotorType,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="leftMotorDuration">Length of time in seconds to activate the left motor before it stops. [0 = Infinite]</param>
            <param name="rightMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetLightColor">
            <summary>
            Gets the current light color.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetLightColor(UnityEngine.Color)">
            <summary>
            Sets the light color. Alpha can be used to set intensity.
            </summary>
            <param name="color">Light color</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetLightColor(System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetLightColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
            <param name="intensity">Intensity [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.SetLightFlash(System.Single,System.Single)">
            <summary>
            Sets the light flashing speed. This sets the flashing system directly in the controller hardware and is subject to the hardware limitation of a 2.5 second duration.
            </summary>
            <param name="onDuration">Duration in seconds for light to remain on. [0 - 2.5]</param>
            <param name="offDuration">Duration in seconds for light to remain off. [0 - 2.5]</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.StopLightFlash">
            <summary>
            Stops the light flashing.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetAccelerometerValueRaw">
            <summary>
            Gets the raw value from the accelerometer as reported by the device.
            Reported device coordinates do not match Unity's coordinate system.
            Format: 1G = 8192f
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Raw accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetAccelerometerValue">
            <summary>
            Gets the value from the accelerometer and processes it so that 1G = 1.0 and so that coordinates match Unity coordinate system.
            The value returned could be thought of as a gravity vector and user acceleration combined.
            If using this value to apply a force in the direction of the vector, invert each axis first.
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Accelerometer data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetLastGyroscopeValueRaw">
            <summary>
            Gets the last raw value from the gyroscope as reported by the device.
            Reported device coordinates do not match Unity's coordinate system.
            The sensor can return more than one value per frame.
            This represents only the last measurement recorded, not an accumulated value.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetLastGyroscopeValue">
            <summary>
            Gets the last value from the gyroscope processed into Unity's coordinate system and adjusted for sensitivity.
            The sensor can return more than one value per frame.
            This represents only the last measurement recorded, not an accumulated value.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetGyroscopeValueRaw">
            <summary>
            Gets the raw value from the gyroscope as reported by the device accumulated over time since the last update.
            Reported device coordinates do not match Unity's coordinate system.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetGyroscopeValue">
            <summary>
            Gets the value from the gyroscope processed into Unity's coordinate system, adjusted for sensitivity, and accumulated over time since the last update.
            This value is not fused with the accelerometer value and can drift.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetOrientation">
            <summary>
            Gets the orientation of the controller in Unity coordinates.
            This is only an estimate because accelerometer + gyroscope is not accurate enough to perfectly determine orientation at all angles.
            Drift can occur on the world Y axis over time. The orientation can be reset by calling ResetOrientation().
            Note: Orientation is not very reliable when connected via Bluetooth due to the possibility of dropped gyro data.
            </summary>
            <returns>Orientation</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.ResetOrientation">
            <summary>
            Resets the orientation to zero state. (Controller laying on back with buttons facing up and the top edge of the controller facing the screen.)
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetTouchId(System.Int32)">
            <summary>
            Gets the touch id for the touch at the specified index.
            </summary>
            <param name="index"></param>
            <returns>Touch id. Returns -1 if there is no current touch at the specified index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetTouchPosition(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetTouchPositionByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetTouchPositionAbsolute(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.GetTouchPositionAbsoluteByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.IsTouching(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="index">The index of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.DualShock4Extension.IsTouchingByTouchId(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="touchId">The id of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.vibrationMotorCount">
            <summary>
            The number of vibration motors in this controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.lightColorRed">
            <summary>
            Light color red channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.lightColorGreen">
            <summary>
            Light color green channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.lightColorBlue">
            <summary>
            Light color blue channel.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.maxTouches">
            <summary>
            Number of simultaneous touches supported by this device.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.touchCount">
            <summary>
            The current touch count.
            </summary>
        </member>
        <member name="P:Rewired.ControllerExtensions.DualShock4Extension.batteryLevel">
            <summary>
            Battery level as a percentage. [0 - 100]
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.DualShock4MotorType">
            <summary>
            Dual Shock 4 game pad motors. Used for vibration.
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualShock4MotorType.LeftMotor">
            <summary>
            Left motor (stronger motor)
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualShock4MotorType.StrongMotor">
            <summary>
            Left motor (stronger motor)
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualShock4MotorType.RightMotor">
            <summary>
            Right motor (weaker motor)
            </summary>
        </member>
        <member name="F:Rewired.ControllerExtensions.DualShock4MotorType.WeakMotor">
            <summary>
            Right motor (weaker motor)
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.RailDriverExtension">
            <summary>
            Allows access to controller-specific functions LED panel and speaker.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.RailDriverExtension.SetLEDDisplay(System.Int32,System.Byte)">
            <summary>
            Set the LED display one digit at a time.
            </summary>
            <param name="digitIndex">Index of the digit to set. [0 - 2]</param>
            <param name="digitBitValues">A byte containing 8 bits, 1 for each element in the display digit. (Like an old LCD clock, plus a period.)</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.RailDriverExtension.SetLEDDisplay(System.Byte,System.Byte,System.Byte)">
            <summary>
            Set all 3 digits of the the LED display.
            </summary>
            <param name="digit1BitValues">A byte containing 7 bits, 1 for each element in the 1st display digit. (Like an old LCD clock, plus a period.)</param>
            <param name="digit2BitValues">A byte containing 7 bits, 1 for each element in the 2nd display digit. (Like an old LCD clock, plus a period.)</param>
            <param name="digit3BitValues">A byte containing 7 bits, 1 for each element in the 3rd display digit. (Like an old LCD clock, plus a period.)</param>
        </member>
        <member name="P:Rewired.ControllerExtensions.RailDriverExtension.speakerEnabled">
            <summary>
            Enable or disable speaker.
            </summary>
        </member>
        <member name="T:Rewired.ControllerExtensions.SteamControllerExtension">
            <summary>
            Allows access to Steam Controller-specific functions.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetActionSetHandle(System.String)">
            <summary>
            Get the handle for a Steam Action Set.
            </summary>
            <param name="actionSetName">Name of the Steam action set</param>
            <returns>Handle</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionHandle(System.String)">
            <summary>
            Get the handle for a Steam analog Action.
            </summary>
            <param name="actionName">Name of the Steam action</param>
            <returns>Handle</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionHandle(System.String)">
            <summary>
            Get the handle for a Steam digital Action.
            </summary>
            <param name="actionName">Name of the Steam action</param>
            <returns>Handle</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetActionSetName(System.UInt64)">
            <summary>
            Get the name for a Steam Action Set.
            </summary>
            <param name="actionSetHandle">Handle of the Steam action set</param>
            <returns>Steam Action name</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionName(System.UInt64)">
            <summary>
            Get the name for a Steam analog Action.
            </summary>
            <param name="actionHandle">Handle of the Steam action</param>
            <returns>Steam Action name</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionName(System.UInt64)">
            <summary>
            Get the name for a Steam digital Action.
            </summary>
            <param name="actionHandle">Handle of the Steam action</param>
            <returns>Steam Action name</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionValue(System.String)">
            <summary>
            Get the current value of an analog Steam action.
            </summary>
            <param name="actionName">Name of the Steam action</param>
            <returns>X/Y value</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionValue(System.UInt64)">
            <summary>
            Get the current value of an analog Steam action.
            </summary>
            <param name="actionHandle">Handle of the Steam action</param>
            <returns>X/Y value</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionValue(System.String)">
            <summary>
            Get the current value of a digital Steam action.
            </summary>
            <param name="actionName">Name of the Steam action</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionValue(System.UInt64)">
            <summary>
            Get the current value of a digital Steam action.
            </summary>
            <param name="actionHandle">Handle of the Steam action</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.SetActiveActionSet(System.UInt64)">
            <summary>
            Set the current active Steam action set.
            </summary>
            <param name="actionSetHandle">Handle of the Steam action set</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.SetActiveActionSet(System.String)">
            <summary>
            Set the current active Steam action set.
            </summary>
            <param name="actionSetName">Name of the Steam action set</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetActiveActionSetHandle">
            <summary>
            Get the current active Steam action set handle.
            </summary>
            <returns>Action set handle</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetActiveActionSetName">
            <summary>
            Get the current active Steam action set name.
            </summary>
            <returns>Action set name</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.ShowBindingPanel">
            <summary>
            Show the Steam control binding panel for the current controller.
            </summary>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.SetHapticPulse(Rewired.ControllerExtensions.SteamControllerPadType,System.Single)">
            <summary>
            Set a haptic pulse in a pad.
            </summary>
            <param name="targePad">Target pad</param>
            <param name="durationSeconds">Duration of pulse in seconds</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.SetHapticPulse(Rewired.ControllerExtensions.SteamControllerPadType,System.UInt16)">
            <summary>
            Set a haptic pulse in a pad.
            </summary>
            <param name="targePad">Target pad</param>
            <param name="durationMicroSeconds">Duration of pulse in micro seconds</param>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionOrigins(System.String,System.String)">
            <summary>
            Get the origins for a Steam digital action.
            </summary>
            <param name="actionSetName">Action set name</param>
            <param name="actionName">Action name</param>
            <returns>List of action origins</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetDigitalActionOrigins(System.UInt64,System.UInt64)">
            <summary>
            Get the origins for a Steam digital action.
            </summary>
            <param name="actionSetHandle">Action set handle</param>
            <param name="actionHandle">Action handle</param>
            <returns>List of action origins</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionOrigins(System.String,System.String)">
            <summary>
            Get the origins for a Steam analog action.
            </summary>
            <param name="actionSetName">Action set name</param>
            <param name="actionName">Action name</param>
            <returns>List of action origins</returns>
        </member>
        <member name="M:Rewired.ControllerExtensions.SteamControllerExtension.GetAnalogActionOrigins(System.UInt64,System.UInt64)">
            <summary>
            Get the origins for a Steam analog action.
            </summary>
            <param name="actionSetHandle">Action set handle</param>
            <param name="actionHandle">Action handle</param>
            <returns>List of action origins</returns>
        </member>
        <member name="T:Rewired.Joystick">
            <summary>
            A joystick with buttons and axes.
            </summary>
        </member>
        <member name="M:Rewired.Joystick.IsType(Rewired.JoystickType)">
            <summary>
            Checks whether this Joystick matches a specific type.
            </summary>
            <param name="joystickType">The Joystick type to match.</param>
            <returns>True if the type matches, false if it does not.</returns>
        </member>
        <member name="M:Rewired.Joystick.GetCalibrationMapSaveData">
            <summary>
            Gets calibration map save data from this joystick.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors or for the first two motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors or for the first two motors with a timeout.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="leftMotorDuration">Length of time in seconds to activate the left motor before it stops.</param>
            <param name="rightMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Joystick.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Joystick.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Joystick.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.joystickTypes">
            <summary>
            The joystick types that apply to this Joystick. A Joystick may have more than one Joystick Type.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.systemId">
            <summary>
            The id of the device in the underlying input source. The meaning of this value is determined by the current input source.
            This may include Unity input, Raw Input, Direct Input, OSX I/O Kit, XBoxOneInput, Ouya input, and others.
            Generally, you should never need to use this, but it is exposed for advanced uses.
            Returns null if there is no system id associated with this joystick.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.unityId">
            <summary>
            The unity joystick id of this joystick. This value is only used on platforms that use Unity input as the underlying input source.
            This value is a 1-based index corresponding to the joystick number in the Unity input manager.
            Generally, you should never need to use this, but it is exposed for advanced uses.
            Returns 0 if the platform does not use Unity input or if the joystick is not associated with a Unity joystick.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.deviceInstanceGuid">
            <summary>
            The unique persistent instance GUID of this device.
            This is an id generated for the device that may stay constant between application sessions and system restarts.
            This can be used for device assignment persistence between runs. The specific platform and input sources in use
            affects the reliability of this value for device assignment persistence.
            A value of Guid.Empty means the device or input source has no reliable unique identifier so persistant assignment
            isn't possible using this value. Even if a Guid is provided, reliability when multiple identical controllers are
            attached depends greatly on the platform and input source(s) currently in use.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.supportsVibration">
            <summary>
            Does this controller support vibration?
            </summary>
        </member>
        <member name="P:Rewired.Joystick.vibrationLeftMotor">
            <summary>
            Sets vibration speed on the left motor or the motor at index 0. [float: 0.0 - 1.0]
            This is specifically for XInput controllers on Windows.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.vibrationRightMotor">
            <summary>
            Sets vibration speed on the right motor or the motor at index 1. [float: 0.0 - 1.0]
            This is specifically for XInput controllers on Windows.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.vibrationMotorCount">
            <summary>
            The number of vibration motors this device supports.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.hatCount">
            <summary>
            The number of Hats in this controller.
            </summary>
        </member>
        <member name="P:Rewired.Joystick.Hats">
            <summary>
            List of Hats in this controller.
            </summary>
        </member>
        <member name="T:Rewired.Keyboard">
            <summary>
            A keyboard with keys.
            </summary>
        </member>
        <member name="M:Rewired.Keyboard.GetKeyCodeByButtonIndex(System.Int32)">
            <summary>
            Gets the KeyCode of the key at the specified button index.
            </summary>
            <param name="buttonIndex">The index of the button.</param>
            <returns>KeyCode of the key.</returns>
        </member>
        <member name="M:Rewired.Keyboard.GetKeyCodeById(System.Int32)">
            <summary>
            Gets the KeyCode of the key with the specified element identifier id.
            </summary>
            <param name="elementIdentifierId">The element identifier id.</param>
            <returns>KeyCode of the key.</returns>
        </member>
        <member name="M:Rewired.Keyboard.GetButtonIndexByKeyCode(UnityEngine.KeyCode)">
            <summary>
            Gets the Button index that corresponds to the specified KeyCode.
            </summary>
            <param name="keyCode">The KeyCode of the key.</param>
            <returns>Button index. -1 if not found.</returns>
        </member>
        <member name="M:Rewired.Keyboard.GetElementIdentifierByKeyCode(UnityEngine.KeyCode)">
            <summary>
            Gets the Controller Element Identifier corresponding to the specified KeyCode.
            </summary>
            <param name="keyCode">The KeyCode of the key.</param>
            <returns>Controller Element Identifier. Null if not found.</returns>
        </member>
        <member name="P:Rewired.Keyboard.deviceInstanceGuid">
            <summary>
            The unique persistent instance GUID of this device.
            This is an id generated for the device that may stay constant between application sessions and system restarts.
            This can be used for device assignment persistence between runs. The specific platform and input sources in use
            affects the reliability of this value for device assignment persistence.
            A value of Guid.Empty means the device or input source has no reliable unique identifier so persistant assignment
            isn't possible using this value. Even if a Guid is provided, reliability when multiple identical controllers are
            attached depends greatly on the platform and input source(s) currently in use.
            </summary>
        </member>
        <member name="T:Rewired.Mouse">
            <summary>
            A mouse with buttons and axes.
            </summary>
        </member>
        <member name="P:Rewired.Mouse.screenPosition">
            <summary>
            The current position of the mouse pointer on the screen in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Mouse.screenPositionPrev">
            <summary>
            The position of the mouse pointer on the screen on the previous frame in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Mouse.screenPositionDelta">
            <summary>
            The difference in position of the mouse pointer on the screen since the last frame in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Mouse.deviceInstanceGuid">
            <summary>
            The unique persistent instance GUID of this device.
            This is an id generated for the device that may stay constant between application sessions and system restarts.
            This can be used for device assignment persistence between runs. The specific platform and input sources in use
            affects the reliability of this value for device assignment persistence.
            A value of Guid.Empty means the device or input source has no reliable unique identifier so persistant assignment
            isn't possible using this value. Even if a Guid is provided, reliability when multiple identical controllers are
            attached depends greatly on the platform and input source(s) currently in use.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplate">
            <summary>
            Base class for a Controller Template.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplate">
            <summary>
            Interface for a Controller Template.
            </summary>
        </member>
        <member name="M:Rewired.IControllerTemplate.GetElement(System.Int32)">
            <summary>
            Gets the specified Controller Template element.
            </summary>
            <param name="id">Id of the Controller Template element.</param>
            <returns>Returns the Controller Template element. Returns null if the element was not found.</returns>
        </member>
        <member name="M:Rewired.IControllerTemplate.GetElement``1(System.Int32)">
            <summary>
            Gets the specified Controller Template element.
            </summary>
            <typeparam name="T">Controller template element type.</typeparam>
            <param name="id">Id of the Controller Template element.</param>
            <returns>Returns the Controller Template element. Returns null if the element was not found or the type is not implemented by the element.</returns>
        </member>
        <member name="M:Rewired.IControllerTemplate.GetElementTargets(Rewired.ControllerElementTarget,System.Collections.Generic.IList{Rewired.ControllerTemplateElementTarget})">
            <summary>
            Gets a list of all Controller Template Element targets that map to the specified target Controller Element.
            </summary>
            <param name="target">The target Controller Element.</param>
            <param name="results">The list of results. Provide a list which will be used to return the results. The list will be cleared by the method.</param>
            <returns>All Template Element targets that map to the specified target Controller Element</returns>
        </member>
        <member name="P:Rewired.IControllerTemplate.controller">
            <summary>
            Parent Controller to which the Controller Template belongs.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplate.name">
            <summary>
            Display name of the Controller Template.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplate.typeGuid">
            <summary>
            GUID of the Controller Template type.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplate.elements">
            <summary>
            List of Controller Template elements.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplate.elementCount">
            <summary>
            Count of Controller Template elements.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplate.GetElement``1(System.Int32)">
            This is protected so implementing classes can get the element
        </member>
        <member name="T:Rewired.ControllerTemplate.Element">
            <summary>
            Base of all elements whether they are actual buttons/axes, compound elements, or template-level elements
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateElement">
            <summary>
            Interface for a Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElement.id">
            <summary>
            Id of the Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElement.descriptiveName">
            <summary>
            Display name of the Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElement.type">
            <summary>
            Type of the Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElement.exists">
            <summary>
            Does the Element exist in the parent Controller?
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElement.source">
            <summary>
            Information about the source element(s) in the parent Controller.
            This will return null for elements that cannot have a directly mappable source Controller Element.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplate.ElementWithSources">
            <summary>
            Base of actual functional elements that point back to real controller element sources.
            Button and axis only.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateAxis">
            <summary>
            Interface for a Controller Template Axis.
            An Axis has a floating-point value.
            An Axis consists of two poles, positive and negative.
            </summary>
        </member>
        <member name="M:Rewired.IControllerTemplateAxis.GetDescriptiveName(Rewired.AxisRange)">
            <summary>
            Gets the display name of the Controller Template Element for the specified axis range.
            </summary>
            <param name="axisRange">The axis range for which to get the descriptiveName</param>
            <returns>Returns the display name of the Controller Template Element for the specified axis range</returns>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.positiveDescriptiveName">
            <summary>
            Display name of the Controller Template Element for the positive axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.negativeDescriptiveName">
            <summary>
            Display name of the Controller Template Element for the negative axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.value">
            <summary>
            The current value of the axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.valuePrev">
            <summary>
            The value of the axis in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.source">
            <summary>
            The Controller element source.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis.AsButton">
            <summary>
            Gets the element cast to <see cref="T:Rewired.IControllerTemplateButton"/>.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateButton">
            <summary>
            Interface for a Controller Template Button.
            A Button has an on/off value and optionally a pressure value.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.value">
            <summary>
            The current value of the button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.valuePrev">
            <summary>
            The value of the button in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.pressure">
            <summary>
            The current pressure of the button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.pressurePrev">
            <summary>
            The pressure of the button in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.justPressed">
            <summary>
            Was this button just pressed this frame? Returns true for only one frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.justReleased">
            <summary>
            Was this button just released this frame? Returns true for only one frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.justChangedState">
            <summary>
            Returns true if the button was just pressed or just released. Returns true for only one frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.source">
            <summary>
            The Controller element source.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButton.AsAxis">
            <summary>
            Gets the element cast to <see cref="T:Rewired.IControllerTemplateAxis"/>.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateAxis2D">
            <summary>
            Interface for a Controller Template axis 2D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis2D.value">
            <summary>
            The current value of the axis 2D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis2D.valuePrev">
            <summary>
            The value of the axis 2D in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis2D.horizontal">
            <summary>
            The horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis2D.vertical">
            <summary>
            The vertical axis.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateAxis3D">
            <summary>
            Interface for a Controller Template axis 2D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis3D.value">
            <summary>
            The current value of the axis 3D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis3D.valuePrev">
            <summary>
            The value of the axis 3D in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis3D.horizontal">
            <summary>
            The horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis3D.vertical">
            <summary>
            The vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis3D.depth">
            <summary>
            The depth axis.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateAxis6D">
            <summary>
            Interface for a Controller Template axis 6D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.position">
            <summary>
            The current position value of the Axis6D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.positionPrev">
            <summary>
            The position value of the Axis6D in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.rotation">
            <summary>
            The current rotation value of the Axis6D.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.rotationPrev">
            <summary>
            The rotation value of the Axis6D in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.positionX">
            <summary>
            The position X axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.positionY">
            <summary>
            The position Y axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.positionZ">
            <summary>
            The position Z axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.rotationX">
            <summary>
            The rotation X axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.rotationY">
            <summary>
            The rotation Y axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxis6D.rotationZ">
            <summary>
            The rotation Z axis.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateStick">
            <summary>
            Interface for a Controller Template Stick.
            A Stick can have up to 3 axes: Horizontal, Vertical, and Rotation.
            This is used for flight sticks.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick.value">
            <summary>
            The current value of the stick.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick.valuePrev">
            <summary>
            The value of the stick in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick.horizontal">
            <summary>
            The horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick.vertical">
            <summary>
            The vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick.rotation">
            <summary>
            The rotation axis.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateThumbStick">
            <summary>
            Interface for a Controller Template Thumb Stick.
            A Thumb Stick has 2 axes and an optional button.
            This is used for gamepad sticks.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThumbStick.value">
            <summary>
            The current value of the thumb stick.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThumbStick.valuePrev">
            <summary>
            The value of the thumb stick in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThumbStick.horizontal">
            <summary>
            The horizontal axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThumbStick.vertical">
            <summary>
            The vertical axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThumbStick.press">
            <summary>
            The stick press button.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateDPad">
            <summary>
            Interface for a Controller Template D-Pad.
            A D-Pad consists of 4 directional buttons and an optional press-in button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.value">
            <summary>
            The current value of the D-Pad as a 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.valuePrev">
            <summary>
            The value of the D-Pad as a 2D axis in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.up">
            <summary>
            The up button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.right">
            <summary>
            The right button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.down">
            <summary>
            The down button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.left">
            <summary>
            The left button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateDPad.press">
            <summary>
            The press button.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateThrottle">
            <summary>
            Interface for a Controller Template Throttle.
            A Throttle has an axis and an optional button activated when the throttle is at its minimum value.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThrottle.value">
            <summary>
            The current value of the throttle.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThrottle.valuePrev">
            <summary>
            The value of the throttle in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThrottle.throttle">
            <summary>
            The axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateThrottle.minDetent">
            <summary>
            The min-detent button.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateHat">
            <summary>
            Interface for a Controller Template Hat.
            A Hat is an 8-directional switch.
            This is commonly used on flight sticks.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.value">
            <summary>
            The current value of the Hat as a 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.valuePrev">
            <summary>
            The value of the Hat as a 2D axis in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.up">
            <summary>
            The up button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.upRight">
            <summary>
            The up-right button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.right">
            <summary>
            The right button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.downRight">
            <summary>
            The down-right button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.down">
            <summary>
            The down button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.downLeft">
            <summary>
            The down-left button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.left">
            <summary>
            The left button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateHat.upLeft">
            <summary>
            The up-left button.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateYoke">
            <summary>
            Interface for a Controller Template Yoke.
            A Yoke has 2 axes: Rotation and Push/Pull.
            This is used for flight yokes.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateYoke.value">
            <summary>
            The current value of the yoke as a 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateYoke.valuePrev">
            <summary>
            The value of the yoke as a 2D axis in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateYoke.rotation">
            <summary>
            The rotation axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateYoke.pushPull">
            <summary>
            The push / pull axis.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateStick6D">
            <summary>
            Interface for a Controller Template 6 DoF Stick.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.position">
            <summary>
            The current position value of the 6 DoF stick.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.positionPrev">
            <summary>
            The position value of the 6 DoF stick in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.rotation">
            <summary>
            The current rotation value of the 6 DoF stick.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.rotationPrev">
            <summary>
            The rotation value of the 6 DoF stick in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.positionX">
            <summary>
            The position X axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.positionY">
            <summary>
            The position Y axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.positionZ">
            <summary>
            The position Z axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.rotationX">
            <summary>
            The rotation X axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.rotationY">
            <summary>
            The rotation Y axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateStick6D.rotationZ">
            <summary>
            The rotation Z axis.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateActionElementMap">
            <summary>
            Maps an Action to a Controller Template element.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplateActionElementMap.#ctor(Rewired.ActionElementMap)">
            <summary>
            This overload is only for converting ControllerMap_Editor ActionElementMaps directly to ControllerTemplateActionElementMaps.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplateActionElementMap.Create(Rewired.ActionElementMap)">
            <summary>
            This overload is only for directly converting ControllerMap_Editor mappings for a Controller Template into Template Action Element Maps.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionElementMap.id">
            <summary>
            Gets the unique runtime id of this ControllerTemplateActionElementMap. This value is not consistent between game sessions, so do not store it.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionElementMap.elementType">
            <summary>
            The Controller Template Element type.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionElementMap.enabled">
            <summary>
            Is the map enabled? Disabled maps will never return input.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionElementMap.actionId">
            <summary>
            The id of the Action to which the element is bound.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionElementMap.elementIdentifierId">
            <summary>
            Gets the element type of the Controller Template element bound to the Action.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateActionButtonMap">
            <summary>
            Maps an Action to a Controller Template Button element.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateActionButtonMap.axisContribution">
            <summary>
            The contribution to the Action's final value when queried as an axis.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateActionAxisMap">
            <summary>
            Maps an Action to a Controller Template Axis element.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateElementSource">
            <summary>
            Interface for a Controller Template Element Source.
            This provides information about the source of the Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateElementSource.type">
            <summary>
            Gets the type of the element source.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateAxisSource">
            <summary>
            Interface for a Controller Template Axis Source.
            This provides information about the source of the Controller Template Axis.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxisSource.splitAxis">
            <summary>
            Is this a split-axis assignment?
            If false, <see cref="P:Rewired.IControllerTemplateAxisSource.fullTarget"/> is used.
            If true, <see cref="P:Rewired.IControllerTemplateAxisSource.positiveTarget"/> and <see cref="P:Rewired.IControllerTemplateAxisSource.negativeTarget"/> are used.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxisSource.fullTarget">
            <summary>
            Target Controller element for the axis.
            This is only used if <see cref="P:Rewired.IControllerTemplateAxisSource.splitAxis"/> is false.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxisSource.positiveTarget">
            <summary>
            Target Controller element for the positive pole of the axis.
            This is only used if <see cref="P:Rewired.IControllerTemplateAxisSource.splitAxis"/> is true.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateAxisSource.negativeTarget">
            <summary>
            Target Controller element for the negative pole of the axis.
            This is only used if <see cref="P:Rewired.IControllerTemplateAxisSource.splitAxis"/> is true.
            </summary>
        </member>
        <member name="T:Rewired.IControllerTemplateButtonSource">
            <summary>
            Interface for a Controller Template Button Source.
            This provides information about the source of the Controller Template Button.
            </summary>
        </member>
        <member name="P:Rewired.IControllerTemplateButtonSource.target">
            <summary>
            Target Controller element.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateElementTarget">
            <summary>
            Describes a specific Controller Template Element on a Controller Template including a partial Axis.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplateElementTarget.#ctor(Rewired.IControllerTemplateElement,Rewired.AxisRange)">
            <summary>
            Creates a <see cref="T:Rewired.ControllerTemplateElementTarget"/> instance.
            </summary>
            <param name="element">The Controller Template Element.</param>
            <param name="axisRange">The range of the target Axis. Only used for Axis targets.</param>
        </member>
        <member name="M:Rewired.ControllerTemplateElementTarget.#ctor(Rewired.ControllerTemplateElementTarget)">
            <summary>
            Creates a copy of a <see cref="T:Rewired.ControllerTemplateElementTarget"/>.
            </summary>
            <param name="other">The <see cref="T:Rewired.ControllerTemplateElementTarget"/> to copy.</param>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.axisRange">
            <summary>
            For Axes, the portion of the Axis that applies.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.elementType">
            <summary>
            Gets the element type of the target Controller Template element.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.descriptiveName">
            <summary>
            Gets the name of the target element.
            For split axes, this will return the Positive or Negative name or the Descriptive Name with a +/- suffix.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.element">
            <summary>
            The target Controller Template Element.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.template">
            <summary>
            The target Controller Template.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateElementTarget.hasTarget">
            <summary>
            Does a valid target exist in the Controller Template?
            </summary>
        </member>
        <member name="T:Rewired.ControllerElementTarget">
            <summary>
            Describes a specific Controller Element on a Controller including a partial Axis.
            </summary>
        </member>
        <member name="M:Rewired.ControllerElementTarget.#ctor(Rewired.ActionElementMap)">
            <summary>
            Creates a <see cref="T:Rewired.ControllerElementTarget"/> instance from an <see cref="T:Rewired.ActionElementMap"/>.
            </summary>
            <param name="actionElementMap">The Action Element Map.</param>
        </member>
        <member name="M:Rewired.ControllerElementTarget.#ctor(Rewired.ControllerElementTarget)">
            <summary>
            Creates a copy of a <see cref="T:Rewired.ControllerElementTarget"/>.
            </summary>
            <param name="other">The <see cref="T:Rewired.ControllerElementTarget"/> to copy.</param>
        </member>
        <member name="M:Rewired.ControllerElementTarget.#ctor(Rewired.IControllerElementTarget)">
            <summary>
            Creates a copy of a <see cref="T:Rewired.IControllerElementTarget"/>.
            </summary>
            <param name="other">The <see cref="T:Rewired.IControllerElementTarget"/> to copy.</param>
        </member>
        <member name="M:Rewired.ControllerElementTarget.op_Implicit(Rewired.ActionElementMap)~Rewired.ControllerElementTarget">
            <summary>
            Implicit conversion from an Action Element Map.
            </summary>
            <param name="actionElementMap">The Action Element Map.</param>
            <returns>Returns the converted object.</returns>
        </member>
        <member name="P:Rewired.ControllerElementTarget.elementIdentifierId">
            <summary>
            The element identifier id of the target element.
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.axisRange">
            <summary>
            Determines whether the full range or just one pole of the target element is used.
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.hasTarget">
            <summary>
            Does a valid target exist in the Controller?
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.elementType">
            <summary>
            Gets the element type of the target Controller element.
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.descriptiveName">
            <summary>
            Gets the name of the target elementr.
            For split axes, this will return the Positive or Negative name or the Descriptive Name with a +/- suffix.
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.controller">
            <summary>
            The target Controller.
            </summary>
        </member>
        <member name="P:Rewired.ControllerElementTarget.element">
            <summary>
            The target Controller Element.
            </summary>
        </member>
        <member name="T:Rewired.IControllerElementTarget">
            <summary>
            Interface for a Controller element target.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.elementIdentifierId">
            <summary>
            The element identifier id of the target element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.axisRange">
            <summary>
            For Axes, the portion of the Axis that is being targeted.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.hasTarget">
            <summary>
            Does a valid target exist in the Controller?
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.elementType">
            <summary>
            Gets the element type of the target Controller element.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.descriptiveName">
            <summary>
            Gets the name of the target element.
            For split axes, this will return the Positive or Negative name or the Descriptive Name with a +/- suffix.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.controller">
            <summary>
            The target Controller.
            </summary>
        </member>
        <member name="P:Rewired.IControllerElementTarget.element">
            <summary>
            The target Controller Element.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.IPoolableObject_Internal">
            <summary>
            Interface for a simple poolable object that maintains a reference to its parent pool so it can be returned easily.
            </summary>
        </member>
        <member name="T:Rewired.Interfaces.IPoolableObject">
            <summary>
            Interface for a poolable object.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IPoolableObject.Return">
            <summary>
            Returns the object to its pool if it is a member of one.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.IPoolableObject_Internal.Clear">
            <summary>
            Clear the object.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.IPoolableObject_Internal.pool">
            <summary>
            The object's parent pool.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateElementType">
            <summary>
            Controller Template Element type.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Axis">
            <summary>
            An axis.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Button">
            <summary>
            A button.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.ThumbStick">
            <summary>
            A thumb stick with a button.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.DPad">
            <summary>
            A 4-way directional pad.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Stick">
            <summary>
            A 2 or 3 axis stick.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Throttle">
            <summary>
            A throttle.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Hat">
            <summary>
            An 8-way hat.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Yoke">
            <summary>
            A flight yoke.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementType.Stick6D">
            <summary>
            A 6 DoF stick.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateElementSourceType">
            <summary>
            Controller Template Element Source type.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementSourceType.Axis">
            <summary>
            An axis.
            </summary>
        </member>
        <member name="F:Rewired.ControllerTemplateElementSourceType.Button">
            <summary>
            A button.
            </summary>
        </member>
        <member name="T:Rewired.ControllerTemplateMap">
            <summary>
            Maps actions to specific Controller Template elements.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.ToXmlString">
            <summary>
            Exports the map to an XML string.
            </summary>
            <returns>XML string</returns>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.ToJsonString">
            <summary>
            Exports the map to a JSON string.
            </summary>
            <returns>JSON string</returns>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.ToControllerMap(Rewired.Controller)">
            <summary>
            Converts the Controller Template Map to a Controller Map.
            </summary>
            <param name="controller">The Controller for which to build the Controller Map.</param>
            <returns>Returns the Controller Map.</returns>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.FromControllerMap(Rewired.IControllerTemplate,Rewired.ControllerMap)">
            <summary>
            Creates a Controller Template Map from a Controller Map.
            </summary>
            <param name="controllerTemplate">The Controller Template for which to create the map.</param>
            <param name="controllerMap">The Controller Map to convert.</param>
            <returns>Returns a Controller Template Map created from a Controller Map.</returns>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.FromXml(System.String)">
            <summary>
            Creates a Controller Template Map from XML.
            </summary>
            <param name="xmlString">The XML string.</param>
            <returns>Returns the Controller Template Map. Returns null on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerTemplateMap.FromJson(System.String)">
            <summary>
            Creates a Controller Template Map from JSON.
            </summary>
            <param name="jsonString">The JSON string.</param>
            <returns>Returns the Controller Template Map. Returns null on failure.</returns>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.id">
            <summary>
            The unique id of this Controller Template Map. This value is not consistent between game sessions, so do not store it.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.templateTypeGuid">
            <summary>
            The Controller Template type GUID.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.enabled">
            <summary>
            Is the controller map enabled? Disabled maps will never return input values for the ActionElementMaps contained within.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.categoryId">
            <summary>
            The id of the Map Category of this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.layoutId">
            <summary>
            The id of the Layout of this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerTemplateMap.ElementMaps">
            <summary>
            Gets all element maps in this Controller Template Map.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController">
            <summary>
            A controller that uses Player Actions as the input sources for controller elements.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.GetButton(System.Int32)">
            <summary>
            Gets the current value of the button.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The current value of the button.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetButtonDown(System.Int32)">
            <summary>
            Gets the down state of the button. Returns True only on the first frame the button was pressed.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The down state of the button.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetButtonUp(System.Int32)">
            <summary>
            Gets the up state of the button. Returns True only on the first frame the button was released.
            </summary>
            <param name="index">The index of the button.</param>
            <returns>The up state of the button.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetAxis(System.Int32)">
            <summary>
            Gets the current axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current axis value.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetAxisRaw(System.Int32)">
            <summary>
            Gets the current raw axis value.
            </summary>
            <param name="index">The index of the axis</param>
            <returns>The current raw axis value.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetElement(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index.</returns>
        </member>
        <member name="M:Rewired.PlayerController.GetElement``1(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="index">The index of the element.</param>
            <returns>The element at the specified index. Returns null if no element exists at the specified index or it is not the correct type.</returns>
        </member>
        <member name="P:Rewired.PlayerController.enabled">
            <summary>
            Is the controller enabled?
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.playerId">
            <summary>
            The Player id of the Player used for the source of input.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.buttons">
            <summary>
            The list of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.axes">
            <summary>
            The list of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.elements">
            <summary>
            The list of Elements of all types in the controller.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.buttonCount">
            <summary>
            The number of Buttons in the controller.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.axisCount">
            <summary>
            The number of Axes in the controller.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.elementCount">
            <summary>
            The number of Elements in the controller.
            </summary>
        </member>
        <member name="E:Rewired.PlayerController.ButtonStateChangedEvent">
            <summary>
            Triggered the first frame the button is pressed or released.
            </summary>
        </member>
        <member name="E:Rewired.PlayerController.AxisValueChangedEvent">
            <summary>
            Triggered when the axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.PlayerController.EnabledStateChangedEvent">
            <summary>
            Triggered when the controller is enabled or disabled.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Definition">
            <summary>
            Definition for Player Controller.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Definition.enabled">
            <summary>
            Is the controller enabled?
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Definition.playerId">
            <summary>
            The Player id of the Player used for the source of input.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Definition.elements">
            <summary>
            A list of element definitions used to create elements in the controller.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Definition.#ctor">
            <summary>
            Creates a Definition with the default values.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Factory">
            <summary>
            Class for creating Player Controller instances.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Factory.Create(Rewired.PlayerController.Definition)">
            <summary>
            Creates a new Player Controller.
            </summary>
            <param name="definition">Definition use to set initial values in the controller.</param>
            <returns>A new Player Controller.</returns>
        </member>
        <member name="T:Rewired.PlayerController.Axis">
            <summary>
            An Axis that uses Player Actions as the value source.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.ElementWithSource">
            <summary>
            Base class for elements that have an input source.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Element">
            <summary>
            Base class for elements.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Element.enabled">
            <summary>
            Is this element enabled? Disabled elements return no value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Element.name">
            <summary>
            The name of the element.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Element.Definition">
            <summary>
            Properties to use when creating a new Element.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Element.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Element.Definition.enabled">
            <summary>
            Is this element enabled? Disabled elements return no value.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Element.Definition.name">
            <summary>
            The name of the element.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.ElementWithSource.actionId">
            <summary>
            The Action id of the Action which will be used as the input source for the Element.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.ElementWithSource.actionName">
            <summary>
            The Action name of the Action which will be used as the input source for the Element.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.ElementWithSource.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.ElementWithSource.Definition.actionId">
            <summary>
            The Action id of the Action which will be used as the input source for the Element.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.ElementWithSource.Definition.actionName">
            <summary>
            The Action name of the Action which will be used as the input source for the Element.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis.absoluteToRelativeSensitivity">
            <summary>
            The absolute to relative sensitivity multiplier. This is only applied when the axis coordinate mode is set to Relative and the axis receives
            Absolute coordinate mode input (joystick axes, keyboard keys, etc.).
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis.coordinateMode">
            <summary>
            The output coordinate mode of the axis. An Absolute axis will only return value for input received from Absolute sources.
            A Relative axis will return value for input received from both Relative and Absolute sources. When converting from
            an Absolute input source to a Relative output, absoluteToRelativeSensitivity will be multiplied by the Absolute value
            to yield a simulated Relative value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis.value">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis.valueRaw">
            <summary>
            The current raw value.
            This is the same as getting the raw axis value from Player.GetAxisRaw.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Axis.Definition">
            <summary>
            Properties to use when creating a new Axis.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Axis.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Axis.Definition.coordinateMode">
            <summary>
            The output coordinate mode of the axis. An Absolute axis will only return value for input received from Absolute sources.
            A Relative axis will return value for input received from both Relative and Absolute sources. When converting from
            an Absolute input source to a Relative output, absoluteToRelativeSensitivity will be multiplied by the Absolute value
            to yield a simulated Relative value.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.Axis.Definition.absoluteToRelativeSensitivity">
            <summary>
            The absolute to relative sensitivity multiplier. This is only applied when the axis coordinate mode is set to Relative and the axis receives
            Absolute coordinate mode input (joystick axes, keyboard keys, etc.).
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.MouseAxis">
            <summary>
            A Mouse Axis that uses Player Actions as the value source.
            Source value is automatically scaled to screen resolution.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseAxis.value">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.MouseAxis.Definition">
            <summary>
            Properties to use when creating a new Mouse Axis.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.MouseAxis.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Axis2D">
            <summary>
            An element with 2 Axes.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.CompoundElement">
            <summary>
            Base for elements with multiple source elements.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.CompoundElement.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.xAxis">
            <summary>
            The X axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.yAxis">
            <summary>
            The Y axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.value">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.valueRaw">
            <summary>
            The current raw value.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Axis2D.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.Definition.xAxis">
            <summary>
            The X axis definition.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Axis2D.Definition.yAxis">
            <summary>
            The Y axis definition.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.MouseAxis2D">
            <summary>
            An element with 2 Mouse Axes.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseAxis2D.xAxis">
            <summary>
            The X axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseAxis2D.yAxis">
            <summary>
            The Y axis.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.MouseAxis2D.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseAxis2D.Definition.xAxis">
            <summary>
            The X axis definition.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseAxis2D.Definition.yAxis">
            <summary>
            The Y axis definition.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Button">
            <summary>
            A Button that uses Player Actions as the value source.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Button.value">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Button.valuePrev">
            <summary>
            The value in the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Button.justPressed">
            <summary>
            Returns True only on the first frame the button was pressed.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.Button.justReleased">
            <summary>
            Returns True only on the first frame the button was released.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.Button.Definition">
            <summary>
            Properties to use when creating a new Button.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.Button.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheel.xAxis">
            <summary>
            The X axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheel.yAxis">
            <summary>
            The Y axis.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.MouseWheel.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheel.Definition.xAxis">
            <summary>
            The X axis definition.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheel.Definition.yAxis">
            <summary>
            The Y axis definition.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheelAxis.repeatRate">
            <summary>
            The number of times per second the wheel ticks when the value source
            is an absolute axis value.
            </summary>
        </member>
        <member name="P:Rewired.PlayerController.MouseWheelAxis.value">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="T:Rewired.PlayerController.MouseWheelAxis.Definition">
            <summary>
            Properties to use when creating a new MouseWheelAxis.
            </summary>
        </member>
        <member name="M:Rewired.PlayerController.MouseWheelAxis.Definition.#ctor">
            <summary>
            Creates a new Definition with the default options.
            </summary>
        </member>
        <member name="F:Rewired.PlayerController.MouseWheelAxis.Definition.repeatRate">
            <summary>
            The number of times per second the wheel ticks when the value source
            is an absolute axis value.
            </summary>
        </member>
        <member name="T:Rewired.PlayerMouse">
            <summary>
            A virtual mouse that can be used to drive a sprite or software mouse pointer.
            It uses a Rewired Player to move the pointer position and as the source for
            the buttons and axes.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.defaultToCenter">
            <summary>
            If enabled, the screen position will default to the center of the allowed movement area.
            Otherwise, it will default to the lower-left corner of the allowed movement area.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.clampToMovementArea">
            <summary>
            If enabled, movement will be clamped to the <see cref="P:Rewired.PlayerMouse.movementArea"/>.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.movementArea">
            <summary>
            The allowed movement area for the mouse pointer.
            Set <see cref="P:Rewired.PlayerMouse.movementAreaUnit"/> to determine the data format of this value.
            This rect is a screen-space rect with 0, 0 at the lower-left corner.
            If you pass a UnityEngine.Rect in which represents 0, 0 as the upper-left corner, Y will automatically be flipped.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.movementAreaUnit">
            <summary>
            The unit format of the movement area.
            This is used to determine the data format of <see cref="P:Rewired.PlayerMouse.movementArea"/>.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.screenPosition">
            <summary>
            The screen position on the current frame.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.screenPositionPrev">
            <summary>
            The screen position on the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.screenPositionDelta">
            <summary>
            The change in screen position since the previous frame.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.xAxis">
            <summary>
            The horizontal axis or the first axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.yAxis">
            <summary>
            The vertical axis or the second axis.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.wheel">
            <summary>
            The wheel (or the first wheel if multiple exist.)
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.leftButton">
            <summary>
            The left or first button.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.rightButton">
            <summary>
            The right or second button.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.middleButton">
            <summary>
            The middle or third button.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.pointerSpeed">
            <summary>
            The pointer speed. This does not affect the speed of input from the mouse x/y axes if
            useHardwarePointerPosition is enabled. It only affects the speed
            from input sources other than mouse x/y or if mouse x/y are mapped to Actions
            assigned to Axes.
            </summary>
        </member>
        <member name="P:Rewired.PlayerMouse.useHardwarePointerPosition">
            <summary>
            If enabled, the hardware pointer position will be used for mouse input.
            Otherwise, the position of the pointer will be calculated only from
            the Axis Action values.
            The Player that owns this Player Mouse must have the physical mouse assigned to it in order for the hardware position to be used, ex: player.controllers.hasMouse == true.
            </summary>
        </member>
        <member name="E:Rewired.PlayerMouse.ScreenPositionChangedEvent">
            <summary>
            Triggers when the screen position changes.
            </summary>
        </member>
        <member name="T:Rewired.PlayerMouse.Definition">
            <summary>
            Definition for a Player Mouse.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.defaultToCenter">
            <summary>
            If enabled, the screen position will default to the center of the allowed movement area.
            Otherwise, it will default to the lower-left corner of the allowed movement area.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.clampToMovementArea">
            <summary>
            If enabled, movement will be clamped to the <see cref="F:Rewired.PlayerMouse.Definition.movementArea"/>.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.movementArea">
            <summary>
            The allowed movement area for the mouse pointer.
            Set <see cref="F:Rewired.PlayerMouse.Definition.movementAreaUnit"/> to determine the data format of this value.
            This rect is a screen-space rect with 0, 0 at the lower-left corner.
            If you pass a UnityEngine.Rect in which represents 0, 0 as the upper-left corner, Y will automatically be flipped.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.movementAreaUnit">
            <summary>
            The unit format of the movement area.
            This is used to determine the data format of <see cref="F:Rewired.PlayerMouse.Definition.movementArea"/>.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.pointerSpeed">
            <summary>
            The pointer speed. This does not affect the speed of input from the mouse x/y axes if
            useHardwarePointerPosition is enabled. It only affects the speed
            from input sources other than mouse x/y or if mouse x/y are mapped to Actions
            assigned to Axes.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.Definition.useHardwarePointerPosition">
            <summary>
            If enabled, the hardware pointer position will be used for mouse input.
            Otherwise, the position of the pointer will be calculated only from
            the Axis Action values.
            </summary>
        </member>
        <member name="M:Rewired.PlayerMouse.Definition.#ctor">
            <summary>
            Creates a Definition with the default values.
            </summary>
        </member>
        <member name="T:Rewired.PlayerMouse.Factory">
            <summary>
            Class for creating Player Mouse instances.
            </summary>
        </member>
        <member name="M:Rewired.PlayerMouse.Factory.Create">
            <summary>
            Creates a new Player Mouse with the default elements.
            </summary>
            <returns>A new Player Mouse.</returns>
        </member>
        <member name="M:Rewired.PlayerMouse.Factory.Create(System.Int32,System.Int32)">
            <summary>
            Creates a new Player Mouse.
            </summary>
            <param name="buttonCount">The number of Buttons to create.</param>
            <param name="axisCount">The number of Axes to create.</param>
            <returns>A new Player Mouse.</returns>
        </member>
        <member name="M:Rewired.PlayerMouse.Factory.Create(Rewired.PlayerMouse.Definition)">
            <summary>
            Creates a new Player Mouse.
            </summary>
            <param name="definition">Definition use to set initial values in the controller.</param>
            <returns>A new Player Mouse.</returns>
        </member>
        <member name="T:Rewired.PlayerMouse.MovementAreaUnit">
            <summary>
            The unit of the movement area.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.MovementAreaUnit.Screen">
            <summary>
            Screen units.
            0, 0 = lower-corner of the screen, 1, 1 = upper-right corner of the screen.
            </summary>
        </member>
        <member name="F:Rewired.PlayerMouse.MovementAreaUnit.Pixel">
            <summary>
            Pixel units.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource.Controller">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource.Joystick">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.Custom.CustomInputSource.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.ConfigVars">
            <summary>
            Configuration variables for the Input Manager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.IConfigVars_Internal">
            <summary>
            Provides an interface to get and set values in ConfigVars from plugins.
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_disableKeyboard">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_disableKeyboard(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_ignoreInputWhenAppNotInFocus">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_useEnhancedDeviceSupport">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_useNativeMouse">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_useNativeKeyboard">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_joystickRefreshRate">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVar_assignJoysticksBySystemId">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_ignoreInputWhenAppNotInFocus(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_useEnhancedDeviceSupport(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_useNativeMouse(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_useNativeKeyboard(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_joystickRefreshRate(System.Int32)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.SetPlatformVar_assignJoysticksBySystemId(System.Boolean)">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="M:Rewired.Data.ConfigVars.GetPlatformVars">
            <summary>
            Runtime only!
            </summary>
        </member>
        <member name="T:Rewired.Data.ConfigVars.PlatformVars">
            <summary>
            Configuration variables for the Input Manager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.ConfigVars.EditorVars">
            <summary>
            Editor configuration variables for the Input Manager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.ControllerDataFiles">
            <summary>
            Stores the supported controller hardware maps.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.CustomController_Editor">
            <summary>
            Custom Controller data stored in the InputManager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.EditorSettings">
            <summary>
            Stores editor data.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.ActionCategoryMap">
            <summary>
            Maps actions to an action category.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Classes.SerializedMethod">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap">
            <summary>
            A hardware controller profile. Maps physical hardware elements to identifiable elements on supported platforms.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.IHardwareControllerMap">
            <summary>
            Interface for hardware controller maps.
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.IHardwareControllerMap_Internal">
            <summary>
            Interface for hardware controller maps.
            </summary>
        </member>
        <member name="M:Rewired.Data.Mapping.HardwareJoystickMap.GetSpecificPlatformMap(Rewired.HardwareControllerMapIdentifier)">
            <summary>
            Get a specific Platform map at the location pointed to by HardwareControllerMapIdentifier.
            </summary>
        </member>
        <member name="M:Rewired.Data.Mapping.HardwareJoystickMap.GetSpecificPlatformRoot(Rewired.InputPlatform)">
            <summary>
            Get the root-level Platform for the InputPlatform. Does not do any kind of fallbacks.
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform">
            <exclude></exclude>
        </member>
        <member name="P:Rewired.Data.Mapping.HardwareJoystickMap.Platform.isAllowed">
            <summary>
            Determines whether this map is allowed on the system. It incorporates Unity version checking or other type checking not dependent on the joystick.
            DOES NOT check whether hasData because this would cause it to fail on Default and special maps.
            DOES check whether any buttons or axes have been assigned though.
            </summary>
        </member>
        <member name="P:Rewired.Data.Mapping.HardwareJoystickMap.Platform.variants_base">
            <summary>
            Gets a list of all Variants. NOT NULL FILTERED! Safe to use to get varaint index.
            </summary>
        </member>
        <member name="P:Rewired.Data.Mapping.HardwareJoystickMap.Platform.Variants">
            <summary>
            Enumerates all Variants. YES NULL FILTERED! NOT SAFE to use to get varaint index.
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Elements_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.MatchingCriteria_Base">
            <exclude></exclude>
        </member>
        <member name="P:Rewired.Data.Mapping.HardwareJoystickMap.MatchingCriteria_Base.isAllowed">
            <summary>
            Determines whether this map is allowed on the system. It incorporates Unity version checking or other type checking not dependent on the joystick.
            DOES NOT check whether hasData because this would cause it to fail on Default and special maps.
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.CompoundElement">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.VidPid">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.AxisCalibrationInfoEntry">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.Elements_Platform_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.CustomCalculationSourceData">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.Button_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.Axis_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawOrDirectInput.DeviceType">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_DirectInput_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_DirectInput_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_DirectInput_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_DirectInput_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_DirectInput">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawInput_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawInput_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawInput_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawInput_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_RawInput">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XInput">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_OSX">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Linux">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WindowsUWP">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Fallback">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.CustomCalculationSourceData">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Custom.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Ouya">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_XboxOne">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS4">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_NintendoSwitch">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Stadia">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.DeviceType">
            <summary>
            DO NOT CHANGE THESE VALUES.
            MUST MATCH TO THE GameCore PrimaryTemplateType enum
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore_Base.GamepadSubType">
            <summary>
            DO NOT MODIFY THE NUMBERING.
            THIS MUST MATCH THE HARDWARE JOYSTICK MAP GamepadSubType
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_GameCore">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_PS5">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_InternalDriver">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base.Element">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_SDL2">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Steam_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Steam_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Steam_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_Steam">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL_Base">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL_Base.MatchingCriteria">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL_Base.Elements">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL_Base.Button">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL_Base.Axis">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickMap.Platform_WebGL">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareControllerTemplateMap">
            <summary>
            Base class for controller template maps.
            </summary>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareJoystickTemplateMap">
            <summary>
            Maps hardware joystick maps to a common template.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareElementSourceType">
            <summary>
            The type of this hardware element.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareElementSourceTypeWithHat">
            <summary>
            The type of this hardware element including hats.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HatDirection">
            <summary>
            A specific direction of a hat.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HatType">
            <summary>
            The type of hat.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.AxisDirection">
            <summary>
            A specific direction of an axis.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.HardwareAxisType">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.AxisCalibrationType">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.SpecialAxisType">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.Mapping.AlternateAxisCalibrationType">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.RuntimeData">
            <summary>
            Data used during runtime.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.EditorPlatformData">
            <summary>
            Data used in the editor.
            </summary>
        </member>
        <member name="T:Rewired.Data.EditorPlatformData.Platform">
            <summary>
            Represents a platform.
            </summary>
        </member>
        <member name="T:Rewired.Data.Player_Editor">
            <summary>
            Player data stored in an InputManager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.UserData">
            <summary>
            User data stored in an InputManager.
            </summary>
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerNames">
            <summary>
            Returns EDITOR player names starting with System, not runtime
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerNames(System.Collections.Generic.IList{System.String})">
            <summary>
            Returns EDITOR player names starting with System, not runtime
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerIds">
            <summary>
            Returns EDITOR playerIds, not runtime.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerRuntimeIds">
            <summary>
            These are sorted by editor order, not game order.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerRuntimeIds(System.Collections.Generic.IList{System.Int32})">
            <summary>
            These are sorted by editor order, not game order.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerNameById(System.Int32)">
            <summary>
            Returns EDITOR playerId, not runtime
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayer(System.Int32)">
            <summary>
            Returns EDITOR player, not runtime
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.GetPlayerId(System.String)">
            <summary>
            Returns EDITOR playerId, not runtime
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.FindJoystickMap_Game(Rewired.Joystick,System.Int32,System.Int32)">
            <summary>
            Searches the user-defined maps for a matching map based on category, layout, controller Guid, and template Guid.
            First it will search for an exact controller guid + category + layout match. If no controller guid's match, it search for a template
            map. Failing that, it will search for a generic map. If no map is found, a blank map will be loaded.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.FindKeyboardMap_Game(Rewired.Keyboard,System.Int32,System.Int32)">
            <summary>
            Searches the user-defined maps for a matching map based on category, layout, controller Guid, and template Guid.
            First it will search for an exact controller guid + category + layout match. If no controller guid's match, it search for a template
            map. Failing that, it will search for a generic map. If no map is found, a blank map will be loaded.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.FindMouseMap_Game(Rewired.Mouse,System.Int32,System.Int32)">
            <summary>
            Searches the user-defined maps for a matching map based on category, layout, controller Guid, and template Guid.
            First it will search for an exact controller guid + category + layout match. If no controller guid's match, it search for a template
            map. Failing that, it will search for a generic map. If no map is found, a blank map will be loaded.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.FindCustomControllerMap_Game(System.Guid,System.Int32,System.Int32)">
            <summary>
            Searches the user-defined maps for a matching map based on category, layout, controller Guid, and template Guid.
            First it will search for an exact controller guid + category + layout match. If no controller guid's match, it search for a template
            map. Failing that, it will search for a generic map. If no map is found, a blank map will be loaded.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserData.FindCustomControllerMap_Game(System.Int32,System.Int32,System.Int32)">
            <summary>
            Searches the user-defined maps for a matching map based on category, layout, controller Guid, and template Guid.
            First it will search for an exact controller guid + category + layout match. If no controller guid's match, it search for a template
            map. Failing that, it will search for a generic map. If no map is found, a blank map will be loaded.
            </summary>
        </member>
        <member name="T:Rewired.Data.UserDataStore">
            <summary>
            Base class for Rewired data storage system. Implement this class to make a custom data store.
            </summary>
        </member>
        <member name="T:Rewired.Interfaces.IUserDataStore">
            <summary>
            Interface for UserDataStore. Used for saving and loading controller configuration data.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.Save">
            <summary>
            Save all data now.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.SaveControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.SaveControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller. Does not save Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.SavePlayerData(System.Int32)">
            <summary>
            Save all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.SaveInputBehavior(System.Int32,System.Int32)">
            <summary>
            Save all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.Load">
            <summary>
            Load all data now.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.LoadControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.LoadControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller. Does not load Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.LoadPlayerData(System.Int32)">
            <summary>
            Load all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Interfaces.IUserDataStore.LoadInputBehavior(System.Int32,System.Int32)">
            <summary>
            Load all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="T:Rewired.Interfaces.IControllerMapStore">
            <summary>
            An interface for loading and saving Controller Maps.
            </summary>
        </member>
        <member name="M:Rewired.Interfaces.IControllerMapStore.SaveControllerMap(System.Int32,Rewired.ControllerMap)">
            <summary>
            Saves a Controller Map.
            </summary>
            <param name="playerId">The Player id</param>
            <param name="controllerMap">The Controller Map</param>
        </member>
        <member name="M:Rewired.Interfaces.IControllerMapStore.LoadControllerMap(System.Int32,Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Loads a Controller Map for a Controller.
            </summary>
            <param name="playerId">The Player id</param>
            <param name="controllerIdentifier">Controller Identifier for the Controller. Get this from <see cref="P:Rewired.Controller.identifier"/>.</param>
            <param name="categoryId">The Map Category id of the Controller Map</param>
            <param name="layoutId">The Layout id of the Controller Map</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Data.UserDataStore.Load">
            <summary>
            Load all data now.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore.LoadControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.LoadControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Load all data for a specific controller. Does not load Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.LoadPlayerData(System.Int32)">
            <summary>
            Load all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.LoadInputBehavior(System.Int32,System.Int32)">
            <summary>
            Load all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.Save">
            <summary>
            Save all data now.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore.SaveControllerData(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.SaveControllerData(Rewired.ControllerType,System.Int32)">
            <summary>
            Save all data for a specific controller. Does not save Player data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.SavePlayerData(System.Int32)">
            <summary>
            Save all data for a specific Player.
            </summary>
            <param name="playerId">Player id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.SaveInputBehavior(System.Int32,System.Int32)">
            <summary>
            Save all data for a specific InputBehavior for a Player.
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.SaveControllerMap(System.Int32,Rewired.ControllerMap)">
            <summary>
            Saves a Controller Map.
            </summary>
            <param name="playerId">The Player id</param>
            <param name="controllerMap">The Controller Map</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.LoadControllerMap(System.Int32,Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Loads a Controller Map for a Controller.
            </summary>
            <param name="playerId">The Player id</param>
            <param name="controllerIdentifier">Controller Identifier for the Controller. Get this from <see cref="P:Rewired.Controller.identifier"/>.</param>
            <param name="categoryId">The Map Category id of the Controller Map</param>
            <param name="layoutId">The Layout id of the Controller Map</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Data.UserDataStore.OnInitialize">
            <summary>
            Called when SaveDataStore is initialized.
            </summary>
        </member>
        <member name="M:Rewired.Data.UserDataStore.OnControllerConnected(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Called when a controller is connected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.OnControllerDisconnected(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Calls after a controller has been disconnected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.OnControllerPreDiscconnect(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Called when a controller is about to be disconnected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="M:Rewired.Data.UserDataStore.OnControllerPreDisconnect(Rewired.ControllerStatusChangedEventArgs)">
            <summary>
            Called when a controller is about to be disconnected.
            </summary>
            <param name="args">ControllerStatusChangedEventArgs</param>
        </member>
        <member name="T:Rewired.ActiveControllerChangedDelegate">
            <summary>
            Delegate for a current active controller change.
            </summary>
            <param name="controller">The active Controller</param>
        </member>
        <member name="T:Rewired.PlayerActiveControllerChangedDelegate">
            <summary>
            Delegate for a current active controller change in a Player.
            </summary>
            <param name="player">The Player</param>
            <param name="controller">The active Controller</param>
        </member>
        <member name="T:Rewired.ModifierKey">
            <summary>
            A keyboard modifier key type.
            </summary>
        </member>
        <member name="T:Rewired.ModifierKeyFlags">
            <summary>
            Keyboard modifier keys as flags.
            </summary>
        </member>
        <member name="T:Rewired.KeyboardKeyCode">
            <summary>
            A keyboard key code.
            </summary>
        </member>
        <member name="T:Rewired.MouseInputElement">
            <summary>
            An input element on the mouse.
            </summary>
        </member>
        <member name="T:Rewired.MouseXYAxisMode">
            <summary>
            The mode for the mouse's X and Y axes.
            </summary>
        </member>
        <member name="T:Rewired.MouseXYAxisDeltaCalc">
            <summary>
            The delta calulation mode for the mouse's X and Y axes.
            </summary>
        </member>
        <member name="T:Rewired.MouseOtherAxisMode">
            <summary>
            The mode for the mouse's other axes apart from X and Y.
            </summary>
        </member>
        <member name="T:Rewired.InputActionType">
            <summary>
            The expected element type of an action.
            </summary>
        </member>
        <member name="T:Rewired.AxisType">
            <summary>
            The type of axis.
            </summary>
        </member>
        <member name="F:Rewired.AxisType.None">
            <summary>
            Not an axis.
            </summary>
        </member>
        <member name="F:Rewired.AxisType.Normal">
            <summary>
            A full axis with both positive and negative sides.
            </summary>
        </member>
        <member name="F:Rewired.AxisType.Split">
            <summary>
            One half of an axis with only a positive or negative side.
            </summary>
        </member>
        <member name="T:Rewired.Pole">
            <summary>
            A positive or negative value.
            </summary>
        </member>
        <member name="F:Rewired.Pole.Positive">
            <summary>
            Positive value.
            </summary>
        </member>
        <member name="F:Rewired.Pole.Negative">
            <summary>
            Negative value.
            </summary>
        </member>
        <member name="T:Rewired.AxisRange">
            <summary>
            The range of an axis.
            </summary>
        </member>
        <member name="F:Rewired.AxisRange.Full">
            <summary>
            A complete axis with both positive and negative sides.
            </summary>
        </member>
        <member name="F:Rewired.AxisRange.Positive">
            <summary>
            Only the positive side of the axis.
            </summary>
        </member>
        <member name="F:Rewired.AxisRange.Negative">
            <summary>
            Only the negative side of the axis.
            </summary>
        </member>
        <member name="T:Rewired.AxisCoordinateMode">
            <summary>
            The axis coordinate mode.
            </summary>
        </member>
        <member name="F:Rewired.AxisCoordinateMode.Absolute">
            <summary>
            Represents the position of the axis in relation to a fixed point.
            </summary>
        </member>
        <member name="F:Rewired.AxisCoordinateMode.Relative">
            <summary>
            Represents the change in position of the axis since the last time the value was retreived.
            </summary>
        </member>
        <member name="T:Rewired.ControllerType">
            <summary>
            The type of a controller.
            </summary>
        </member>
        <member name="F:Rewired.ControllerType.Keyboard">
            <summary>
            A keyboard.
            </summary>
        </member>
        <member name="F:Rewired.ControllerType.Mouse">
            <summary>
            A mouse.
            </summary>
        </member>
        <member name="F:Rewired.ControllerType.Joystick">
            <summary>
            A joystick.
            </summary>
        </member>
        <member name="F:Rewired.ControllerType.Custom">
            <summary>
            A Custom Controller.
            </summary>
        </member>
        <member name="T:Rewired.ControllerElementType">
            <summary>
            The type of an element in a controller.
            </summary>
        </member>
        <member name="T:Rewired.CompoundControllerElementType">
            <summary>
            The type of a compound element in a controller.
            </summary>
        </member>
        <member name="T:Rewired.DeadZone2DType">
            <summary>
            Calculation type for 2D deadzones.
            </summary>
        </member>
        <member name="T:Rewired.AxisSensitivity2DType">
            <summary>
            Calculation type for sensitivity on 2D axes.
            </summary>
        </member>
        <member name="T:Rewired.ElementAssignmentType">
            <summary>
            The type of an element assignment.
            </summary>
        </member>
        <member name="T:Rewired.UpdateLoopType">
            <summary>
            Unity update loop type.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Rewired.InputActionEventType" -->
        <member name="F:Rewired.InputActionEventType.Update">
            <summary>
            Event fires every time input is updated.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonPressed">
            <summary>
            Event fires every frame a button is pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonUnpressed">
            <summary>
            Event fires every frame a button is not pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustPressed">
            <summary>
            Event fires only on the first frame a button is pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustReleased">
            <summary>
            Event fires only on the first frame a button is released.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonDoublePressed">
            <summary>
            Event fires when a button is double pressed and every frame that it is held afterwards.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustDoublePressed">
            <summary>
            Event fires only on the first frame a button is double pressed.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonPressedForTime">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            Requires 1 argument: time [float]
            1 argument is optional: expireIn [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustPressedForTime">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            Requires 1 argument: time [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonPressedForTimeJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            Requires 1 argument: time [float]
            1 argument is optional: expireIn [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonShortPressed">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.ButtonPressedForTime">ButtonPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustShortPressed">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.ButtonJustPressedForTime">ButtonJustPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonShortPressJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="!:InputActionEventType.ButtonJustPressedForTimeAndReleased">ButtonJustPressedForTimeAndReleased</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonLongPressed">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.ButtonPressedForTime">ButtonPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonJustLongPressed">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.ButtonJustPressedForTime">ButtonJustPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonLongPressJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="!:InputActionEventType.ButtonJustPressedForTimeAndReleased">ButtonJustPressedForTimeAndReleased</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonRepeating">
            <summary>
            Event fires on the first frame that a button has been pressed, then again after delay of the specified length
            and repeating on a regular interval as specified until the button is released. The delay and repeat rate are
            set in the Input Behavior assigned to the Action.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonPressed">
            <summary>
            Event fires every frame a button is pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonUnpressed">
            <summary>
            Event fires every frame a button is not pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustPressed">
            <summary>
            Event fires only on the first frame a button is pressed.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustReleased">
            <summary>
            Event fires only on the first frame a button is released.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonDoublePressed">
            <summary>
            Event fires when a button is double pressed and every frame that it is held afterwards.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustDoublePressed">
            <summary>
            Event fires only on the first frame a button is double pressed.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonPressedForTime">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            Requires 1 argument: time [float]
            1 argument is optional: expireIn [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustPressedForTime">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            Requires 1 argument: time [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonPressedForTimeJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            Requires 1 argument: time [float]
            1 argument is optional: expireIn [float]
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonShortPressed">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.NegativeButtonPressedForTime">NegativeButtonPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustShortPressed">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.NegativeButtonJustPressedForTime">NegativeButtonJustPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonShortPressJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            The button short press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="!:InputActionEventType.NegativeButtonJustPressedForTimeAndReleased">NegativeButtonJustPressedForTimeAndReleased</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonLongPressed">
            <summary>
            Event fires when a button has been pressed for a specific time period and every frame that it is held afterwards.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.NegativeButtonPressedForTime">NegativeButtonPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonJustLongPressed">
            <summary>
            Event fires only on the frame that a button has been pressed for a specific time period.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="F:Rewired.InputActionEventType.NegativeButtonJustPressedForTime">NegativeButtonJustPressedForTime</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonLongPressJustReleased">
            <summary>
            Event fires only on the frame that a button that has been pressed for a specific time period is released.
            The button long press time and expiration are set in the Input Behavior assigned to the Action.
            For a custom duration, use <see cref="!:InputActionEventType.NegativeButtonJustPressedForTimeAndReleased">NegativeButtonJustPressedForTimeAndReleased</see> instead.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.NegativeButtonRepeating">
            <summary>
            Event fires on the first frame that a button has been pressed, then again after delay of the specified length
            and repeating on a regular interval as specified until the button is released. The delay and repeat rate are
            set in the Input Behavior assigned to the Action.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisActive">
            <summary>
            Event fires every frame the axis value is non-zero.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisInactive">
            <summary>
            Event fires every frame the axis value is zero.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisRawActive">
            <summary>
            Event fires every frame the raw axis value is non-zero.
            This does not fire when the axis value is zero.
            If you need to know both when the axis value is non-zero and when it returns to zero, see <see cref="F:Rewired.InputActionEventType.AxisRawActiveOrJustInactive"/>.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisRawInactive">
            <summary>
            Event fires every frame the raw axis value is zero.
            This does not fire when the axis value is zero.
            If you need to know both when the axis value is non-zero and when it returns to zero, see <see cref="F:Rewired.InputActionEventType.AxisActiveOrJustInactive"/>.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisActiveOrJustInactive">
            <summary>
            Event fires every frame the axis value is non-zero and once more when the axis returns to zero.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.AxisRawActiveOrJustInactive">
            <summary>
            Event fires every frame the raw axis value is non-zero and once more when the axis returns to zero.
            </summary>
        </member>
        <member name="F:Rewired.InputActionEventType.ButtonDoublePressJustReleased">
            <summary>
            Event fires only on the first frame after a button is released after a double press.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.ButtonSinglePressed" -->
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.ButtonJustSinglePressed" -->
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.ButtonSinglePressJustReleased" -->
        <member name="F:Rewired.InputActionEventType.NegativeButtonDoublePressJustReleased">
            <summary>
            Event fires only on the first frame after a negative button is released after a double press.
            Accepts optional arguments: speed [float]
            If no arguments are passed, <see cref="P:Rewired.InputBehavior.buttonDoublePressSpeed"/> will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.NegativeButtonSinglePressed" -->
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.NegativeButtonJustSinglePressed" -->
        <!-- Badly formed XML comment ignored for member "F:Rewired.InputActionEventType.NegativeButtonSinglePressJustReleased" -->
        <member name="T:Rewired.AxisSensitivityType">
            <summary>
            Axis sensitivity calculation type.
            </summary>
        </member>
        <member name="F:Rewired.AxisSensitivityType.Multiplier">
            <summary>
            Value is multiplied by sensitivity.
            </summary>
        </member>
        <member name="F:Rewired.AxisSensitivityType.Power">
            <summary>
            Value is raised to a power.
            As power nears 0, sensitivity of the axis closer to the zero/center position increases, while sensitivty closer the max position decreases.
            As power increases past 1, sensitivity of the axis closer to the zero/center position decreases, while sensitivity close to the max position increases.
            </summary>
        </member>
        <member name="F:Rewired.AxisSensitivityType.Curve">
            <summary>
            Value is multiplied by a point on a curve.
            </summary>
        </member>
        <member name="T:Rewired.JoystickType">
            <summary>
            Joystick type.
            </summary>
        </member>
        <member name="T:Rewired.Initializer">
            <exclude></exclude>
        </member>
        <member name="F:Rewired.Initializer._inputManagerPrefab">
            <exclude></exclude>
        </member>
        <member name="F:Rewired.Initializer._destroySelf">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Initializer.Initialize">
            <summary>
            Spawns the prefab if one does not already exist.
            </summary>
        </member>
        <member name="P:Rewired.Initializer.inputManagerPrefab">
            <summary>
            Set this to a prefab of your Rewired Input Manager.
            </summary>
        </member>
        <member name="P:Rewired.Initializer.destroySelf">
            <summary>
            Destroy this GameObject after initialization.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Interfaces.IExternalTools">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Interfaces.IExternalInputManager">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Interfaces.IKeyedData`1">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.UI.ITouchInputSource">
            <summary>
            Interface for a touch input source for UI interaction.
            </summary>
        </member>
        <member name="M:Rewired.HID.Drivers.DualSenseDriver.GetTwist(UnityEngine.Quaternion,UnityEngine.Vector3)">
                       Decompose the rotation on to 2 parts.
                       1. Twist - rotation around the "direction" vector
                       2. Swing - rotation around axis that is perpendicular to "direction" vector
                       The rotation can be composed back by 
                       rotation = swing * twist
            
                       has singularity in case of swing_rotation close to 180 degrees rotation.
                       if the input quaternion is of non-unit length, the outputs are non-unit as well
                       otherwise, outputs are both unit
        </member>
        <member name="M:Rewired.HID.Drivers.DualShock4Driver.GetTwist(UnityEngine.Quaternion,UnityEngine.Vector3)">
                       Decompose the rotation on to 2 parts.
                       1. Twist - rotation around the "direction" vector
                       2. Swing - rotation around axis that is perpendicular to "direction" vector
                       The rotation can be composed back by 
                       rotation = swing * twist
            
                       has singularity in case of swing_rotation close to 180 degrees rotation.
                       if the input quaternion is of non-unit length, the outputs are non-unit as well
                       otherwise, outputs are both unit
        </member>
        <member name="T:Rewired.Utils.Classes.Data.ExpandableArray_DataContainer`1">
            <summary>
            An expandable array which uses objects to hold data.
            Creates an object for every entry. These objects remain even when Clear is called, but the contents are cleared.
            Data is added by padding another instance of T object from which the contents are copied to the public object.
            The passed object itself is not added, but objects contained in the passer object are stored by reference (not cloned).
            You cannot add objects to the list directly, only data witin the object.
            Your T must implement the Workpool_DataContainer&lt;T&gt;.IEntry interface.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rewired.HID.HidOutputReportHandler">
            <summary>
            Creates a dedicated thread to send output reports.
            This is unbuffered and can only be used for a single HID device.
            </summary>
        </member>
        <member name="M:Rewired.HID.HidOutputReportHandler.#ctor(Rewired.HID.HidOutputReportHandler.WriteReportDelegate)">
            <param name="writeReportDelegate">Delegate to send HID report to the device. Must be threadsafe!</param>
        </member>
        <member name="M:Rewired.HID.HidOutputReportHandler.WriteReport(Rewired.HID.OutputReport)">
            <summary>
            Enqueue a report to send to the device. The incoming report data is copied before sending, so the buffer does not need to be unique.
            </summary>
        </member>
        <member name="M:Rewired.HID.HidOutputReportHandler.Dispose(System.Boolean)">
            <summary>
            Dispose should only be called on the same thread that instantiated this and
            the same thread that is sending the output reports.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Rewired.HID.SpecialDevices.SpecialDeviceInfo.IsMatch(System.UInt16,System.UInt16,System.String)">
            <summary>
            Matches on VID/PID or Product Name. Does not require all 3 to match.
            </summary>
        </member>
        <member name="T:Rewired.InputManager_Base">
            <exclude></exclude>
        </member>
        <member name="P:Rewired.InputManager_Base.runInEditMode">
            <summary>
            Makes Rewired run in the editor outside of Play mode.
            Note that the state of objects is not maintained between Edit mode and Play mode.
            For example, Joystick assignments do not persist when switching between modes.
            See the Input Manager documentation for other important information about running in Edit mode.
            </summary>
        </member>
        <member name="P:Rewired.InputManager_Base.isRunningInEditMode">
            <summary>
            Is this Rewired Input Manager currently running in Edit mode?
            </summary>
        </member>
        <member name="T:Rewired.Internal.OnGUIHelper">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Internal.StandaloneAxis.SetRawValue(System.Single)">
            <summary>
            Sets the raw value of the axis.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:Rewired.Internal.StandaloneAxis.Clear">
            <summary>
            Clears the axis value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.buttonActivationThreshold">
            <summary>
            The axis value at or above which the buttonValue property will return True. This will also return true for negative values below the inverse of this threshold.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.calibration">
            <summary>
            Contains calibration settings for the axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.valueRaw">
            <summary>
            The raw value of the axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.valueRawPrev">
            <summary>
            The previous raw value of the axis. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.valueRawDelta">
            <summary>
            The difference between the current raw value and the previous raw value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.value">
            <summary>
            The calibrated value of the axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.valuePrev">
            <summary>
            The previous calibrated value of the axis. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.valueDelta">
            <summary>
            The difference between the current calibrated value and the previous calibrated value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.rawButtonValue">
            <summary>
            The button value calculated from the raw axis value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.rawButtonValuePrev">
            <summary>
            The previous button value calculated from the raw axis value. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.buttonValue">
            <summary>
            The button value calculated from the calibrated axis value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis.buttonValuePrev">
            <summary>
            The previous button value calculated from the calibrated axis value. Note that this is previous value set, but not necessarily the value in the last frame.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.AxisValueChangedEvent">
            <summary>
            Event that fires when the calibrated axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.RawAxisValueChangedEvent">
            <summary>
            Event that fires when the raw axis value changes.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.ButtonDownEvent">
            <summary>
            Event that fires when the button is just pressed.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.ButtonUpEvent">
            <summary>
            Event that fires when the button is just released.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.ButtonValueChangedEvent">
            <summary>
            Event that fires when the button value changes.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.RawButtonDownEvent">
            <summary>
            Event that fires with the button is just pressed based on the raw axis value.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.RawButtonUpEvent">
            <summary>
            Event that fires with the button is just released based on the raw axis value.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis.RawButtonValueChangedEvent">
            <summary>
            Event that fires with the button value changes based on the raw axis value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.calibration">
            <summary>
            Contains calibration settings for the 2D axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.xAxis">
            <summary>
            The X axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.yAxis">
            <summary>
            The Y axis.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.value">
            <summary>
            The calibrated value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.valuePrev">
            <summary>
            The previous calibrated value.
            Note: Previous is not necessarily the value in the previous frame, but rather the previous value that was input into the axes.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.valueDelta">
            <summary>
            The difference between the current calibrated value and previous calibrated value.
            Note: Previous is not necessarily the value in the previous frame, but rather the previous value that was input into the axes.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.rawValue">
            <summary>
            The raw value.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.rawValuePrev">
            <summary>
            The previous raw value.
            Note: Previous is not necessarily the value in the previous frame, but rather the previous value that was input into the axes.
            </summary>
        </member>
        <member name="P:Rewired.Internal.StandaloneAxis2D.rawValueDelta">
            <summary>
            The difference between the current raw value and previous raw value.
            Note: Previous is not necessarily the value in the previous frame, but rather the previous value that was input into the axes.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis2D.ValueChangedEvent">
            <summary>
            Event fired when the calibrated value changes.
            </summary>
        </member>
        <member name="E:Rewired.Internal.StandaloneAxis2D.RawValueChangedEvent">
            <summary>
            Event fired when the raw value changes.
            </summary>
        </member>
        <member name="T:Rewired.VirtualButton">
            <summary>
            A virtual button that is used to track button states for things like
            keyboard + modifier keys and mouse axes being treated as digital buttons.
            This is auto-cleared every update by Control Manager.
            You cannot set the button value to false, only true.
            It can be set multiple times per frame as well without issue.
            </summary>
        </member>
        <member name="M:Rewired.VirtualButton.SetOn(Rewired.UpdateLoopType,System.Boolean)">
            <summary>
            This does not store the valuePrev at this time so it can be set multiple times per update.
            You cannot set a negative value here because the button may be fed by multiple sources and
            negatives cannot cancel out positives. The button value will be cleared at the end up update.
            </summary>
        </member>
        <member name="M:Rewired.VirtualButton.InnerButton.SetOn(System.Boolean)">
            <summary>
            This does not store the valuePrev at this time so it can be set multiple times per update.
            You cannot set a negative value here because the button may be fed by multiple sources and
            negatives cannot cancel out positives. The button value will be cleared at the end up update.
            </summary>
        </member>
        <member name="T:Rewired.VirtualButton.InnerButton.ButtonValueFlags">
            <summary>
            Represents the value and previous 
            </summary>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxis">
            <summary>
            Gets the axis value of an Action.
            </summary>
            <returns>The axis value.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisPrev">
            <summary>
            Gets the axis value of an Action during the previous frame.
            </summary>
            <returns>The previous axis value.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisDelta">
            <summary>
            Gets the change in axis value of an Action since the previous frame.
            </summary>
            <returns>The change in axis value.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisTimeActive">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active. Returns 0 if the axis is not currently active.
            </summary>
            <returns>The duration the axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisTimeInactive">
            <summary>
            Gets the length of time in seconds that an axis has been inactive. Returns 0 if the axis is currently active.
            </summary>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisCoordinateMode">
            <summary>
            Gets the current coordinate mode of the axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisCoordinateModePrev">
            <summary>
            Gets the coordinate mode of the axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <returns>The axis coordinate mode.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetAxisRaw" -->
        <member name="M:Rewired.PlayerAction.GetAxisRawPrev">
            <summary>
            Gets the axis value of an Action during the previous frame.
            </summary>
            <returns>The previous axis value.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetAxisRawDelta" -->
        <member name="M:Rewired.PlayerAction.GetAxisRawTimeActive">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active as calculated from the raw value. Returns 0 if the axis is not currently active.
            </summary>
            <returns>The duration the raw axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisRawTimeInactive">
            <summary>
            Gets the length of time in seconds that an axis has been inactive as calculated from the raw value. Returns 0 if the axis is currently active.
            </summary>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisRawCoordinateMode">
            <summary>
            Gets the current coordinate mode of the raw axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetAxisRawCoordinateModePrev">
            <summary>
            Gets the coordinate mode of the raw axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButton">
            <summary>
            Gets the button held state of an Action. This will return TRUE as long as the button is held.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonDown" -->
        <member name="M:Rewired.PlayerAction.GetButtonUp">
            <summary>
            Get the button just released state for an Action. This will only return TRUE for the first frame the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The button just released state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonSinglePressHold" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonSinglePressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonSinglePressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonDoublePressHold" -->
        <member name="M:Rewired.PlayerAction.GetButtonDoublePressHold(System.Single)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonDoublePressDown" -->
        <member name="M:Rewired.PlayerAction.GetButtonDoublePressDown(System.Single)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just pressed state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonDoublePressUp" -->
        <member name="M:Rewired.PlayerAction.GetButtonDoublePressUp(System.Single)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimedPress(System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimedPress(System.Single,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time in seconds the button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimedPressDown(System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimedPressUp(System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimedPressUp(System.Single,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes being used as buttons.
            </summary>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The button up state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonShortPress" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonShortPressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonShortPressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonLongPress" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonLongPressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonLongPressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetButtonRepeating" -->
        <member name="M:Rewired.PlayerAction.GetButtonPrev">
            <summary>
            Gets the button held state of an Action during the previous frame.
            </summary>
            <returns>The previous button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimePressed">
            <summary>
            Gets the length of time in seconds that a button has been continuously held down. Returns 0 if the button is not currently pressed.
            </summary>
            <returns>The duration of the button hold.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetButtonTimeUnpressed">
            <summary>
            Gets the length of time in seconds that a button has not been pressed. Returns 0 if the button is currently pressed.
            </summary>
            <returns>The duration of the button inactivity.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButton">
            <summary>
            Gets the negative button held state of an Action. This will return TRUE as long as the negative button is held.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The negative button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonDown" -->
        <member name="M:Rewired.PlayerAction.GetNegativeButtonUp">
            <summary>
            Get the negative button just released state for an Action. This will only return TRUE for the first frame the negative button is released.
            This also applies to axes being used as buttons.
            </summary>
            <returns>The negative button just released state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonSinglePressHold" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonSinglePressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonSinglePressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonDoublePressHold" -->
        <member name="M:Rewired.PlayerAction.GetNegativeButtonDoublePressHold(System.Single)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button held state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonDoublePressDown" -->
        <member name="M:Rewired.PlayerAction.GetNegativeButtonDoublePressDown(System.Single)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonDoublePressUp" -->
        <member name="M:Rewired.PlayerAction.GetNegativeButtonDoublePressUp(System.Single)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimedPress(System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimedPress(System.Single,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time in seconds the negative button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimedPressDown(System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimedPressUp(System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimedPressUp(System.Single,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The negative button up state</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonShortPress" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonShortPressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonShortPressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonLongPress" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonLongPressDown" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonLongPressUp" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.PlayerAction.GetNegativeButtonRepeating" -->
        <member name="M:Rewired.PlayerAction.GetNegativeButtonPrev">
            <summary>
            Gets the negative button held state of an Action during the previous frame.
            </summary>
            <returns>The previous negative button held state</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimePressed">
            <summary>
            Gets the length of time in seconds that a negative button has been continuously held down. Returns 0 if the negative button is not currently pressed.
            </summary>
            <returns>The duration of the negative button hold.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.GetNegativeButtonTimeUnpressed">
            <summary>
            Gets the length of time in seconds that a negative button has not been pressed. Returns 0 if the negative button is currently pressed.
            </summary>
            <returns>The duration of the negative button inactivity.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.ClearButtonDownBuffer">
            <summary>
            Clears the button down buffer so GetButtonDown no longer returns true
            for the duration set in the Input Behavior assigned to this Action.
            </summary>
        </member>
        <member name="M:Rewired.PlayerAction.GetCurrentInputSources">
            <summary>
            Gets a list of all the input sources that contributed to the value of an Action in the current frame.
            </summary>
        </member>
        <member name="M:Rewired.PlayerAction.IsCurrentInputSource(Rewired.ControllerType)">
            <summary>
            Checks whether any controller of controller type contributed input to this Action in the current frame.
            </summary>
            <param name="controllerType">Type of the controller</param>
            <returns>Whether any controller type contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.IsCurrentInputSource(Rewired.ControllerType,System.Int32)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="controllerType">Type of the controller</param>
            <param name="controllerId">Id the controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.PlayerAction.IsCurrentInputSource(Rewired.Controller)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="controller">The controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="T:Rewired.ActionElementMap">
            <summary>
            Maps an Action to a Controller element.
            </summary>
        </member>
        <member name="M:Rewired.ActionElementMap.IsValidMap(Rewired.ActionElementMap)">
            <summary>
            Determines if an ActionElementMap is valid.
            Blank Action assignment is not considered invalid, but an Action Id that no longer exists is invalid.
            Only valid at runtime!
            </summary>
            <param name="map">The ActionElementMap</param>
            <returns></returns>
        </member>
        <member name="M:Rewired.ActionElementMap.#ctor(System.Int32,Rewired.ControllerElementType,Rewired.Pole,Rewired.KeyboardKeyCode,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ModifierKey)">
            <summary>
            Create an ActionElementMap for a keyboard key.
            </summary>
            <param name="actionId">Action id</param>
            <param name="elementType">Element type</param>
            <param name="axisContribution">Axis contribution</param>
            <param name="keyboardKeyCode">Keyboard key code</param>
            <param name="modifierKey1">Modifier key 1</param>
            <param name="modifierKey2">Modifier key 2</param>
            <param name="modifierKey3">Modifier key 3</param>
        </member>
        <member name="M:Rewired.ActionElementMap.CheckForAssignmentConflict(Rewired.ElementAssignment)">
            <summary>
            Checks if there are any assignment conflicts between the incoming ElementAssignment and this map.
            </summary>
            <param name="elementAssignment">The Element Assignment.</param>
            <returns>True if conflicts were found, false if not.</returns>
        </member>
        <member name="M:Rewired.ActionElementMap.CheckForAssignmentConflict(Rewired.ActionElementMap)">
            <summary>
            Checks if there are any assignment conflicts between the incoming ActionElementMap and this map.
            </summary>
            <param name="elementMap">The Action Element Map.</param>
            <returns>True if conflicts were found, false if not.</returns>
        </member>
        <member name="M:Rewired.ActionElementMap.ShowInField(Rewired.AxisRange)">
            <summary>
            Should this Action Element Map be shown in a particular input field with the specified range?
            This makes it easy to determine whether to show this map in a full, positive, or negative input field when remapping controls.
            </summary>
            <param name="fieldActionRange">The range of the input field.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ActionElementMap.IsTarget(Rewired.ControllerElementTarget)">
            <summary>
            Is the Controller Element target mapped by this ActionElementMap?
            </summary>
            <param name="elementTarget">The Controller Element target</param>
            <returns>True if the the Controller Element target is mapped by this ActionElementMap, false if it is not.</returns>
        </member>
        <member name="M:Rewired.ActionElementMap.IsTarget(Rewired.IControllerElementTarget)">
            <summary>
            Is the Controller Element target mapped by this ActionElementMap?
            </summary>
            <param name="elementTarget">The Controller Element target</param>
            <returns>True if the the Controller Element target is mapped by this ActionElementMap, false if it is not.</returns>
        </member>
        <member name="P:Rewired.ActionElementMap.actionId">
            <summary>
            Gets the id of the Action to which the element is bound.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.elementType">
            <summary>
            Gets the element type of the controller element bound to the Action.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.elementIdentifierId">
            <summary>
            The controller element identifier id bound to the Action.
            Warning: Do not change this value during iteration of the list of element mappings in a Controller Map.
            If the element type changes based on the new element identifier id, the element mapping list will be changed
            resulting in an InvalidOperationException during iteration.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.axisRange">
            <summary>
            The range of the axis.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.invert">
            <summary>
            Is the axis inverted?
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.axisContribution">
            <summary>
            The contribution to the Action's final value when queried as an axis.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.keyboardKeyCode">
            <summary>
            The keyboard key code. Only used for keyboard bindings. Returns Rewired.KeyboardKeyCode value.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.modifierKey1">
            <summary>
            The first keyboard modifier key.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.modifierKey2">
            <summary>
            The second keyboard modifier key.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.modifierKey3">
            <summary>
            The third keyboard modifier key.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.axisType">
            <summary>
            The axis type.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.modifierKeyFlags">
            <summary>
            Flags representing all the assigned keyboard modifier keys.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.keyCode">
            <summary>
            The keyboard key code. Only used for keyboard bindings. Returns UnityEngine.KeyCode value.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.hasModifiers">
            <summary>
            Does this use any keyboard modfiier keys?
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.controllerMap">
            <summary>
            The parent Controller Map that contains this ActionElementMap.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.enabled">
            <summary>
            Is the Action Element Map enabled? Disabled maps will never return input.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.elementIdentifierName">
            <summary>
            Gets the descriptive name of the element identifier bound to the Action.
            For split axes, this will return the Positive or Negative Descriptive Name or the Descriptive Name with a +/- suffix.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.actionDescriptiveName">
            <summary>
            Gets the descriptive name of the Action.
            For split axes, this will return the Positive or Negative Descriptive Name or the Descriptive Name with a +/- suffix.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.elementIndex">
            <summary>
            Gets the controller element index pointed to by this mapping.
            </summary>
        </member>
        <member name="P:Rewired.ActionElementMap.id">
            <summary>
            Gets the unique runtime id of this ActionElementMap. This value is not consistent between game sessions, so do not store it.
            </summary>
        </member>
        <member name="T:Rewired.CalibrationMapSaveData">
            <summary>
            Save data for a Calibration Map.
            </summary>
        </member>
        <member name="T:Rewired.JoystickCalibrationMapSaveData">
            <summary>
            Save data for a Joystick Calibration Map.
            </summary>
        </member>
        <member name="T:Rewired.CalibrationMap">
            <summary>
            Maps calibration data to a controller's axes.
            </summary>
        </member>
        <member name="M:Rewired.CalibrationMap.#ctor(Rewired.AxisCalibration[])">
            <summary>
            Creates a CalibrationMap from an array of AxisCalibrations.
            </summary>
            <param name="axisCalibrations">Array of AxisCalibrations</param>
        </member>
        <member name="M:Rewired.CalibrationMap.Reset">
            <summary>
            Resets all calibration data to hardware defaults.
            </summary>
        </member>
        <member name="M:Rewired.CalibrationMap.GetAxis(System.Int32)">
            <summary>
            Gets an AxisCalibration at a particular index.
            </summary>
            <param name="index">Index of the Axis</param>
            <returns>AxisCalibration</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.GetCalibratedValue(System.Int32,System.Single)">
            <summary>
            Calibrates the incoming value by the AxisCalibration at a particular index.
            </summary>
            <param name="axisIndex">Index of the Axis</param>
            <param name="value">Incoming value to calibrate</param>
            <returns>Calibrated value</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.SetAxisData(System.Int32,Rewired.AxisCalibrationData)">
            <summary>
            Sets calibration settings for an Axis at a particular index.
            </summary>
            <param name="index">Index of the Axis</param>
            <param name="data">Calibration data</param>
            <returns>Success / failure</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.GetAxisData(System.Int32)">
            <summary>
            Gets a struct containing the calibration data for an Axis at a particular index.
            </summary>
            <param name="index">Index of the Axis</param>
            <returns>AxisCalibrationData</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.ToXmlString">
            <summary>
            Exports the map to an XML string.
            </summary>
            <returns>XML string</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.ToJsonString">
            <summary>
            Exports the map to a JSON string.
            </summary>
            <returns>JSON string</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.ImportXmlString(System.String)">
            <summary>
            Imports data from an XML string.
            </summary>
            <param name="xmlString">XML string data</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="M:Rewired.CalibrationMap.ImportJsonString(System.String)">
            <summary>
            Imports data from a JSON string.
            </summary>
            <param name="jsonString">JSON string data</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="P:Rewired.CalibrationMap.Axes">
            <summary>
            Get a list of the AxisCalibration objects.
            </summary>
        </member>
        <member name="P:Rewired.CalibrationMap.axisCount">
            <summary>
            The number of axes in the map.
            </summary>
        </member>
        <member name="T:Rewired.AxisCalibration">
            <summary>
            Holds calibration information for a controller axis.
            </summary>
        </member>
        <member name="M:Rewired.AxisCalibration.GetCalibratedValue(System.Single)">
            <summary>
            Calibrates the incoming value.
            </summary>
            <param name="value">Axis value</param>
            <returns>Calibrated value</returns>
        </member>
        <member name="M:Rewired.AxisCalibration.GetCalibratedValue(System.Single,Rewired.AxisRange)">
            <summary>
            Calibrates the incoming value.
            </summary>
            <param name="value">Axis value</param>
            <param name="axisRange">Axis range</param>
            <returns>Calibrated value</returns>
        </member>
        <member name="M:Rewired.AxisCalibration.GetData">
            <summary>
            Gets a struct containing the calibration data.
            </summary>
            <returns>AxisCalibrationData</returns>
        </member>
        <member name="M:Rewired.AxisCalibration.SetData(Rewired.AxisCalibrationData)">
            <summary>
            Sets the calibration data.
            </summary>
            <param name="data">Calibration data</param>
        </member>
        <member name="M:Rewired.AxisCalibration.Reset">
            <summary>
            Resets all calibration setings to the hardware defaults.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.enabled">
            <summary>
            Enables or disables the Axis. A disabled Axis always returns a value of 0.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.deadZone">
            <summary>
            Gets or sets the dead zone. If the Axis's absolute value is less than or equal to the dead zone, it will return 0.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.calibratedZero">
            <summary>
            Gets or sets the zero value. This can be used to correct a non-zero resting state.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.calibratedMin">
            <summary>
            Gets or sets the minimum value. This can be used to transform the value to a new range.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.calibratedMax">
            <summary>
            Gets or sets the maximum value. This can be used to transform the value to a new range.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.invert">
            <summary>
            If true, the final value will be multiplied by -1. This can be used to correct an inverted Axis.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.sensitivityType">
            <summary>
            Determines how sensitivity will be calculated.
            If sensitivityType is set to Multiplier or Power, the sensitivity property is used to calculate the value.
            If sensitivityType is set to Curve, the sensitivityCurve property is used to calculate the value.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.sensitivity">
            <summary>
            Gets or sets the sensitivity value.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.sensitivityCurve">
            <summary>
            Gets or sets the sensitivity curve. The curve has no effect unless sensitivityType is set to Curve.
            Curve should have a time of 0 - 1 if using <see cref="F:Rewired.AxisSensitivity2DType.Radial"/>, -1 to +1 or 0 to 1 if using <see cref="F:Rewired.AxisSensitivity2DType.Axial"/>.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibration.applyRangeCalibration">
            <summary>
            If enabled, calibratedMin, calibratedMax, and calibratedZero will be used to convert the value to a new range.
            If disabled, calibratedMin, calibratedMax, and calibratedZero will have no effect on the final value.
            </summary>
        </member>
        <member name="T:Rewired.AxisCalibrationData">
            <summary>
            A struct for working with axis calibration data.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.enabled">
            <summary>
            Enables or disables the Axis. A disabled Axis always returns a value of 0.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.deadZone">
            <summary>
            If the Axis's absolute value is less than or equal to the dead zone, it will return 0.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.zero">
            <summary>
            The zero value. This can be used to correct a non-zero resting state.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.min">
            <summary>
            The minimum value. This can be used to transform the value to a new range.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.max">
            <summary>
            The maximum value. This can be used to transform the value to a new range.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.invert">
            <summary>
            If true, the final value will be multiplied by -1. This can be used to correct an inverted Axis.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.sensitivityType">
            <summary>
            Determines how sensitivity will be calculated.
            If sensitivityType is set to Multiplier or Power, the sensitivity property is used to calculate the value.
            If sensitivityType is set to Curve, the sensitivityCurve property is used to calculate the value.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.sensitivity">
            <summary>
            The sensitivity value.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.sensitivityCurve">
            <summary>
            The sensitivity curve. The curve has no effect unless sensitivityType is set to Curve.
            </summary>
        </member>
        <member name="F:Rewired.AxisCalibrationData.applyRangeCalibration">
            <summary>
            If enabled, min, max, and zero will be used to convert the value to a new range.
            If disabled, min, max, and zero will have no effect on the final value.
            </summary>
        </member>
        <member name="P:Rewired.AxisCalibrationData.Default">
            <summary>
            Creates a default AxisCalibrationData.
            </summary>
        </member>
        <member name="P:Rewired.Axis2DCalibration.deadZoneType">
            <summary>
            The calculation type for the dead zone.
            </summary>
        </member>
        <member name="P:Rewired.Axis2DCalibration.sensitivityType">
            <summary>
            Calculation type for sensitivity on 2D axes.
            </summary>
        </member>
        <member name="T:Rewired.ControllerElementIdentifier">
            <summary>
            Represents a single element on a controller. Used to identify physical elements on controllers by type and name.
            </summary>
        </member>
        <member name="M:Rewired.ControllerElementIdentifier.GetDisplayName(Rewired.ControllerElementType,Rewired.AxisRange)">
            <summary>
            Gets the display name for the specified element type and range.
            </summary>
            <param name="actualElementType">The element type of the actual Controller Element. This can differ from the element type of the Element Identifier.</param>
            <param name="axisRange">The range.</param>
            <returns>Returns the display name for the specified element type and range.</returns>
        </member>
        <member name="M:Rewired.ControllerElementIdentifier.GetDisplayName(Rewired.AxisRange)">
            <summary>
            Gets the display name for the specified range.
            </summary>
            <param name="axisRange">The range.</param>
            <returns>Returns the display name for the specified range.</returns>
        </member>
        <member name="T:Rewired.ControllerTemplateElementIdentifier">
            <summary>
            Represents a single element on a controller template. Used to identify physical elements on controller templates by type and name.
            </summary>
        </member>
        <member name="M:Rewired.ControllerTemplateElementIdentifier.GetDisplayName(Rewired.AxisRange)">
            <summary>
            Gets the display name for the specified axis range.
            </summary>
            <param name="axisRange">The range.</param>
            <returns>Returns the display name for the specified axis range.</returns>
        </member>
        <member name="T:Rewired.Data.ControllerTemplateElementIdentifier_Editor">
            <summary>
            Represents a single element on a controller template. Used to identify physical elements on controller templates by type and name.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapEnabler">
            <summary>
            Enforces persistent enabled states on Controller Maps in a Player based on user settings.
            This can be used to make specific Controller Maps be enabled or disabled in a Player,
            for example when changing game modes that require user input to change.
            These settings will persist and be inherited by new Controllers assigned to the Player.
            Enabled states will be sync'd when new Controllers are added, when Controller Maps are loaded, etc.
            When using <see cref="T:Rewired.ControllerMapEnabler"/>, you should not manually set enabled states
            on Controller Maps that are managed by this class, but instead change all settings within this class.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.Apply">
            <summary>
            Applies settings to Controller Maps in the Player.
            This must be called if you make changes to anything in <see cref="P:Rewired.ControllerMapEnabler.ruleSets"/> in
            order for those changes to be applied to the Player's Controller Maps.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.LoadDefaults">
            <summary>
            Loads the default settings from the Rewired Input Manager.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.ToXmlString">
            <summary>
            Exports data to XML.
            </summary>
            <returns>Exported data as an XML string.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.ToJsonString">
            <summary>
            Exports data to JSON.
            </summary>
            <returns>Exported data as a JSON string.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.ImportXml(System.String)">
            <summary>
            Imports data from XML.
            </summary>
            <param name="xmlString">The XML string</param>
            <returns>True if data was imported successfully, false on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.ImportJson(System.String)">
            <summary>
            Imports data from JSON.
            </summary>
            <param name="jsonString">The JSON string</param>
            <returns>True if data was imported successfully, false on failure.</returns>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.enabled">
            <summary>
            If enabled, Controller Maps enabled states will be sync'd when Controllers are assigned, new maps are loaded, etc.
            Changes to Controller Maps will be applied immediately in the Player when enabled.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.ruleSets">
            <summary>
            The list of rule sets.
            When <see cref="M:Rewired.ControllerMapEnabler.Apply"/> is called (whether manually or on various events which trigger it), each rule set in the list
            will be evaluated and enable or disable Controller Maps for the Controller(s) specified in the rule properties.
            After modifying or replacing the list, you must call <see cref="M:Rewired.ControllerMapEnabler.Apply"/> for the changes to take effect in the Player.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapEnabler.Rule">
            <summary>
            Settings for persisting the enabled state of Controller Maps.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.Rule.#ctor">
            <summary>
            Creates a new object instance.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.Rule.#ctor(Rewired.ControllerMapEnabler.Rule)">
            <summary>
            Creates a copy of an object instance.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.appliesToAllLayouts">
            <summary>
            Does this rule apply to Controller Maps in all Layouts or just a specific Layout id?
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.tag">
            <summary>
            A tag which can be used to find an rule in the list. This is optional.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.enable">
            <summary>
            The enabled state to be set on the Controller Maps.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.controllerSetSelector">
            <summary>
            Determines which Controller(s) this applies to.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.categoryIds">
            <summary>
            The Map Category ids of the Controller Maps the rule applies to.
            This is optional. If this value is set to null, this will apply to all Controller Maps
            regardless of the Map Category id.
            [Null = Match any Map Category id (wildcard)]
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.layoutIds">
            <summary>
            The Layout ids of the Controller Maps the rule applies to.
            This is optional. If this value is set to null, this will apply to all Controller Maps
            regardless of the Layout id.
            [Null = Match any Layout id (wildcard)]
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.categoryId">
            <summary>
            The first Map Category id of the Controller Maps the rule applies to.
            If you need to set more than one Map Category, use <see cref="P:Rewired.ControllerMapEnabler.Rule.categoryIds"/> instead.
            This is optional. If this value is not specified, this will apply to all Controller Maps
            regardless of the Map Category id.
            [-1 = Match any Map Category id (wildcard)]
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.layoutId">
            <summary>
            The first Layout id of the Controller Maps the rule applies to.
            If you need to set more than one Layout, use <see cref="P:Rewired.ControllerMapEnabler.Rule.layoutIds"/> instead.
            This is optional. If this value is not specified, this will apply to all Controller Maps
            regardless of the Layout id.
            [-1 = Match any Layout id (wildcard)]
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.categoryNames">
            <summary>
            The Map Category names of the Controller Maps the rule applies to.
            This is an alternate way of setting the Map Category id.
            This will automatically be set by the Map Category id and vice versa when changed.
            This is optional. If this value is set to null, this will apply to all Controller Maps
            regardless of the Map Category.
            [Null = Match any Map Category (wildcard)]
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.layoutNames">
            <summary>
            The Layout names of the Controller Maps the rule applies to.
            This is an alternate way of setting the Layout id.
            This will automatically be set by the Layout id and vice versa when changed.
            This is optional. If this value is set to null, this will apply to all Controller Maps
            regardless of the Layout.
            [Null = Match any Layout (wildcard)]
            IMPORTANT: <see cref="P:Rewired.ControllerMapEnabler.Rule.controllerSetSelector"/> must be set before this value is set because <see cref="P:Rewired.ControllerSetSelector.controllerType"/>
            is used to determine the Controller Type for looking up the Layout id. Alway create the <see cref="P:Rewired.ControllerMapEnabler.Rule.controllerSetSelector"/> before
            setting this value as a string array. The same limitation does not apply to <see cref="P:Rewired.ControllerMapEnabler.Rule.layoutIds"/>.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.categoryName">
            <summary>
            The first Map Category of the Controller Maps the rule applies to.
            This is an alternate way of setting the Map Category id.
            This will automatically be set by the Map Category id and vice versa when changed.
            This is optional. If this value is not specified, this will apply to all Controller Maps
            regardless of the Map Category.
            [Null = Match any Map Category (wildcard)]
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.Rule.layoutName">
            <summary>
            The first Layout of the Controller Maps the rule applies to.
            This is an alternate way of setting the Layout id.
            This will automatically be set by the Layout id and vice versa when changed.
            This is optional. If this value is not specified, this will apply to all Controller Maps
            regardless of the Layout.
            [Null = Match any Layout (wildcard)]
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            IMPORTANT: <see cref="P:Rewired.ControllerMapEnabler.Rule.controllerSetSelector"/> must be set before this value is set because <see cref="!:ControllerSelector.controllerType"/>
            is used to determine the Controller Type for looking up the Layout id. Alway create the <see cref="P:Rewired.ControllerMapEnabler.Rule.controllerSetSelector"/> before
            setting this value as a string. The same limitation does not apply to <see cref="P:Rewired.ControllerMapEnabler.Rule.layoutId"/>.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapEnabler.RuleSet">
            <summary>
            A set of Rules.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.RuleSet.Find(System.Predicate{Rewired.ControllerMapEnabler.Rule})">
            <summary>
            Finds the first Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The first Rule that satisfies the predicate. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.RuleSet.FindLast(System.Predicate{Rewired.ControllerMapEnabler.Rule})">
            <summary>
            Finds the last Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The last Rule that satisfies the predicate. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.RuleSet.FindIndex(System.Predicate{Rewired.ControllerMapEnabler.Rule})">
            <summary>
            Finds the index of the first Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The index of the first Rule that satisfies the predicate. Returns -1 if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapEnabler.RuleSet.FindLastIndex(System.Predicate{Rewired.ControllerMapEnabler.Rule})">
            <summary>
            Finds the index of the last Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The index of the last Rule that satisfies the predicate. Returns -1 if not found.</returns>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.RuleSet.enabled">
            <summary>
            If enabled, the rule set will be evaluated. Otherwise, it will be ignored.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.RuleSet.tag">
            <summary>
            The tag.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapEnabler.RuleSet.rules">
            <summary>
            The Rule list.
            </summary>
        </member>
        <member name="T:Rewired.Data.ControllerMapEnabler_RuleSet_Editor">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.ControllerMapEnabler_Rule_Editor">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Data.ControllerMapEnabler_Rule_Editor.#ctor">
            <summary>
            Creates a new object instance.
            </summary>
        </member>
        <member name="M:Rewired.Data.ControllerMapEnabler_Rule_Editor.#ctor(Rewired.Data.ControllerMapEnabler_Rule_Editor)">
            <summary>
            Creates a copy of an object instance.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapLayoutManager">
            <summary>
            Manages loading and unloading of Controller Maps in a Player based on user settings to force the specified Layouts to be used.
            This can be used to make specific Controller Maps be loaded in a Player with specific Layouts, for example when changing from one Controller
            Layout to another. These settings will persist and be inherited by new Controllers assigned to the Player.
            This will enforce a single Layout per managed Map Category be loaded in the Player. This cannot manage mutliple simultaneous
            Layouts in the same Map Category being loaded in the Player.
            This does not manage enabled states of the Controller Maps. It only manages loading and unloading of Controller Maps.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.Apply">
            <summary>
            Applies settings to Controller Maps in the Player.
            This must be called if you make changes to anything in <see cref="P:Rewired.ControllerMapLayoutManager.ruleSets"/> in
            order for those changes to be applied to the Player's Controller Maps.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.LoadDefaults">
            <summary>
            Loads the default settings from the Rewired Input Manager.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.ToXmlString">
            <summary>
            Exports data to XML.
            </summary>
            <returns>Exported data as an XML string.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.ToJsonString">
            <summary>
            Exports data to JSON.
            </summary>
            <returns>Exported data as a JSON string.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.ImportXml(System.String)">
            <summary>
            Imports data from XML.
            </summary>
            <param name="xmlString">The XML string</param>
            <returns>True if data was imported successfully, false on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.ImportJson(System.String)">
            <summary>
            Imports data from JSON.
            </summary>
            <param name="jsonString">The JSON string</param>
            <returns>True if data was imported successfully, false on failure.</returns>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.enabled">
            <summary>
            If enabled, loaded Controller Maps will be evaluated when Controllers are assigned, after saved data is loaded, etc.
            Changes to Controller Maps will be applied immediately in the Player when enabled.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.loadFromUserDataStore">
            <summary>
            If enabled, Controller Maps will be loaded from UserDataStore (if available) instead of from the Rewired Input Manager
            defaults. If no matching Controller Map is found in UserDataStore, the Rewired Input Manager default will be loaded.
            Note: The UserDataStore implementation must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> to be used.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.ruleSets">
            <summary>
            The list of rule sets.
            When <see cref="M:Rewired.ControllerMapLayoutManager.Apply"/> is called (whether manually or on various events which trigger it), each rule set in the list
            will be evaluated and Controller Maps for the Controller(s) specified in the rule properties will be loaded or removed.
            After modifying or replacing the list, you must call <see cref="M:Rewired.ControllerMapLayoutManager.Apply"/> for the changes to take effect in the Player.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapLayoutManager.Rule">
            <summary>
            Settings for persisting a Controller Map Layout.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.Rule.#ctor">
            <summary>
            Creates a new object instance.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.Rule.#ctor(Rewired.ControllerMapLayoutManager.Rule)">
            <summary>
            Creates a copy of an object instance.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.tag">
            <summary>
            A tag which can be used to find an rule in the list. This is optional.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.controllerSetSelector">
            <summary>
            Determines which Controller(s) this applies to.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.categoryId">
            <summary>
            The first Map Category id of the Controller Maps the rule applies to.
            If you need to set more than one Map Category, use <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryIds"/> instead.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryName"/>, <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryIds"/>, or <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryNames"/> instead.
            Set this to -1 to clear the categories.
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.categoryIds">
            <summary>
            The Map Category ids of the Controller Maps the rule applies to.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryNames"/> instead.
            Set this to null to clear the categories.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.layoutId">
            <summary>
            The Layout id of the Controller Maps the rule applies to.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.layoutName"/> instead.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.categoryName">
            <summary>
            The first Map Category of the Controller Maps the rule applies to.
            If you need to set more than one Map Category, use <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryNames"/> instead.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryId"/>, <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryNames"/>, or <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryIds"/> instead.
            Set this to null to clear the categories.
            Note: If you set this value while an array of categories has already been set, the array will be cleared and only this value will remain.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.categoryNames">
            <summary>
            The Map Category names of the Controller Maps the rule applies to.
            This is an alternate way of setting the Map Category id.
            This will automatically be set by the Map Category id and vice versa when changed.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.categoryIds"/> instead.
            Set this to null to clear the categories.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.Rule.layoutName">
            <summary>
            The Layout name of the Controller Maps the rule applies to.
            This is an alternate way of setting the Layout id.
            This will automatically be set by the Layout id and vice versa when changed.
            This is required, or you can set the value using <see cref="P:Rewired.ControllerMapLayoutManager.Rule.layoutId"/> instead.
            NOTE: <see cref="P:Rewired.ControllerMapLayoutManager.Rule.controllerSetSelector"/> must be set before this value is set because <see cref="P:Rewired.ControllerSetSelector.controllerType"/>
            is used to determine the Controller Type for looking up the Layout id. Alway create the <see cref="P:Rewired.ControllerMapLayoutManager.Rule.controllerSetSelector"/> before
            setting this value as a string. The same limitation does not apply to <see cref="P:Rewired.ControllerMapLayoutManager.Rule.layoutId"/>.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapLayoutManager.RuleSet">
            <summary>
            A set of Rules.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.RuleSet.Find(System.Predicate{Rewired.ControllerMapLayoutManager.Rule})">
            <summary>
            Finds the first Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The first Rule that satisfies the predicate. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.RuleSet.FindLast(System.Predicate{Rewired.ControllerMapLayoutManager.Rule})">
            <summary>
            Finds the last Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The last Rule that satisfies the predicate. Returns null if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.RuleSet.FindIndex(System.Predicate{Rewired.ControllerMapLayoutManager.Rule})">
            <summary>
            Finds the index of the first Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The index of the first Rule that satisfies the predicate. Returns -1 if not found.</returns>
        </member>
        <member name="M:Rewired.ControllerMapLayoutManager.RuleSet.FindLastIndex(System.Predicate{Rewired.ControllerMapLayoutManager.Rule})">
            <summary>
            Finds the index of the last Rule that satisfies the predicate.
            </summary>
            <param name="predicate">Predicate</param>
            <returns>The index of the last Rule that satisfies the predicate. Returns -1 if not found.</returns>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.RuleSet.enabled">
            <summary>
            If enabled, the rule set will be evaluated. Otherwise, it will be ignored.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.RuleSet.tag">
            <summary>
            The tag.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapLayoutManager.RuleSet.rules">
            <summary>
            The Rule list.
            </summary>
        </member>
        <member name="T:Rewired.Data.ControllerMapLayoutManager_RuleSet_Editor">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Data.ControllerMapLayoutManager_Rule_Editor">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Data.ControllerMapLayoutManager_Rule_Editor.#ctor">
            <summary>
            Creates a new object instance.
            </summary>
        </member>
        <member name="M:Rewired.Data.ControllerMapLayoutManager_Rule_Editor.#ctor(Rewired.Data.ControllerMapLayoutManager_Rule_Editor)">
            <summary>
            Creates a copy of an object instance.
            </summary>
        </member>
        <member name="T:Rewired.Data.ControllerSetSelector_Editor">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Data.ControllerSetSelector_Editor.#ctor(Rewired.ControllerSetSelector.Type)">
            <summary>
            Creates an instance of the class.
            </summary>
            <param name="type">The selector type</param>
        </member>
        <member name="M:Rewired.Data.ControllerSetSelector_Editor.#ctor">
            <summary>
            Creates an instance of the class.
            </summary>
        </member>
        <member name="M:Rewired.Data.ControllerSetSelector_Editor.#ctor(Rewired.Data.ControllerSetSelector_Editor)">
            <summary>
            Creates a copy of an instance.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapSaveData">
            <summary>
            Base class for controller map save data.
            </summary>
        </member>
        <member name="T:Rewired.KeyboardMapSaveData">
            <summary>
            Used to retrieve saveable keyboard map data.
            </summary>
        </member>
        <member name="T:Rewired.MouseMapSaveData">
            <summary>
            Used to retrieve saveable mouse map data.
            </summary>
        </member>
        <member name="T:Rewired.JoystickMapSaveData">
            <summary>
            Used to retrieve saveable joystick map data.
            </summary>
        </member>
        <member name="T:Rewired.CustomControllerMapSaveData">
            <summary>
            Used to retrieve saveable custom controller map data.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMap">
            <summary>
            The base class for all controller maps. Maps actions to specific controller elements.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsAction(System.String)">
            <summary>
            Does this controller map contain any ActionElementMaps that are bound to a particular Action?
            </summary>
            <param name="actionName">The name of the Action.</param>
            <returns>Boolean</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsAction(System.Int32)">
            <summary>
            Does this controller map contain any ActionElementMaps that are bound to a particular Action?
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsElementIdentifier(System.Int32)">
            <summary>
            Does this controller map contain any ActionElementMaps that are bound to a particular Element Identifier Id?
            </summary>
            <param name="elementIdentifierId">The id of the element identifier.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsKeyboardKey(UnityEngine.KeyCode,Rewired.ModifierKeyFlags)">
            <summary>
            Does this controller map contain any ActionElementMaps that are bound to a particular keyboard key?
            </summary>
            <param name="keyCode">The primary key code.</param>
            <param name="modifierKeys">The modifier key flags.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsElementMap(Rewired.ActionElementMap)">
            <summary>
            Does this controller map contain the ActionElementMap?
            </summary>
            <param name="elementMap">The ActionElementMap.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ContainsElementMap(System.Int32)">
            <summary>
            Does this controller map contain the ActionElementMap with the specific id?
            </summary>
            <param name="elementMapId">The id of the ActionElementMap.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceOrCreateElementMap(Rewired.ElementAssignment)">
            <summary>
            Replaces an existing ActionElementMap with a new assignment.
            ElementAssignment.elementMapId must be set to the ActionElementMap.id of the assignment to replace if replacing.
            If no ActionElementMap is found matching that id, a new ActionElementMap will be created instead.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceOrCreateElementMap(Rewired.ElementAssignment,Rewired.ActionElementMap@)">
            <summary>
            Replaces an existing ActionElementMap with a new assignment.
            ElementAssignment.elementMapId must be set to the ActionElementMap.id of the assignment to replace if replacing.
            If no ActionElementMap is found matching that id, a new ActionElementMap will be created instead.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(Rewired.ElementAssignment)">
            <summary>
            Creates an ActionElementMap in this controller map based on the data in elementAssignment.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(Rewired.ElementAssignment,Rewired.ActionElementMap@)">
            <summary>
            Creates an ActionElementMap in this controller map based on the data in elementAssignment.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ModifierKey)">
            <summary>
            Creates an ActionElementMap in this controller map for a keyboard key assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKey1">First modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey2">Second modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey3">Third modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ActionElementMap@)">
            <summary>
            Creates an ActionElementMap in this controller map for a keyboard key assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKey1">First modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey2">Second modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey3">Third modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKeyFlags)">
            <summary>
            Creates an ActionElementMap in this controller map for a keyboard key assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKeyFlags">Modifier key flags for the keyboard key. ModifierKeyFlags.None = no modifiers.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,Rewired.ActionElementMap@)">
            <summary>
            Creates an ActionElementMap in this controller map for a keyboard key assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKeyFlags">Modifier key flags for the keyboard key. ModifierKeyFlags.None = no modifiers.</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean)">
            <summary>
            Creates an ActionElementMap in this controller map for a controller button or axis assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.CreateElementMap(System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean,Rewired.ActionElementMap@)">
            <summary>
            Creates an ActionElementMap in this controller map for a controller button or axis assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(Rewired.ElementAssignment)">
            <summary>
            Replaces an existing ActionElementMap with a new assignment.
            ElementAssignment.elementMapId must be set to the ActionElementMap.id of the assignment to replace if replacing.
            If no matching ActionElementMap is found, it will return false.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(Rewired.ElementAssignment,Rewired.ActionElementMap@)">
            <summary>
            Replaces an existing ActionElementMap with a new assignment.
            ElementAssignment.elementMapId must be set to the ActionElementMap.id of the assignment to replace if replacing.
            If no matching ActionElementMap is found, it will return false.
            </summary>
            <param name="elementAssignment">ElementAssignment info</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ModifierKey)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new keyboard key assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKey1">First modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey2">Second modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey3">Third modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ModifierKey,Rewired.ActionElementMap@)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new keyboard key assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKey1">First modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey2">Second modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="modifierKey3">Third modifier key for the keyboard key. KeyCode.None = no modifier.</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKeyFlags)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new keyboard key assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKeyFlags">Modifier key flags for the keyboard key. ModifierKeyFlags.None = no modifiers.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,UnityEngine.KeyCode,Rewired.ModifierKeyFlags,Rewired.ActionElementMap@)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new keyboard key assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the key is pressed, does it return a positive or negative value?</param>
            <param name="keyCode">The keyboard key the Action will be bound to.</param>
            <param name="modifierKeyFlags">Modifier key flags for the keyboard key. ModifierKeyFlags.None = no modifiers.</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new button or axis assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean,Rewired.ActionElementMap@)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new button or axis assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DeleteElementMap(System.Int32)">
            <summary>
            Deletes the ActionElementMap from the controller map.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap to delete.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DeleteElementMapsWithAction(System.String)">
            <summary>
            Deletes all ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DeleteElementMapsWithAction(System.Int32)">
            <summary>
            Deletes all ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMap(System.Int32)">
            <summary>
            Gets the ActionElementMap that matches the id.
            </summary>
            <param name="elementMapId">Unique id of the ActionElementMap.</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMaps">
            <summary>
            Gets all ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="P:Rewired.ControllerMap.AllMaps"/> instead.
            </summary>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMaps(System.Boolean)">
            <summary>
            Gets all ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetElementMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMaps(System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map.
            </summary>
            <param name="results">List which will be populated with matching results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String)">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32)">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String,System.Boolean)">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithAction(System.String)">
            <summary>
            Enumarates all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithAction(System.Int32)">
            <summary>
            Enumarates all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithAction(System.Int32)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithAction(System.String)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithAction(System.String,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstElementMapMatch(System.Predicate{Rewired.ActionElementMap})">
            <summary>
            Finds the first Action Element Map of any kind that matches the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <returns>Action Element Map</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMapMatches(System.Predicate{Rewired.ActionElementMap},System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Finds all Action Element Maps of any kind that match the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="results">The list to be filled with results.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">results is null.</exception>
            <returns>Number of matches.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementMapMatch(System.Predicate{Rewired.ActionElementMap},System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the action on each Action Element Map of any type that matches the conditions defined by specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ClearElementMaps">
            <summary>
            Deletes all ActionElementMaps in this controller map.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMap.SetAllElementMapsEnabled(System.Boolean)">
            <summary>
            Sets the enabled state on all Action Element Maps.
            </summary>
            <param name="state">The enabled state.</param>
            <returns>Number of maps that changed state</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMap(System.Int32)">
            <summary>
            Gets the Button ActionElementMap at a specific index..
            </summary>
            <param name="index">Index</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMaps">
            <summary>
            Gets all Button ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="P:Rewired.ControllerMap.ButtonMaps"/> instead.
            </summary>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMaps(System.Boolean)">
            <summary>
            Gets all Button ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetButtonMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Button ActionElementMaps in this controller map.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String)">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32)">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String,System.Boolean)">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ButtonMapsWithAction(System.Int32)">
            <summary>
            Enumarates all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ButtonMapsWithAction(System.String)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ButtonMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumarates all Button ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ButtonMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstButtonMapWithAction(System.Int32)">
            <summary>
            Gets the first Button ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstButtonMapWithAction(System.String)">
            <summary>
            Gets the first Button ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstButtonMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets the first Button ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstButtonMapWithAction(System.String,System.Boolean)">
            <summary>
            Gets the first Button ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetFirstButtonMapMatch(System.Predicate{Rewired.ActionElementMap})">
            <summary>
            Finds the first Button Map that matches the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <returns>Action Element Map</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonMapMatches(System.Predicate{Rewired.ActionElementMap},System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Finds all Button Maps that match the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="results">The list to be filled with results.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">results is null.</exception>
            <returns>Number of matches.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachButtonMapMatch(System.Predicate{Rewired.ActionElementMap},System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the action on each Button Map that matches the conditions defined by specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.DeleteButtonMapsWithAction(System.String)">
            <summary>
            Deletes all Button ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DeleteButtonMapsWithAction(System.Int32)">
            <summary>
            Deletes all Button ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.SetAllButtonMapsEnabled(System.Boolean)">
            <summary>
            Sets the enabled state on all Button Maps.
            </summary>
            <param name="state">The enabled state.</param>
            <returns>Number of maps that changed state</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ControllerMap)">
            <summary>
            Determines if any element assignments conflict between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ActionElementMap)">
            <summary>
            Determines if any element assignments conflict between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Determines if any element assignments conflict between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ControllerMap)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ActionElementMap)">
            <summary>
            Enumerates all assignment conflicts between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ControllerMap)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ActionElementMap)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ControllerMap)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ActionElementMap)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ControllerMap,System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ActionElementMap,System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ControllerMap,System.Action{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ActionElementMap,System.Action{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.ForEachElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Action{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Invokes the specified action on all ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Number of conflicting ActionElementMaps.</returns>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMap.GetButtonNames">
            <summary>
            Gets the element identifier names in all button maps.
            Warning: Calling this allocates memory.
            </summary>
            <returns>Array of names</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToXmlString">
            <summary>
            Exports the map to an XML string.
            </summary>
            <returns>XML string</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToJsonString">
            <summary>
            Exports the map to a JSON string.
            </summary>
            <returns>JSON string</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToControllerTemplateMap(System.Guid)">
            <summary>
            Converts the Controller Map to a Controller Template Map.
            </summary>
            <param name="templateTypeGuid">Controller Template type GUID. The Controller that owns this Controller Map must implement this Controller Template type.</param>
            <returns>Returns the Controller Template Map. Returns null on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToControllerTemplateMap``1">
            <summary>
            Converts the Controller Map to a Controller Template Map.
            </summary>
            <typeparam name="T">The Controller Template interface type. The Controller that owns this Controller Map must implement this Controller Template type.</typeparam>
            <returns>Returns the Controller Template Map. Returns null on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToControllerTemplateMap(System.Type)">
            <summary>
            Converts the Controller Map to a Controller Template Map.
            </summary>
            <param name="templateInterfaceType">The Controller Template interface type. The Controller that owns this Controller Map must implement this Controller Template type.</param>
            <returns>Returns the Controller Template Map. Returns null on failure.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.ToControllerTemplateMap(Rewired.IControllerTemplate)">
            <summary>
            Converts the Controller Map to a Controller Template Map.
            </summary>
            <param name="controllerTemplate">The Controller Template for which to create the map.</param>
            <returns>Returns the Controller Template Map.</returns>
        </member>
        <member name="M:Rewired.ControllerMap.GetElementMaps_Append(System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Gets all ActionElementMaps in this controller map and appends them to the end of the list.
            </summary>
            <param name="results">List which will be populated with matching results.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="P:Rewired.ControllerMap.id">
            <summary>
            The unique id of this controller map. This value is not consistent between game sessions, so do not store it.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.sourceMapId">
            <summary>
            The id of the original source ControllerMap from the Rewired Input Manager. This is only valid for maps loaded from the Rewired Input Manager on start, not maps loaded via XML or created at runtime.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.categoryId">
            <summary>
            The id of the Map Category of this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.layoutId">
            <summary>
            The id of the Layout of this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.name">
            <summary>
            The name of this controller map. (This is currently unused and will always be blank.)
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.hardwareGuid">
            <summary>
            The GUID of the controller definition this map is for. This GUID corresponds to the Rewired HardwareJoystickMap controller definition and can be used to identify recognized controller types.
            This will always be Guid.Empty for Unknown Controllers.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.enabled">
            <summary>
            Is the controller map enabled? Disabled maps will never return input values for the ActionElementMaps contained within.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.playerId">
            <summary>
            The id of the Player that owns this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.controllerId">
            <summary>
            The id of the controller this controller map applies to.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.controller">
            <summary>
            The controller this controller map applies to.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.controllerType">
            <summary>
            The type of controller this controller map applies to.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.player">
            <summary>
            The parent Player that owns this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.elementMapCount">
            <summary>
            The count of all ActionElementMaps contained in this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.buttonMapCount">
            <summary>
            The count of all Button ActionElementMaps contained in this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.AllMaps">
            <summary>
            Gets all ActionElementMaps in this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMap.ButtonMaps">
            <summary>
            Gets all Button ActionElementMaps in this controller map.
            </summary>
        </member>
        <member name="T:Rewired.ControllerMapWithAxes">
            <summary>
            Maps actions to controller elements for a controller with axes.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ContainsAction(System.Int32)">
            <summary>
            Does this controller map contain any ActionElementMaps that are bound to a particular Action?
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>Boolean</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.CreateElementMap(System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean,Rewired.ActionElementMap@)">
            <summary>
            Creates an ActionElementMap in this controller map for a controller button or axis assignment.
            </summary>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ReplaceElementMap(System.Int32,System.Int32,Rewired.Pole,System.Int32,Rewired.ControllerElementType,Rewired.AxisRange,System.Boolean,Rewired.ActionElementMap@)">
            <summary>
            Replaces an ActionElementMap in this controller map with a new button or axis assignment.
            If the ActionElementMap is not found in this controller map, a new ActionElementMap will not be created.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap being replaced.</param>
            <param name="actionId">The id of the Action to bind to.</param>
            <param name="axisContribution">When the button or split-axis is activated, does it return a positive or negative value?</param>
            <param name="elementIdentifierId">The id of the controller element identifier the Action will be bound to.</param>
            <param name="elementType">The type of controller element the Action will be bound to.</param>
            <param name="axisRange">The portion of the axis the Action will be bound to. (Only used if elementType is Axis.)</param>
            <param name="invert">Is the axis inverted? (Only used if elementType is Axis and axisRange is Full.)</param>
            <param name="result">The resulting ActionElementMap.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DeleteElementMap(System.Int32)">
            <summary>
            Deletes the ActionElementMap from the controller map.
            </summary>
            <param name="elementMapId">The unique id of the ActionElementMap to delete.</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DeleteElementMapsWithAction(System.String)">
            <summary>
            Deletes all ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DeleteElementMapsWithAction(System.Int32)">
            <summary>
            Deletes all ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetElementMap(System.Int32)">
            <summary>
            Gets the ActionElementMap that matches the id.
            </summary>
            <param name="elementMapId">Unique id of the ActionElementMap.</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstElementMapWithAction(System.Int32)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstElementMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstElementMapMatch(System.Predicate{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Finds the first Action Element Map of any kind that matches the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <returns>Action Element Map</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ClearElementMaps">
            <summary>
            Deletes all ActionElementMaps in this controller map.
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMap(System.Int32)">
            <summary>
            Gets the Axis ActionElementMap at a specific index..
            </summary>
            <param name="index">Index</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMaps">
            <summary>
            Gets all Axis ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="P:Rewired.ControllerMapWithAxes.AxisMaps"/> instead.
            </summary>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMaps(System.Boolean)">
            <summary>
            Gets all Axis ActionElementMaps in this controller map.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMapWithAxes.GetAxisMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMaps(System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Axis ActionElementMaps in this controller map.
            </summary>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String)">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32)">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String,System.Boolean)">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            Warning: Calling this allocates memory.
            Use <see cref="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})"/> instead.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>Array of ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">List which will be populated with matching results.</param>
            <returns>Number of maps found.</returns>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.AxisMapsWithAction(System.String)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.AxisMapsWithAction(System.Int32)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.AxisMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.AxisMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumarates all Axis ActionElementMaps in this controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstAxisMapWithAction(System.Int32)">
            <summary>
            Gets the first Axis ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstAxisMapWithAction(System.String)">
            <summary>
            Gets the first Axis ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstAxisMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Gets the first Axis ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstAxisMapWithAction(System.String,System.Boolean)">
            <summary>
            Gets the first Axis ActionElementMap found in this controller that contains a specific Action.
            </summary>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetFirstAxisMapMatch(System.Predicate{Rewired.ActionElementMap})">
            <summary>
            Finds the first Axis Map that matches the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <returns>Action Element Map</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisMapMatches(System.Predicate{Rewired.ActionElementMap},System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Finds all Axis Maps that match the conditions defined by the specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="results">The list to be filled with results.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">results is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ForEachAxisMapMatch(System.Predicate{Rewired.ActionElementMap},System.Action{Rewired.ActionElementMap})">
            <summary>
            Invokes the action on each Axis Map that matches the conditions defined by specified predicate.
            </summary>
            <param name="predicate">The Predicate delegate that defines the conditions to match.</param>
            <param name="actionToPerform">The action to invoke on each entry.</param>
            <exception cref="T:System.ArgumentNullException">predicate is null.</exception>
            <exception cref="T:System.ArgumentNullException">actionToPerform is null.</exception>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DeleteAxisMapsWithAction(System.String)">
            <summary>
            Deletes all Axis ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionName">The name of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DeleteAxisMapsWithAction(System.Int32)">
            <summary>
            Deletes all Axis ActionElementMap from the controller map that contain a specific Action.
            </summary>
            <param name="actionId">The id of the Action.</param>
            <returns>True/False if any ActionElementMaps were deleted.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.SetAllAxisMapsEnabled(System.Boolean)">
            <summary>
            Sets the enabled state on all Axis Maps.
            </summary>
            <param name="state">The enabled state.</param>
            <returns>Number of maps that changed state</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DoesElementAssignmentConflict(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DoesElementAssignmentConflict(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Determines if any element assignments conflict between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between the this controller map and the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Enumerates all assignment conflicts between this controller map and the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.RemoveElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.RemoveElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Deletes any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of conflicting ActionElementMaps removed.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DisableElementAssignmentConflicts(Rewired.ControllerMap,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming controller map.
            </summary>
            <param name="controllerMap">ControllerMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DisableElementAssignmentConflicts(Rewired.ActionElementMap,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the incoming ActionElementMap.
            </summary>
            <param name="actionElementMap">ActionElementMap</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Disables any ActionElementMaps in this controller map that conflict with the potential assignment contained in the ElementAssignmentConflictCheck.
            </summary>
            <param name="conflictCheck">ElementAssignmentConflictCheck</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="disabledActionElementMaps">List which will be populated with the disabled ActionElementMaps.</param>
            <param name="appendList">If true, the disabledActionElementMaps list will be appended with the new results. If false, the list will be cleared first.</param>
            <returns>Number of conflicting ActionElementMaps disabled.</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetAxisNames">
            <summary>
            Gets the element identifier names in all axis maps.
            Warning: Calling this allocates memory.
            </summary>
            <returns>Array of names</returns>
        </member>
        <member name="M:Rewired.ControllerMapWithAxes.GetElementMaps_Append(System.Collections.Generic.List{Rewired.ActionElementMap},System.Boolean)">
            <summary>
            Gets all ActionElementMaps in this controller map and appends them to the end of the list.
            </summary>
            <param name="results">List which will be populated with matching results.</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="P:Rewired.ControllerMapWithAxes.axisMapCount">
            <summary>
            The count of all Axis ActionElementMaps contained in this controller map.
            </summary>
        </member>
        <member name="P:Rewired.ControllerMapWithAxes.AxisMaps">
            <summary>
            Gets all Axis ActionElementMaps in this controller map.
            </summary>
        </member>
        <member name="T:Rewired.KeyboardMap">
            <summary>
            Maps actions to controller elements for a keyboard.
            </summary>
        </member>
        <member name="T:Rewired.MouseMap">
            <summary>
            Maps actions to controller elements for a mouse.
            </summary>
        </member>
        <member name="T:Rewired.JoystickMap">
            <summary>
            Maps actions to controller elements for a joystick.
            </summary>
        </member>
        <member name="T:Rewired.CustomControllerMap">
            <summary>
            Maps actions to controller elements for a custom controller.
            </summary>
        </member>
        <member name="M:Rewired.IControllerMapSet.GetMaps">
            <summary>
            GC!
            </summary>
        </member>
        <member name="M:Rewired.IControllerMapSet.GetMapsByCategory(System.Int32)">
            <summary>
            GC!
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapSet`1.Rewired#IControllerMapSet#GetMaps``1">
            <summary>
            Used for getting the type-specific list from the interface.
            DO NOT USE ControllerMap or ControllerMapWithAxes!
            </summary>
        </member>
        <member name="M:Rewired.ControllerMapSet`1.Rewired#IControllerMapSet#GetMapsByCategory``1(System.Int32,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            DO NOT USE ControllerMap or ControllerMapWithAxes!
            </summary>
        </member>
        <member name="M:Rewired.HardwareControllerMap_Game.#ctor(System.String,System.Int32,Rewired.ControllerElementIdentifier[],System.Int32[],System.Int32[],Rewired.AxisCalibrationData[],Rewired.AxisRange[],Rewired.Data.Mapping.HardwareAxisInfo[],Rewired.Data.Mapping.HardwareButtonInfo[],Rewired.Data.Mapping.HardwareJoystickMap.CompoundElement[])">
            <summary>
            Overload for Custom Controllers.
            </summary>
        </member>
        <member name="M:Rewired.HardwareControllerMap_Game.#ctor(System.String,Rewired.HardwareControllerMapIdentifier,Rewired.JoystickType[],Rewired.ControllerElementIdentifier[],System.Int32[],System.Int32[],Rewired.AxisCalibrationData[],Rewired.AxisRange[],Rewired.Data.Mapping.HardwareAxisInfo[],Rewired.Data.Mapping.HardwareButtonInfo[],Rewired.Data.Mapping.HardwareJoystickMap.CompoundElement[])">
            <summary>
            Overload for Joysticks.
            </summary>
        </member>
        <member name="M:Rewired.HardwareControllerMap_Game.#ctor(System.String,Rewired.HardwareControllerMapIdentifier,Rewired.ControllerElementIdentifier[],System.Int32[],System.Int32[],Rewired.AxisCalibrationData[],Rewired.AxisRange[],Rewired.Data.Mapping.HardwareAxisInfo[],Rewired.Data.Mapping.HardwareButtonInfo[],Rewired.Data.Mapping.HardwareJoystickMap.CompoundElement[])">
            <summary>
            Overload for keyboard/mouse.
            </summary>
        </member>
        <member name="T:Rewired.InputAction">
            <summary>
            Represents a single action.
            </summary>
        </member>
        <member name="M:Rewired.InputAction.#ctor">
            <summary>
            Creates an instance.
            </summary>
        </member>
        <member name="M:Rewired.InputAction.#ctor(Rewired.InputAction)">
            <summary>
            Makes a copy of an InputAction.
            </summary>
            <param name="source">The source InputAction</param>
        </member>
        <member name="M:Rewired.InputAction.Clone">
            <summary>
            Makes a copy of an InputAction.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.id">
            <summary>
            The id.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.name">
            <summary>
            The scripting name.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.type">
            <summary>
            The InputActionType.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.descriptiveName">
            <summary>
            The descripive name. This can be shown to users.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.positiveDescriptiveName">
            <summary>
            The positive descriptive name. This can be shown to users.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.negativeDescriptiveName">
            <summary>
            The negative descriptive name. This can be shown to users.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.behaviorId">
            <summary>
            The Input Behavior Id assigned to this Action.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.categoryId">
            <summary>
            The Action Category Id this Action belongs to.
            </summary>
        </member>
        <member name="P:Rewired.InputAction.userAssignable">
            <summary>
            Determines whether the Action will appear in certain lists such as in a control remapping UI.
            Note: This value is not used in the conflict checking system and has no impact on whether an Action is protected from reassignment.
            </summary>
        </member>
        <member name="T:Rewired.InputBehavior">
            <summary>
            Provides configuration options for an InputAction.
            </summary>
        </member>
        <member name="M:Rewired.InputBehavior.ToXmlString">
            <summary>
            Exports the map to an XML string.
            </summary>
            <returns>XML string</returns>
        </member>
        <member name="M:Rewired.InputBehavior.ImportXmlString(System.String)">
            <summary>
            Exports the map to a JSON string.
            </summary>
            <param name="xmlString">XML string data</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="M:Rewired.InputBehavior.ToJsonString">
            <summary>
            Exports data to JSON string for saving.
            </summary>
            <returns>JSON string</returns>
        </member>
        <member name="M:Rewired.InputBehavior.ImportJsonString(System.String)">
            <summary>
            Imports data from a JSON string.
            </summary>
            <param name="jsonString">JSON string data</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="M:Rewired.InputBehavior.ImportData(Rewired.InputBehavior)">
            <summary>
            Imports data from an InputBehavior.
            Note: Does not copy id.
            </summary>
            <param name="inputBehavior">An InputBehavior</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="M:Rewired.InputBehavior.Clone">
            <summary>
            Copies this object.
            </summary>
            <returns>Copy of InputBehavior</returns>
        </member>
        <member name="M:Rewired.InputBehavior.Reset">
            <summary>
            Restores all settings to originals from the Rewired Input Manager.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.id">
            <summary>
            The id of this Input Behavior.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.name">
            <summary>
            The name of this Input Behavior.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.joystickAxisSensitivity">
            <summary>
            All joystick axes are multiplied by this value.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.digitalAxisSimulation">
            <summary>
            Enables digital axis simulation which makes button or key presses contribute to an Action's axis value gradually over time based on gravity and sensitivity.
            This only affects axis values generated by button and key presses.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.digitalAxisSnap">
            <summary>
            When input is received in the opposite direction of the current flow, snap axis value to 0 and continue from there.
            This only affects axis values generated by button and key presses.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.digitalAxisInstantReverse">
            <summary>
            When input is received in the opposite direction of the current flow, reverse the current value to the opposite sign and continue from there.
            This only affects axis values generated by button and key presses.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.digitalAxisGravity">
            <summary>
            Speed (units/sec) that the axis value falls toward 0. This only affects axis values generated by button and key presses.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.digitalAxisSensitivity">
            <summary>
            Speed to move toward an axis value of 1.0 in units/sec. This only affects axis values generated by button and key presses.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.mouseXYAxisMode">
            <summary>
            Affects how mouse X/Y axes contribute to the value.
            Mouse Axis - Value range that depends on speed of movement. The value can and does exceed +/- 1.0 by a large amount. This value is the same value returned by Unity's Input.GetAxis when axis type is set to Mouse Movement. Mouse Sensitivity is multiplied by the axis value.
            Digital Axis - Any mouse movement returns a value from -1.0 to 1.0 and is smoothed by the digital axis filters. This makes mouse movement behave like a button or key press.
            ScreenPositionDelta - A value from -1.0 to 1.0 that represents the distance moved across the screen over the update cycle. The value is normalized based on the width and height of the screen. A movement across the entire screen distance in one update cycle will return +/- 1.0.
            Speed - A value based on the speed the mouse is moved across the screen. Speed is calculated from the mouse movement delta / delta time. The returned value can exceed +/- 1.0.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.mouseOtherAxisMode">
            <summary>
            Affects how mouse axes other than X/Y contribute to the value. This affects the mouse wheel axis.
            Mouse Axis - Value range goes beyond -1 to 1 depending on speed of movement. This value is the same value returned by Unity's Input.GetAxis when axis type is set to Mouse Movement. Mouse Other Axis Sensitivity is multiplied by the axis value.
            Digital Axis - Any movement returns -1 to 1 and is smoothed by digital axes values. Mouse movement behaves like a button or keyboard key press. Mouse sensitivity does not affect this mode. Instead, all Digital Axis filters are applied.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.mouseXYAxisSensitivity">
            <summary>
            Mouse X/Y axes are multiplied by this value.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.mouseXYAxisDeltaCalc">
            <summary>
            Determines how the screen position delta (and therefore speed) is calculated for mouse X/Y axes.
            An equvalent mouse movement on X and Y will yield a different result for delta X and delta Y if the screen width and height are not equal.
            If you need the delta consistent between X and Y movement, change this to ScreenWidth or ScreenHeight and the delta will be calculated based on only one dimension.
            Note that the returned value may exceed +/- 1.0 if set to a value other than Normal.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.mouseOtherAxisSensitivity">
            <summary>
            All mouse axes except X/Y are multiplied by this value.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.customControllerAxisSensitivity">
            <summary>
            All Custom Controller axes are multiplied by this value.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonDoublePressSpeed">
            <summary>
            Time in seconds in which to register a button double-press or double-click.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonShortPressTime">
            <summary>
            Time in seconds that a button or axis must be held to register a short press.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonShortPressExpiresIn">
            <summary>
            Time in seconds after a short press is registered after which it will expire and no longer return true for any button events.
            For example: If you want the press to expire 2 seconds after the press first registers true, set this value to 2.
            This is useful, for example, if you want short and long presses to be mutually exclusive.
            [0 = Never expires]
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonLongPressTime">
            <summary>
            Time in seconds that a button or axis must be held to register a long press.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonLongPressExpiresIn">
            <summary>
            Time in seconds after a long press is registered after which it will expire and no longer return true for any button events.
            For example: If you want the press to expire 2 seconds after the press first registers true, set this value to 2.
            [0 = Never expires]
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonDeadZone">
            <summary>
            When an Action's axis value is below this threshold, GetButton will return false. This is useful if you map axes as buttons. If the value is too low, GetButton may always return true. If the value is 1, it will never return true.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonDownBuffer">
            <summary>
            Time in seconds to buffer GetButtonDown results. This makes GetButtonDown return TRUE for extra time beyond a single frame.
            This is useful to prevent missing button presses when pressing very rapidly and the game ignores these presses due to some blocking action. Ex: Punching in rapid succession, but presses are ignored during the punch animation.
            The buffer value should generally be very small such as 0.08 s, but this will depend on your specific needs.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonRepeatRate">
            <summary>
            The number of times per second the button state will be True when queried with GetButtonRepeating or the equivalent event.
            </summary>
        </member>
        <member name="P:Rewired.InputBehavior.buttonRepeatDelay">
            <summary>
            The duration in seconds before repeating will begin after the initial press when queried with GetButtonRepeating or the equivalent event. [0 = No delay]
            </summary>
        </member>
        <member name="T:Rewired.InputCategory">
            <summary>
            A category for organizing input-related data.
            </summary>
        </member>
        <member name="T:Rewired.InputMapCategory">
            <summary>
            A category for organizing controller maps.
            </summary>
        </member>
        <member name="P:Rewired.InputMapCategory.checkConflictsCategoryIds_orig">
            <summary>
            Used by RIM data exporter.
            </summary>
        </member>
        <member name="T:Rewired.InputLayout">
            <summary>
            A layout for organizing input maps.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper">
            <summary>
            A class that simplifies the process of remapping controls.
            Handles listening for controller input, conflict checking, and creating Action-element assignments.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.#ctor">
            <summary>
            Creates a new InputMapper.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.RemoveEventListeners(System.Object)">
            <summary>
            Removes the event listener(s) from all events.
            You can pass the object that contains the target delegates
            to unsubscribe all delegates in that object from all events.
            For example, if your class MyClass subscribes to several events,
            you can pass the MyClass object into this method to remove all of
            its listeners. Example: mapper.RemoveEventListeners(this);
            </summary>
            <param name="listenerOrParent">The event listener to remove from all events. This can be either the containing class object or the delegate.</param>
        </member>
        <member name="M:Rewired.InputMapper.RemoveAllEventListeners">
            <summary>
            Removes all event listeners from all events.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.RemoveCallbacks(System.Object)">
            <summary>
            Removes the delegate(s) from all callbacks.
            You can pass the object that contains the target delegates
            to remove all delegates in that object from all callbacks.
            For example, if your class MyClass supplies several delegates for callbacks,
            you can pass the MyClass object into this method to remove all of
            its delegates. Example: mapper.RemoveCallbacksListeners(this);
            </summary>
            <param name="callbackOrParent">The delegate to remove from all callbacks. This can be either the containing class object or the delegate.</param>
        </member>
        <member name="M:Rewired.InputMapper.RemoveAllCallbacks">
            <summary>
            Removes all callbacks from all events.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Start(Rewired.InputMapper.Context)">
            <summary>
            Starts listening for input.
            </summary>
            <param name="mappingContext">The mapping context.</param>
            <returns>Success/Fail</returns>
        </member>
        <member name="M:Rewired.InputMapper.Stop">
            <summary>
            Stops listening for input.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Clear">
            <summary>
            Stops the mapper and clears all event listeners, callbacks, and Options.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.options">
            <summary>
            Gets the Options object. Configure settings here.
            If set to null, the default Options will be used instead.
            Changing this or any values in Options while the mapper is
            listening will have no effect until the mapper is started again.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.mappingContext">
            <summary>
            Gets the mapping Context object. This allows you to see the current mapping
            context being used while the mapper is listening. You cannot change any settings
            in the mapping context. To change mapping contexts, restart input mapper with a
            new context. If the mapper is idle, this value will be null.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.status">
            <summary>
            The current status of the mapper.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.timeRemaining">
            <summary>
            The time remaining before the mapper times out. Always returns 0 if no timeout was set or if the timer was stopped.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.id">
            <summary>
            The unique id of this mapper.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.InputMappedEvent">
            <summary>
            Event that is triggered when an input assignment is made.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.ErrorEvent">
            <summary>
            Event that is triggered an error occurs.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.CanceledEvent">
            <summary>
            Event that is triggered when listening is canceled.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.TimedOutEvent">
            <summary>
            Event that is triggered when listening times out.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.StartedEvent">
            <summary>
            Event that is triggered when listening is started.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.StoppedEvent">
            <summary>
            Event that is triggered when listening stops.
            </summary>
        </member>
        <member name="E:Rewired.InputMapper.ConflictFoundEvent">
            <summary>
            Event that is triggered when an assignment conflict is found.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.Context">
            <summary>
            Provides information about an input mapping.
            This is used to define what is being mapped and how user input should be handled.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Context.#ctor">
            <summary>
            Creates a new Context.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Context.Clone">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <returns>A shallow copy of this object.</returns>
        </member>
        <member name="M:Rewired.InputMapper.Context.MakeReadOnly">
            <summary>
            Prevents context from being changed.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Context.Copy(Rewired.InputMapper.Context,Rewired.InputMapper.Context)">
            <summary>
            Copies data from one Context into another Context.
            </summary>
            <param name="source">The Context which will provide the data.</param>
            <param name="destination">The Context which will receive the data.</param>
            <exception cref="T:System.ArgumentNullException">source is null.</exception>
            <exception cref="T:System.ArgumentNullException">destination is null.</exception>
        </member>
        <member name="P:Rewired.InputMapper.Context.actionId">
            <summary>
            The id of the Action to be mapped.
            This is a required field.
            This can also be set using the actionName field instead.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Context.actionName">
            <summary>
            The name of the Action to be mapped.
            This is just a convenience property to allow you to set the actionId property
            by using the string name instead of the id. Setting this property
            will set the actionId property with the corresponding id.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Context.controllerMap">
            <summary>
            The Controller Map that will be populated with the new mapping.
            This is a required field.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Context.actionElementMapToReplace">
            <summary>
            The ActionElementMap to be replaced. This ActionElementMap must exist in the Controller Map being passed in or you will get an error.
            Leave null if you are not replacing an existing mapping.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Context.actionRange">
            <summary>
            The range of the Action's value to map input to. For example, for an axis-type Action, should
            user input be mapped to the full range of the Action or just one side of the Action (+/-)?
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.ConflictResponse">
            <summary>
            Actions to take when a conflict is found.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictResponse.Cancel">
            <summary>
            The assignment will be canceled.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictResponse.Replace">
            <summary>
            The conflicting mappings will be cleared and the new assignment added.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictResponse.Add">
            <summary>
            The conflicting mappings will be left as-is and the new assignment will be added.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictResponse.Ignore">
            <summary>
            The conflict will be ignored and polling will continue.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.EventData">
            <summary>
            Base class for event data.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.EventData.inputMapper">
            <summary>
            The InputMapper that sent this event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.InputMappedEventData">
            <summary>
            Data for an input mapped event.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.InputMappedEventData.actionElementMap">
            <summary>
            The Action Element Map that was created or replaced.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.CanceledEventData">
            <summary>
            Data for a canceled event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.ErrorEventData">
            <summary>
            Data for an error event.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ErrorEventData.message">
            <summary>
            The error message.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.TimedOutEventData">
            <summary>
            Data for a timed out event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.StartedEventData">
            <summary>
            Data for a started event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.StoppedEventData">
            <summary>
            Data for a stopped event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.ConflictFoundEventData">
            <summary>
            Data for a conflict event.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictFoundEventData.responseCallback">
            <summary>
            Invoke this callback to send a response to the Input Mapper.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictFoundEventData.assignment">
            <summary>
            The pending input assignment.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictFoundEventData.conflicts">
            <summary>
            A list of assignment conflicts found.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.ConflictFoundEventData.isProtected">
            <summary>
            Is one or more of the conflicting maps protected from removal?
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.Status">
            <summary>
            The status of the mapper.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.Status.Idle">
            <summary>
            Mapper is idle.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.Status.Listening">
            <summary>
            Mapper is listening for input.
            </summary>
        </member>
        <member name="F:Rewired.InputMapper.Status.AwaitingResponse">
            <summary>
            Mapper is waiting for a response to an event.
            </summary>
        </member>
        <member name="T:Rewired.InputMapper.Options">
            <summary>
            Configuration options for the InputMapper.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Options.#ctor">
            <summary>
            Creates a new Options with default values.
            </summary>
        </member>
        <member name="M:Rewired.InputMapper.Options.Clone">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <returns>A shallow copy of this object.</returns>
        </member>
        <member name="M:Rewired.InputMapper.Options.Copy(Rewired.InputMapper.Options,Rewired.InputMapper.Options)">
            <summary>
            Copies data from one Options to another.
            </summary>
            <param name="source">The Options which will provide the data.</param>
            <param name="destination">The Options which will receive the data.</param>
            <exception cref="T:System.ArgumentNullException">source is null.</exception>
            <exception cref="T:System.ArgumentNullException">destination is null.</exception>
        </member>
        <member name="P:Rewired.InputMapper.Options.allowAxes">
            <summary>
            Should axes be polled for user input?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.allowButtons">
            <summary>
            Should buttons be polled for user input?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.allowButtonsOnFullAxisAssignment">
            <summary>
            Should buttons be polled when making a full-axis assignment?
            If allowed, buttons will be assigned to the positive axis range of the Action.
            If not allowed, button input will be ignored when making a full-axis assignment.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.timeout">
            <summary>
            The time in seconds that the mapper will listen before stopping. [0 = no timeout]
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.checkForConflicts">
            <summary>
            Should assignment conflict checking be enabled?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.checkForConflictsWithAllPlayers">
            <summary>
            Should assignment conflicts be checked with all Players? This setting overrides all other checkForConflictsWith options.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.checkForConflictsWithSelf">
            <summary>
            Should assignment conflicts be checked with the current Player?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.checkForConflictsWithSystemPlayer">
            <summary>
            Should assignment conflicts be checked with the System Player?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.checkForConflictsWithPlayerIds">
            <summary>
            A list of Player Ids to check for assignment conflicts with.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.defaultActionWhenConflictFound">
            <summary>
            When an assignment conflict is found, if there is no event listener for the ConflictsFoundEvent, the default action defined here will be used to resolve the conflict.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.ignoreMouseXAxis">
            <summary>
            Should the the mouse X axis be ignored when polling for user input?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.ignoreMouseYAxis">
            <summary>
            Should the the mouse Y axis be ignored when polling for user input?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.allowKeyboardKeysWithModifiers">
            <summary>
            Should modifier key + key combinations be allowed for keyboard mappings? Otherwise, only individual key mappings will be allowed.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.allowKeyboardModifierKeyAsPrimary">
            <summary>
            Should keyboard modifier keys be allowed as the primary key for the Action?
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.holdDurationToMapKeyboardModifierKeyAsPrimary">
            <summary>
            If both allowKeyboardKeysWithModifiers and allowKeyboardModifierKeyAsPrimary are true, the modifier key must be held down
            for this duration in seconds before it will be accepted as a primary key assignment. This is used to allow the user to be able to map
            modifier key + key combinations while also allowing them to map modifier keys as the primary key.
            </summary>
        </member>
        <member name="P:Rewired.InputMapper.Options.isElementAllowedCallback">
            <summary>
            A callback used to determine whether a particular controller element is allowed for mapping.
            Set this if you want to manually disallow specific controller elements from being used.
            </summary>
        </member>
        <member name="T:Rewired.PlayerSaveData">
            <summary>
            A struct used for retrieving all the saveable data in a Player.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.Platform">
            <exclude></exclude>
            <summary>
            The runtime platform.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.EditorPlatform">
            <exclude></exclude>
            <summary>
            The editor platform.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WebplayerPlatform">
            <exclude></exclude>
            <summary>
            The webplayer platform.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.ScriptingBackend">
            <exclude></exclude>
            <summary>
            The Unity scripting backend.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.ScriptingAPILevel">
            <exclude></exclude>
            <summary>
            The Unity scripting API level.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WindowsStandalonePrimaryInputSource">
            <summary>
            Windows Standalone input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.WindowsStandalonePrimaryInputSource.RawInput">
            <summary>
            Use Raw Input for the input source. Note: Raw Input carries significant advantages over Direct Input such as better Bluetooth controller support, support for more elements on certain controllers, better controller recognition, etc. Does not require any extra libraries. Windows Control Panel joystick calibration does not affect Joystick axes.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.WindowsStandalonePrimaryInputSource.DirectInput">
            <summary>
            Use Direct Input for the input source. Installation of DirectX end-user runtimes may be required for Direct Input support. Windows Control Panel joystick calibration settings affect Joystick axes.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.WindowsStandalonePrimaryInputSource.XInput">
            <summary>
            Use XInput for the input source. This will use XInput only. All non-XInput compatible controllers will be non-functional. To support both XInput and non-XInput controllers, use Raw Input or Direct Input instead and enable the Use XInput option. Installation of DirectX end-user runtimes is required on Windows XP.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.WindowsStandalonePrimaryInputSource.SDL2">
            <summary>
            Use SDL2 for the input source. This option requires the SDL2 runtime library to be installed. Note: SDL2 does not support as many devices as other native input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.WindowsStandalonePrimaryInputSource.Unity">
            <summary>
            Use Unity fallback input.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.OSXStandalonePrimaryInputSource">
            <summary>
            OSX Standalone input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.OSXStandalonePrimaryInputSource.Native">
            <summary>
            Use native input for the input source. This provides the best device support.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.OSXStandalonePrimaryInputSource.SDL2">
            <summary>
             SDL2 - Use SDL2 for the input source. May be required for Steam Streaming and Steam Controller support in OSX. This option requires the SDL2 runtime library to be installed. Note: SDL2 does not support as many devices as other native input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.OSXStandalonePrimaryInputSource.Unity">
            <summary>
            Unity Input - Use Unity fallback input.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.LinuxStandalonePrimaryInputSource">
            <summary>
            Linux Standalone input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.LinuxStandalonePrimaryInputSource.Native">
            <summary>
            Use native input for the input source. This provides the best device support.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.LinuxStandalonePrimaryInputSource.SDL2">
            <summary>
            SDL2 - Use SDL2 for the input source. May be required for Steam Streaming and Steam Controller support in Linux. This option requires the SDL2 runtime library to be installed. Note: SDL2 does not support as many devices as other native input sources.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.LinuxStandalonePrimaryInputSource.Unity">
            <summary>
            Unity Input - Use Unity fallback input.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WindowsUWPPrimaryInputSource">
            <summary>
            Windows 10 Universal input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XboxOnePrimaryInputSource">
            <summary>
            Xbox One input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.GameCoreXboxOnePrimaryInputSource">
            <summary>
            GameCore Xbox One input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.GameCoreScarlettPrimaryInputSource">
            <summary>
            GameCore Xbox Series X input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS4PrimaryInputSource">
            <summary>
            PS4 input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS5PrimaryInputSource">
            <summary>
            PS5 input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WebGLPrimaryInputSource">
            <summary>
            WebGL input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.StadiaPrimaryInputSource">
            <summary>
            Stadia input sources.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.DirectInputAxis">
            <exclude></exclude>
            <summary>
            Axes supported by DirectInput.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.RawInputAxis">
            <exclude></exclude>
            <summary>
            Axes supported by RawInput in the Generic Desktop Usage Page.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XInputDeviceSubType">
            <exclude></exclude>
            <summary>
            XInput device sub types.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XInputAxis">
            <exclude></exclude>
            <summary>
            Axes supported by XInput.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XInputButton">
            <exclude></exclude>
            <summary>
            Buttons supported by XInput.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.OSXAxis">
            <exclude></exclude>
            <summary>
            Axes supported by OSX.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.UnityAxis">
            <exclude></exclude>
            <summary>
            Axes supported by Unity input.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.UnityButton">
            <exclude></exclude>
            <summary>
            Buttons supported by Unity input.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WebGLGamepadMappingType">
            <exclude></exclude>
            <summary>
            WebGL gamepad mapping types.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WebGLWebBrowserType">
            <exclude></exclude>
            <summary>
            WebGL Browser types.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.WebGLOSType">
            <exclude></exclude>
            <summary>
            WebGL Browser types.
            </summary>
        </member>
        <member name="T:Rewired.Player">
            <summary>
            Represents a player to which controllers are assigned. Input should normally be managed through the Player class.
            </summary>
        </member>
        <member name="F:Rewired.Player.controllers">
            <summary>
            A helper object that provides access controllers and controller maps.
            </summary>
        </member>
        <member name="M:Rewired.Player.GetSaveData(System.Boolean)">
            <summary>
            Gets save data for this player.
            </summary>
            <param name="userAssignableMapsOnly"></param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.GetButton(System.String)">
            <summary>
            Gets the button held state of an Action. This will return TRUE as long as the button is held.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButton(System.Int32)">
            <summary>
            Gets the button held state of an Action. This will return TRUE as long as the button is held.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDown(System.String)">
            <summary>
            Gets the button just pressed state of an Action. This will only return TRUE only on the first frame the button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDown(System.Int32)">
            <summary>
            Gets the button just pressed state of an Action. This will only return TRUE only on the first frame the button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonUp(System.String)">
            <summary>
            Get the button just released state for an Action. This will only return TRUE for the first frame the button is released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonUp(System.Int32)">
            <summary>
            Get the button just released state for an Action. This will only return TRUE for the first frame the button is released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonPrev(System.String)">
            <summary>
            Gets the button held state of an Action during the previous frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The previous button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonPrev(System.Int32)">
            <summary>
            Gets the button held state of an Action during the previous frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The previous button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressHold(System.Int32)">
            <summary>
            Gets the button single pressed and held state of an Action.
            This will return TRUE after a button is held and the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButton(System.Int32)">GetButton</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button single pressed and held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressHold(System.String)">
            <summary>
            Gets the button single pressed and held state of an Action.
            This will return TRUE after a button is held and the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButton(System.String)">GetButton</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button single pressed and held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressDown(System.Int32)">
            <summary>
            Gets the button just single pressed and held state of an Action.
            This will return TRUE for only the first frame after a button press and after the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButtonDown(System.Int32)">GetButtonDown</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button just single pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressDown(System.String)">
            <summary>
            Gets the button just single pressed state of an Action.
            This will return TRUE for only the first frame after a button press and after the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButtonDown(System.String)">GetButtonDown</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button just single pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressUp(System.Int32)">
            <summary>
            Gets the button single pressed and just released state of an Action.
            This will return TRUE for only the first frame after the release of a single press.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButtonUp(System.Int32)">GetButtonUp</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button single press just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonSinglePressUp(System.String)">
            <summary>
            Gets the button single pressed and just released state of an Action.
            This will return TRUE for only the first frame after the release of a single press.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetButtonUp(System.String)">GetButtonUp</see> instead for instantaneous button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button single press just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressHold(System.String,System.Single)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressHold(System.Int32,System.Single)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressHold(System.String)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressHold(System.Int32)">
            <summary>
            Gets the button double pressed and held state of an Action. This will return TRUE after a double press and the button is then held.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressDown(System.String,System.Single)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressDown(System.Int32,System.Single)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressDown(System.String)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressDown(System.Int32)">
            <summary>
            Gets the button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressUp(System.String,System.Single)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressUp(System.Int32,System.Single)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressUp(System.String)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonDoublePressUp(System.Int32)">
            <summary>
            Gets the button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPress(System.String,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPress(System.Int32,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPress(System.String,System.Single,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time in seconds the button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPress(System.Int32,System.Single,System.Single)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressDown(System.String,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressDown(System.Int32,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the button must be held before returning true.</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressUp(System.String,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressUp(System.Int32,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressUp(System.String,System.Single,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimedPressUp(System.Int32,System.Single,System.Single)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPress(System.String)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPress(System.Int32)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPressDown(System.String)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPressDown(System.Int32)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPressUp(System.String)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonShortPressUp(System.Int32)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            The button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPress(System.String)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPress(System.Int32)">
            <summary>
            Gets the button held state of an Action after being held for a period of time.
            This will return TRUE only after the button has been held
            for the specified time and will continue to return TRUE
            until the button is released.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPress instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPressDown(System.String)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPressDown(System.Int32)">
            <summary>
            Gets the button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the button had been held for the specified time.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressDown instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPressUp(System.String)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonLongPressUp(System.Int32)">
            <summary>
            Gets the button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the button had
            been held for at least the specified time and then released.
            This also applies to axes.
            The button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetButtonTimedPressUp instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonRepeating(System.String)">
            <summary>
            Gets the repeating button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The button state.</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonRepeating(System.Int32)">
            <summary>
            Gets the repeating button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The button state.</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyButton">
            <summary>
            Gets the button held state of all Actions. This will return TRUE as long as any button is held.
            This also applies to axes.
            </summary>
            <returns>The button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyButtonDown">
            <summary>
            Gets the button just pressed state of all Actions. This will only return TRUE only on the first frame any button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This will return TRUE each time any button is pressed even if others are being held down.
            This also applies to axes.
            </summary>
            <returns>The button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyButtonUp">
            <summary>
            Get the button just released state for all Actions. This will only return TRUE for the first frame the button is released.
            This will return TRUE each time any button is released even if others are being held down.
            This also applies to axes.
            </summary>
            <returns>The button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyButtonPrev">
            <summary>
            Gets the button held state of an any Action during the previous frame.
            This also applies to axes.
            </summary>
            <returns>The previous button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimePressed(System.String)">
            <summary>
            Gets the length of time in seconds that a button has been continuously held down. Returns 0 if the button is not currently pressed.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration of the button hold.</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimePressed(System.Int32)">
            <summary>
            Gets the length of time in seconds that a button has been continuously held down. Returns 0 if the button is not currently pressed.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration of the button hold.</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimeUnpressed(System.String)">
            <summary>
            Gets the length of time in seconds that a button has not been pressed. Returns 0 if the button is currently pressed.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration of the button inactivity.</returns>
        </member>
        <member name="M:Rewired.Player.GetButtonTimeUnpressed(System.Int32)">
            <summary>
            Gets the length of time in seconds that a button has not been pressed. Returns 0 if the button is currently pressed.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration of the button inactivity.</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButton(System.String)">
            <summary>
            Gets the negative button held state of an Action. This will return TRUE as long as the negative button is held.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButton(System.Int32)">
            <summary>
            Gets the negative button held state of an Action. This will return TRUE as long as the negative button is held.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDown(System.String)">
            <summary>
            Gets the negative button just pressed state of an Action. This will only return TRUE only on the first frame the negative button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDown(System.Int32)">
            <summary>
            Gets the negative button just pressed state of an Action. This will only return TRUE only on the first frame the negative button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonUp(System.String)">
            <summary>
            Get the negative button just released state for an Action. This will only return TRUE for the first frame the negative button is released.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonUp(System.Int32)">
            <summary>
            Get the negative button just released state for an Action. This will only return TRUE for the first frame the negative button is released.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonPrev(System.String)">
            <summary>
            Gets the negative button held state of an Action during the previous frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The previous negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonPrev(System.Int32)">
            <summary>
            Gets the negative button held state of an Action during the previous frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The previous negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressHold(System.Int32)">
            <summary>
            Gets the negative button single pressed and held state of an Action.
            This will return TRUE after a negative button is held and the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButton(System.Int32)">GetNegativeButton</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button single pressed and held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressHold(System.String)">
            <summary>
            Gets the negative button single pressed and held state of an Action.
            This will return TRUE after a negative button is held and the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButton(System.String)">GetNegativeButton</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button single pressed and held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressDown(System.Int32)">
            <summary>
            Gets the negative button just single pressed and held state of an Action.
            This will return TRUE for only the first frame after a negative button press and after the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButtonDown(System.Int32)">GetNegativeButtonDown</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button just single pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressDown(System.String)">
            <summary>
            Gets the negative button just single pressed state of an Action.
            This will return TRUE for only the first frame after a negative button press and after the double press timeout has expired.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButtonDown(System.String)">GetNegativeButtonDown</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button just single pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressUp(System.Int32)">
            <summary>
            Gets the negative button single pressed and just released state of an Action.
            This will return TRUE for only the first frame after the release of a single press.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButtonUp(System.Int32)">GetNegativeButtonUp</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button single press just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonSinglePressUp(System.String)">
            <summary>
            Gets the negative button single pressed and just released state of an Action.
            This will return TRUE for only the first frame after the release of a single press.
            This will never return TRUE if a double press occurs.
            This method is delayed because it only returns TRUE after the double press timeout has expired.
            Only use this method if you need to check for both a single press and a double press on the same Action.
            Otherwise, use <see cref="M:Rewired.Player.GetNegativeButtonUp(System.String)">GetNegativeButtonUp</see> instead for instantaneous negative button press detection.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button single press just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressHold(System.String,System.Single)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressHold(System.Int32,System.Single)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressHold(System.String)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressHold(System.Int32)">
            <summary>
            Gets the negative button double pressed and held state of an Action. This will return TRUE after a double press and the negative button is then held.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressDown(System.String,System.Single)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressDown(System.Int32,System.Single)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressDown(System.String)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressDown(System.Int32)">
            <summary>
            Gets the negative button double pressed state of an Action. This will return TRUE only on the first frame of a double press.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressUp(System.String,System.Single)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressUp(System.Int32,System.Single)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="speed">Allowed time for a double press in seconds.</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressUp(System.String)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonDoublePressUp(System.Int32)">
            <summary>
            Gets the negative button double pressed and just released state of an Action. This will return TRUE only on the first frame after double press is released.
            The double press speed is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPress(System.String,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPress(System.Int32,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPress(System.String,System.Single,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time in seconds the negative button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPress(System.Int32,System.Single,System.Single)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if held. [0 = Never expire]</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressDown(System.String,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressDown(System.Int32,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true.</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressUp(System.String,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressUp(System.Int32,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressUp(System.String,System.Single,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimedPressUp(System.Int32,System.Single,System.Single)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="time">Minimum time the negative button must be held before returning true when released.</param>
            <param name="expireIn">Time in seconds after activation that the press will expire. Once expired, it will no longer return true even if released. [0 = Never expire]</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPress(System.String)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPress(System.Int32)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPressDown(System.String)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPressDown(System.Int32)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPressUp(System.String)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonShortPressUp(System.Int32)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button short press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPress(System.String)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPress(System.Int32)">
            <summary>
            Gets the negative button held state of an Action after being held for a period of time.
            This will return TRUE only after the negative button has been held
            for the specified time and will continue to return TRUE
            until the negative button is released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPress instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPressDown(System.String)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPressDown(System.Int32)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time.
            This will return TRUE only on the frame in which
            the negative button had been held for the specified time.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressDown instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button down state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPressUp(System.String)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonLongPressUp(System.Int32)">
            <summary>
            Gets the negative button state of an Action after being held for a period of time and then released.
            This will return TRUE only on the frame in which the negative button had
            been held for at least the specified time and then released.
            This also applies to axes being used as negative buttons.
            The negative button long press time is set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            For a custom duration, use GetNegativeButtonTimedPressUp instead.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button up state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonRepeating(System.String)">
            <summary>
            Gets the repeating negative button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This also applies to axes.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The negative button state.</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonRepeating(System.Int32)">
            <summary>
            Gets the repeating negative button state of an Action.
            This will return TRUE when immediately pressed, then FALSE until the Input Behaviour button repeat delay has elapsed,
            then TRUE for a 1-frame duration repeating at the interval specified in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This also applies to axes.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The negative button state.</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyNegativeButton">
            <summary>
            Gets the negative button held state of all Actions. This will return TRUE as long as any negative button is held.
            This also applies to axes.
            </summary>
            <returns>The negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyNegativeButtonDown">
            <summary>
            Gets the negative button just pressed state of all Actions. This will only return TRUE only on the first frame any negative button is pressed or for the duration of the Button Down Buffer time limit if set in the <see cref="T:Rewired.InputBehavior"/> assigned to the Action.
            This will return TRUE each time any negative button is pressed even if others are being held down.
            This also applies to axes.
            </summary>
            <returns>The negative button just pressed state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyNegativeButtonUp">
            <summary>
            Get the negative button just released state for all Actions. This will only return TRUE for the first frame the negative button is released.
            This will return TRUE each time any negative button is released even if others are being held down.
            This also applies to axes.
            </summary>
            <returns>The negative button just released state</returns>
        </member>
        <member name="M:Rewired.Player.GetAnyNegativeButtonPrev">
            <summary>
            Gets the negative button held state of an any Action during the previous frame.
            This also applies to axes.
            </summary>
            <returns>The previous negative button held state</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimePressed(System.String)">
            <summary>
            Gets the length of time in seconds that a negative button has been continuously held down. Returns 0 if the negative button is not currently pressed.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration of the negative button hold.</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimePressed(System.Int32)">
            <summary>
            Gets the length of time in seconds that a negative button has been continuously held down. Returns 0 if the negative button is not currently pressed.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration of the negative button hold.</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimeUnpressed(System.String)">
            <summary>
            Gets the length of time in seconds that a negative button has not been pressed. Returns 0 if the negative button is currently pressed.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration of the negative button inactivity.</returns>
        </member>
        <member name="M:Rewired.Player.GetNegativeButtonTimeUnpressed(System.Int32)">
            <summary>
            Gets the length of time in seconds that a negative button has not been pressed. Returns 0 if the negative button is currently pressed.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration of the negative button inactivity.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis(System.String)">
            <summary>
            Gets the axis value of an Action.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis(System.Int32)">
            <summary>
            Gets the axis value of an Action.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRaw(System.String)">
            <summary>
            Gets the raw axis value of an Action. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRaw(System.Int32)">
            <summary>
            Gets the raw axis value of an Action. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisPrev(System.String)">
            <summary>
            Gets the axis value of an Action during the previous frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The previous axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisPrev(System.Int32)">
            <summary>
            Gets the axis value of an Action during the previous frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The previous axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawPrev(System.String)">
            <summary>
            Gets the raw axis value of an Action during the previous frame. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The previous raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawPrev(System.Int32)">
            <summary>
            Gets the raw axis value of an Action during the previous frame. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The previous raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisDelta(System.String)">
            <summary>
            Gets the change in axis value of an Action since the previous frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The change in axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisDelta(System.Int32)">
            <summary>
            Gets the change in axis value of an Action since the previous frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The change in axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawDelta(System.String)">
            <summary>
            Gets the change in raw axis value of an Action since the previous frame. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The change in raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawDelta(System.Int32)">
            <summary>
            Gets the change in raw axis value of an Action since the previous frame. The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The change in raw axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2D(System.String,System.String)">
            <summary>
            Gets the axis value of two Actions.
            </summary>
            <param name="xAxisActionName">Name of the X axis Action</param>
            <param name="yAxisActionName">Name of the Y axis Action</param>
            <returns>The 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2D(System.Int32,System.Int32)">
            <summary>
            Gets the axis value of two Actions.
            </summary>
            <param name="xAxisActionId">Id of the X axis Action</param>
            <param name="yAxisActionId">Id of the Y axis Action</param>
            <returns>The 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DPrev(System.String,System.String)">
            <summary>
            Gets the axis value of two Actions during the previous frame.
            </summary>
            <param name="xAxisActionName">Name of the X axis Action</param>
            <param name="yAxisActionName">Name of the Y axis Action</param>
            <returns>The 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DPrev(System.Int32,System.Int32)">
            <summary>
            Gets the axis value of two Actions during the previous frame.
            </summary>
            <param name="xAxisActionId">Id of the X axis Action</param>
            <param name="yAxisActionId">Id of the Y axis Action</param>
            <returns>The 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DRaw(System.String,System.String)">
            <summary>
            Gets the raw axis value of two Actions.
            The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="xAxisActionName">Name of the X axis Action</param>
            <param name="yAxisActionName">Name of the Y axis Action</param>
            <returns>The raw 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DRaw(System.Int32,System.Int32)">
            <summary>
            Gets the raw axis value of two Actions.
            The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="xAxisActionId">Id of the X axis Action</param>
            <param name="yAxisActionId">Id of the Y axis Action</param>
            <returns>The raw 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DRawPrev(System.String,System.String)">
            <summary>
            Gets the raw axis value of two Actions during the previous frame.
            The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="xAxisActionName">Name of the X axis Action</param>
            <param name="yAxisActionName">Name of the Y axis Action</param>
            <returns>The raw 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxis2DRawPrev(System.Int32,System.Int32)">
            <summary>
            Gets the raw axis value of two Actions during the previous frame.
            The raw value excludes any digital axis simulation modification by the <see cref="T:Rewired.InputBehavior"/> assigned to this Action.
            This raw value is modified by dead zone and axis calibration settings in the controller. To get truly raw values, you must get the raw value directly from the Controller element.
            </summary>
            <param name="xAxisActionId">Id of the X axis Action</param>
            <param name="yAxisActionId">Id of the Y axis Action</param>
            <returns>The raw 2D axis value.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisTimeActive(System.String)">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active. Returns 0 if the axis is not currently active.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration the axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisTimeActive(System.Int32)">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active. Returns 0 if the axis is not currently active.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration the axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisTimeInactive(System.String)">
            <summary>
            Gets the length of time in seconds that an axis has been inactive. Returns 0 if the axis is currently active.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisTimeInactive(System.Int32)">
            <summary>
            Gets the length of time in seconds that an axis has been inactive. Returns 0 if the axis is currently active.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawTimeActive(System.String)">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active as calculated from the raw value. Returns 0 if the axis is not currently active.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration the raw axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawTimeActive(System.Int32)">
            <summary>
            Gets the length of time in seconds that an axis has been continuously active as calculated from the raw value. Returns 0 if the axis is not currently active.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration the raw axis has been continuously active.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawTimeInactive(System.String)">
            <summary>
            Gets the length of time in seconds that an axis has been inactive as calculated from the raw value. Returns 0 if the axis is currently active.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawTimeInactive(System.Int32)">
            <summary>
            Gets the length of time in seconds that an axis has been inactive as calculated from the raw value. Returns 0 if the axis is currently active.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The duration the axis has been continuously inactive.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisCoordinateMode(System.String)">
            <summary>
            Gets the current coordinate mode of the axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisCoordinateMode(System.Int32)">
            <summary>
            Gets the current coordinate mode of the axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawCoordinateMode(System.String)">
            <summary>
            Gets the current coordinate mode of the raw axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawCoordinateMode(System.Int32)">
            <summary>
            Gets the current coordinate mode of the raw axis.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisCoordinateModePrev(System.String)">
            <summary>
            Gets the coordinate mode of the axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisCoordinateModePrev(System.Int32)">
            <summary>
            Gets the coordinate mode of the axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawCoordinateModePrev(System.String)">
            <summary>
            Gets the coordinate mode of the raw axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetAxisRawCoordinateModePrev(System.Int32)">
            <summary>
            Gets the coordinate mode of the raw axis on the previous frame.
            This can be used to detect whether the axis is returning a delta value
            (mouse, touchpad, etc.) or an absolute value (joystick).
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>The raw axis coordinate mode.</returns>
        </member>
        <member name="M:Rewired.Player.GetCurrentInputSources(System.String)">
            <summary>
            Gets a list of all the input sources that contributed to the value of an Action in the current frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <returns>Input source data</returns>
        </member>
        <member name="M:Rewired.Player.GetCurrentInputSources(System.Int32)">
            <summary>
            Gets a list of all the input sources that contributed to the value of an Action in the current frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <returns>Input source data</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.String,Rewired.ControllerType)">
            <summary>
            Checks whether any controller of controller type contributed input to this Action in the current frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="controllerType">Type of the controller</param>
            <returns>Whether any controller type contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.Int32,Rewired.ControllerType)">
            <summary>
            Checks whether any controller of type contributed input to this Action in the current frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="controllerType">Type of the controller</param>
            <returns>Whether any controller type contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.String,Rewired.ControllerType,System.Int32)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="controllerType">Type of the controller</param>
            <param name="controllerId">Id the controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.Int32,Rewired.ControllerType,System.Int32)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="controllerType">Type of the controller</param>
            <param name="controllerId">Id the controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.String,Rewired.Controller)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="actionName">Name of the Action</param>
            <param name="controller">The controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.IsCurrentInputSource(System.Int32,Rewired.Controller)">
            <summary>
            Checks whether a particular controller contributed input to this Action in the current frame.
            </summary>
            <param name="actionId">Id of the Action</param>
            <param name="controller">The controller</param>
            <returns>Whether a controller contributed to the Action this frame.</returns>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType)">
            <summary>
            Add a delegate to receive input action events every time any input action value is updated.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,System.Int32)">
            <summary>
            Add a delegate to receive input action events every time a specific input action value is updated.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="actionId">The id of the action for which to receive change events.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,System.String)">
            <summary>
            Add a delegate to receive input action events every time a specific input action value is updated.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="actionName">The name of the action for which to receive change events.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType)">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in any action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.Int32)">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in a specific action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionId">The id of the action for which to receive change events.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.String)">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in a specific action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionName">The name of the action for which to receive change events.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.Object[])">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in any action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="arguments">Arguments for the event. See InputActionEventType for event types that require arguments.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.Int32,System.Object[])">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in a specific action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionId">The id of the action for which to receive change events.</param>
            <param name="arguments">Arguments for the event. See InputActionEventType for event types that require arguments.</param>
        </member>
        <member name="M:Rewired.Player.AddInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.String,System.Object[])">
            <summary>
            Add a delegate to receive input action events every time a specific event occurs in a specific action.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="updateLoop">The update loop in which to monitor changes.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionName">The name of the action for which to receive change events.</param>
            <param name="arguments">Arguments for the event. See InputActionEventType for event types that require arguments.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData})">
            <summary>
            Remove a delegate to no longer receive input action events from any update loop for all actions.
            </summary>
            <param name="callback">The delegate to be removed.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},System.Int32)">
            <summary>
            Remove a delegate to no longer receive input action events from any update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="actionId">The id of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},System.String)">
            <summary>
            Remove a delegate to no longer receive input action events from any update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="actionName">The name of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for all actions.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.InputActionEventType)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for all actions.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="eventType">The event type for which to send an event.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,System.Int32)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
            <param name="actionId">The id of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,System.String)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
            <param name="actionName">The name of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.InputActionEventType,System.Int32)">
            <summary>
            Remove a delegate to no longer receive input action events from any update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionId">The id of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.InputActionEventType,System.String)">
            <summary>
            Remove a delegate to no longer receive input action events from any update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionName">The name of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for all actions.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
            <param name="eventType">The event type for which to send an event.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.Int32)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionId">The id of the action.</param>
        </member>
        <member name="M:Rewired.Player.RemoveInputEventDelegate(System.Action{Rewired.InputActionEventData},Rewired.UpdateLoopType,Rewired.InputActionEventType,System.String)">
            <summary>
            Remove a delegate to no longer receive input action events from the specified update loop for the specified action.
            </summary>
            <param name="callback">The delegate to be removed.</param>
            <param name="updateLoop">The update loop.</param>
            <param name="eventType">The event type for which to send an event.</param>
            <param name="actionName">The name of the action.</param>
        </member>
        <member name="M:Rewired.Player.ClearInputEventDelegates">
            <summary>
            Clears all input action event delegates. You will no longer receive any input action update events.
            </summary>
        </member>
        <member name="M:Rewired.Player.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index in all <see cref="T:Rewired.Joystick">Joysticks</see> assigned to the Player.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Player.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout in all <see cref="T:Rewired.Joystick">Joysticks</see> assigned to the Player.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Player.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index in all <see cref="T:Rewired.Joystick">Joysticks</see> assigned to the Player.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Player.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout in all <see cref="T:Rewired.Joystick">Joysticks</see> assigned to the Player.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Player.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            This returns the largest value found for the specified motor index in all <see cref="T:Rewired.Joystick">Joysticks</see> assigned to the Player.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Player.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="P:Rewired.Player.id">
            <summary>
            The id of the Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.name">
            <summary>
            The scripting name of the Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.descriptiveName">
            <summary>
            The descriptive name of the Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.isPlaying">
            <summary>
            Is this Player currently playing? This property is for user use. It is never set to anything but whatever you set in the Rewired Input Manager Player's page for the "Is Playing on Start" field. The only thing that Player.isPlaying affects internally is Joystick Auto-Assignment if "Assign to Playing Players Only" is set to True. One might use Player.isPlaying to flag that a Player has joined in and is active or has quit/lost all their lives, etc. Player.isPlaying does not affect input returned by the Player.
            </summary>
        </member>
        <member name="T:Rewired.Player.ControllerHelper">
            <summary>
            Provides access to all controller-related members in Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetController``1(System.Int32)">
            <summary>
            Gets a controller of the specified type assigned to this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetControllerWithTag``1(System.String)">
            <summary>
            Gets a controller of the specificed type with the specified tag assigned to this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="tag">The tag</param>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.AddController``1(System.Int32,System.Boolean)">
            <summary>
            Assigns a controller to this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="removeFromOtherPlayers">Unassign this controller from all other players.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.RemoveController``1(System.Int32)">
            <summary>
            Unassigns a controller from this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ContainsController``1(System.Int32)">
            <summary>
            Checks if a controller is assigned to this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ClearControllersOfType``1">
            <summary>
            Unassign all controllers of a specific type from this Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ClearAllControllers">
            <summary>
            Unassign all controllers from this Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetLastActiveController">
            <summary>
            Get the last controller that contributed input through the Player.
            </summary>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetLastActiveController(Rewired.ControllerType)">
            <summary>
            Get the last controller that contributed input through the Player.
            </summary>
            <param name="controllerType">The controller type.</param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.FindLastActiveControllerOfType(Rewired.ControllerType,Rewired.Controller@,System.Double@)">
            <summary>
            Don't use for Mouse/KB
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetLastActiveController``1">
            <summary>
            Get the last controller that contributed input through the Player.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.AddLastActiveControllerChangedDelegate(Rewired.PlayerActiveControllerChangedDelegate)">
            <summary>
            Add a delegate to receive a callback every time the last active controller changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.AddLastActiveControllerChangedDelegate(Rewired.PlayerActiveControllerChangedDelegate,Rewired.ControllerType)">
            <summary>
            Add a delegate to receive a callback every time the last active controller of a specific type changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="controllerType">The controller type for which to listen for changes.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.RemoveLastActiveControllerChangedDelegate(Rewired.PlayerActiveControllerChangedDelegate)">
            <summary>
            Remove a delegate to no longer receive callbacks when the last active controller changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            
        </member>
        <member name="M:Rewired.Player.ControllerHelper.RemoveLastActiveControllerChangedDelegate(Rewired.PlayerActiveControllerChangedDelegate,Rewired.ControllerType)">
            <summary>
            Remove a delegate to no longer receive callbacks when the last active controller of a specific type changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="controllerType">The controller type for which to listen for changes.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ClearLastActiveControllerChangedDelegates">
            <summary>
            Remove all delegates to no longer receive any callbacks when the last active controller changes.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetFirstControllerWithTemplate(System.Guid)">
            <summary>
            Gets the first Controller of any type that implements the specified Controller Template.
            </summary>
            <param name="templateTypeGuid">Controller Template type GUID</param>
            <returns>Returns the first Controller that implements the Controller Template or null if none were found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetFirstControllerWithTemplate(System.Type)">
            <summary>
            Gets the first Controller of any type that implements the specified Controller Template.
            </summary>
            <param name="templateType">Controller Template type</param>
            <returns>Returns the first Controller that implements the Controller Template or null if none were found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetFirstControllerWithTemplate``1">
            <summary>
            Gets the first Controller of any type that implements the specified Controller Template.
            </summary>
            <typeparam name="T">Controller Template Type</typeparam>
            <returns>Returns the first Controller that implements the Controller Template or null if none were found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.GetControllerTemplates``1">
            <summary>
            Gets a list of all Controller Templates in assigned Controllers that match the type.
            </summary>
            <typeparam name="TInterface">Controller Template interface type. Note: You must use the interface of the Controller Template and not the concrete class.</typeparam>
            <returns></returns>
        </member>
        <member name="E:Rewired.Player.ControllerHelper.ControllerAddedEvent">
            <summary>
            Event triggered when a controller is assigned to this Player.
            </summary>
        </member>
        <member name="E:Rewired.Player.ControllerHelper.ControllerRemovedEvent">
            <summary>
            Event triggered when a controller is unassigned from this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.hasMouse">
            <summary>
            Is the mouse assigned to this Player?
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.hasKeyboard">
            <summary>
            Is the keyboard assigned to this Player?
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.excludeFromControllerAutoAssignment">
            <summary>
            Determines whether controllers can be auto-assigned to this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.Keyboard">
            <summary>
            Gets the Keyboard.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.Mouse">
            <summary>
            Gets the Mouse.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.joystickCount">
            <summary>
            The number of joysticks assigned to this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.Joysticks">
            <summary>
            A list of joysticks assigned to this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.customControllerCount">
            <summary>
            The number of Custom Controllers assigned to this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.CustomControllers">
            <summary>
            Gets a list of Custom Controllers assigned to this Player.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.Controllers">
            <summary>
            Enumerates all controllers of all types assigned to this Player.
            </summary>
        </member>
        <member name="T:Rewired.Player.ControllerHelper.ConflictCheckingHelper">
            <summary>
            Provides access to all controller element assignment conflict checking related members.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.CodeHelper">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Utils.Classes.CodeHelper.Equals(System.Object)">
            <exclude></exclude>
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Rewired.Utils.Classes.CodeHelper.GetHashCode">
            <exclude></exclude>
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Rewired.Utils.Classes.CodeHelper.ToString">
            <exclude></exclude>
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DoesElementAssignmentConflict(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Boolean)">
            <summary>
            Checks if any element assignments on a particular Controller assigned to this Player
            conflicts with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Is there a conflict?</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <returns>Enumerates the conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller
            assigned to this Player and the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller assigned
            to this Player and the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller assigned
            to this Player and the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.ElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Boolean)">
            <summary>
            Enumerates all conflicts between element assignments on a particular Controller assigned
            to this Player and the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>IEnumerable of conflicts.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean,System.Boolean)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean,System.Boolean)">
            <summary>
            Removes all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Removes any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Removes any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.RemoveElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Boolean)">
            <summary>
            Removes any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipRemovedMaps">If true, removed Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were removed.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean,System.Boolean)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with any of the assignments on the incoming Controller Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map whose Action Element Maps will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,Rewired.ActionElementMap,System.Boolean,System.Boolean)">
            <summary>
            Disables all element assignments on a particular Controller assigned to this Player
            that conflict with the assignment in the incoming Action Element Map.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="controllerMap">The Controller Map that contains the incoming Action Element Map. This is used to determine the Map Category for Map Category to Map Category conflict checking.</param>
            <param name="elementMap">The Action Element Map whose assignment will be checked against for conflicts.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck)">
            <summary>
            Disables any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean)">
            <summary>
            Disables any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.ConflictCheckingHelper.DisableElementAssignmentConflicts(Rewired.ElementAssignmentConflictCheck,System.Boolean,System.Boolean)">
            <summary>
            Disables any element assignments on a particular Controller assigned to this Player
            that conflict with the potential assignment in the incoming Element Assignment Conflict Check.
            </summary>
            <param name="conflictCheck">The object containing the desired element assignment.</param>
            <param name="skipDisabledMaps">If true, disabled Controller Maps and Action Element Maps will be skipped.</param>
            <param name="forceCheckAllCategories">If true, all Map Categories will be checked against each other for conflicts regardless of the Map Category to Map Category conflict checking settings defined in the Rewired Input Manager.</param>
            <returns>Number of Action Element Maps that were disabled.</returns>
        </member>
        <member name="T:Rewired.Player.ControllerHelper.ControllerSetCollection">
            <summary>
            It's just small wrapper around an array so it's fast.
            Wouldn't be fast for large collections because it doesn't use buckets and hash
            like a dict and has to linearly search the array, but this will never be large.
            Tests show it about 40% faster than a Dictionary of the same length with the same
            values.
            </summary>
        </member>
        <member name="T:Rewired.Player.ControllerHelper.MapHelper">
            <summary>
            Provides access to all mapping related members.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement. Otherwise, map starts disabled and must be enabled before it can contribute to input.
            If <see cref="T:Rewired.ControllerMapEnabler"/>.<see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap``1(System.Int32,System.String,System.String)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement. Otherwise, map starts disabled and must be enabled before it can contribute to input.
            If <see cref="T:Rewired.ControllerMapEnabler"/>.<see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap(Rewired.ControllerType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement. Otherwise, map starts disabled and must be enabled before it can contribute to input.
            If <see cref="T:Rewired.ControllerMapEnabler"/>.<see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap(Rewired.ControllerType,System.Int32,System.String,System.String)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement. Otherwise, map starts disabled and must be enabled before it can contribute to input.
            If <see cref="T:Rewired.ControllerMapEnabler"/>.<see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap``1(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings overriding the startEnabled setting passed into the function.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap``1(System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings overriding the startEnabled setting passed into the function.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap(Rewired.ControllerType,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings overriding the startEnabled setting passed into the function.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadMap(Rewired.ControllerType,System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Loads a controller map from the maps defined in the Rewired Editor. Replaces if a map already exists with the same category and layout.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings overriding the startEnabled setting passed into the function.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps">
            <summary>
            Enumerates all controller maps assigned to this Player.
            </summary>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps(System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets all controller maps assigned to this Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps``1">
            <summary>
            Enumerates all controller maps assigned to this Player.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets all controller maps assigned to this Player.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps(Rewired.ControllerType)">
            <summary>
            Enumerates all controller maps for a specific controller type assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMaps(Rewired.ControllerType,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets all controller maps for a specific controller type assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.String)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryName">Category name</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.Int32)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryId">Category id</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory``1(System.String)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <param name="categoryName">Category name</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory``1(System.Int32)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <param name="categoryId">Category id</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.String,Rewired.ControllerType)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryName">Category name</param>
            <param name="controllerType">Controller type</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.Int32,Rewired.ControllerType)">
            <summary>
            Enumerates all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryId">Category id</param>
            <param name="controllerType">Controller type</param>
            <returns>IEnumerable of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.String,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryName">Category name</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.Int32,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryId">Category id</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory``1(System.String,System.Collections.Generic.List{``0})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <param name="categoryName">Category name</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory``1(System.Int32,System.Collections.Generic.List{``0})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type</typeparam>
            <param name="categoryId">Category id</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.String,Rewired.ControllerType,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryName">Category name</param>
            <param name="controllerType">Controller type</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapsInCategory(System.Int32,Rewired.ControllerType,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of all controller maps assigned to this player in a specific category.
            </summary>
            <param name="categoryId">Category id</param>
            <param name="controllerType">Controller type</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMaps``1(System.Int32)">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <returns>IList of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMaps(Rewired.ControllerType,System.Int32)">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <returns>IList of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMaps(Rewired.Controller)">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <returns>IList of controller maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controllerType">Controller type.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Map Category id.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.ControllerType,System.Int32,System.String)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controllerType">Controller type.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Map Category name.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.Controller,System.Int32)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controller">Controller.</param>
            <param name="categoryId">Map Category id.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.Controller,System.String)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controller">Controller.</param>
            <param name="categoryName">Map Category name.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.ControllerType,System.Int32,System.Int32,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controllerType">Controller type.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Map Category id.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.ControllerType,System.Int32,System.String,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controllerType">Controller type.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Map Category name.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.Controller,System.Int32,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controller">Controller.</param>
            <param name="categoryId">Map Category id.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory(Rewired.Controller,System.String,System.Collections.Generic.List{Rewired.ControllerMap})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <param name="controller">Controller.</param>
            <param name="categoryName">Map Category name.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory``1(System.Int32,System.Int32)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type.</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Map Category id.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory``1(System.Int32,System.String)">
            <summary>
            Enumerates controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type.</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Map Category name.</param>
            <returns>Enumeration of Controller Maps</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory``1(System.Int32,System.Int32,System.Collections.Generic.List{``0})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type.</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Map Category id.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapsInCategory``1(System.Int32,System.String,System.Collections.Generic.List{``0})">
            <summary>
            Gets a list of controller maps for a specific controller assigned to this Player in a specific category.
            </summary>
            <typeparam name="T">Controller Map type.</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Map Category name.</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of Controller Maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap``1(System.Int32,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="mapId">Controller map id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap``1(System.Int32,System.String,System.String)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(System.Int32)">
            <summary>
            Gets a controller map by id assigned to this Player.
            </summary>
            <param name="mapId">Controller map id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="mapId">Controller map id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.ControllerType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.ControllerType,System.Int32,System.String,System.String)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.Controller,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="mapId">Controller map id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.Controller,System.Int32,System.Int32)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMap(Rewired.Controller,System.String,System.String)">
            <summary>
            Gets a controller map for a specific controller by id assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="categoryName">Category name</param>
            <param name="layoutName">Layout name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory``1(System.Int32,System.String)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory``1(System.Int32,System.Int32)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <typeparam name="T">Controller map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory(Rewired.ControllerType,System.Int32,System.String)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryName">Category name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory(Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory(Rewired.Controller,System.String)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="categoryName">Category name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstMapInCategory(Rewired.Controller,System.Int32)">
            <summary>
            Gets the first controller map for the specified controller in the matching category assigned to this Player.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="categoryId">Category id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap``1(System.Int32,Rewired.ControllerMap)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="map">Controller Map</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap(Rewired.Controller,Rewired.ControllerMap)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <param name="controller">Controller</param>
            <param name="map">Controller Map</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap(Rewired.ControllerType,System.Int32,Rewired.ControllerMap)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="map">Controller Map</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap``1(System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="map">Controller Map</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap(Rewired.Controller,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <param name="controller">Controller</param>
            <param name="map">Controller Map</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMap(Rewired.ControllerType,System.Int32,Rewired.ControllerMap,System.Boolean)">
            <summary>
            Adds a controller map to the Player. Replaces if a map already exists with the same category and layout.
            When replaced, map enabled state is copied from the existing map into the replacement.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="map">Controller Map</param>
            <param name="startEnabled">Start this map enabled?</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapFromXml``1(System.Int32,System.String)">
            <summary>
            Adds a controller map to the Player from Xml save data.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="xmlString">Xml save data</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapFromXml(Rewired.ControllerType,System.Int32,System.String)">
            <summary>
            Adds a controller map to the Player from Xml save data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="xmlString">Xml save data</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapsFromXml``1(System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Adds multiple controller maps to the Player from Xml save data.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="xmlStrings">Xml save data</param>
            <returns>Returns the number of Controller Maps added.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapsFromXml(Rewired.ControllerType,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Adds multiple controller maps to the Player from Xml save data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="xmlStrings">Xml save data</param>
            <returns>>Returns the number of Controller Maps added.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapFromJson``1(System.Int32,System.String)">
            <summary>
            Adds a controller map to the Player from Json save data.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="jsonString">Json save data</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapFromJson(Rewired.ControllerType,System.Int32,System.String)">
            <summary>
            Adds a controller map to the Player from Json save data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="jsonString">Json save data</param>
            <returns>Success/Failure</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapsFromJson``1(System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Adds multiple controller maps to the Player from Json save data.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="jsonStrings">Json save data</param>
            <returns>Returns the number of Controller Maps added.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddMapsFromJson(Rewired.ControllerType,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            Adds multiple controller maps to the Player from Json save data.
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="jsonStrings">Json save data</param>
            <returns>>Returns the number of Controller Maps added.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddEmptyMap``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an empty controller map to the Player with the specified category and layout.
            </summary>
            <typeparam name="T">Map type</typeparam>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="categoryId">Category id</param>
            <param name="layoutId">Layout id</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddEmptyMap``1(System.Int32,System.String,System.String)">
            <summary>
            Add an empty controller map to the Player with the specified category and layout.
            </summary>
            <typeparam name="T">Map type</typeparam>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddEmptyMap(Rewired.ControllerType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an empty controller map to the Player with the specified category and layout.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AddEmptyMap(Rewired.ControllerType,System.Int32,System.String,System.String)">
            <summary>
            Add an empty controller map to the Player with the specified category and layout.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap``1(System.Int32,System.Int32)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap``1(System.Int32,System.Int32,System.Int32)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap``1(System.Int32,System.String,System.String)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap(Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap(Rewired.ControllerType,System.Int32,System.Int32,System.Int32)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.RemoveMap(Rewired.ControllerType,System.Int32,System.String,System.String)">
            <summary>
            Removes a controller map for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMaps``1(System.Boolean)">
            <summary>
            Removes all controller maps of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMaps(Rewired.ControllerType,System.Boolean)">
            <summary>
            Removes all controller maps of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory``1(System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory``1(System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory``1(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category and layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory``1(System.String,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category and layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category and layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInCategory(Rewired.ControllerType,System.String,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific category and layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInLayout``1(System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInLayout``1(System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInLayout(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsInLayout(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for all controllers of a specific type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController``1(System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController``1(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller in a specific category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController``1(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller in a specific category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller in a specific category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForController(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Removes all controller maps for a specific controller in a specific category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForControllerInLayout``1(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for a specific controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForControllerInLayout``1(System.Int32,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for a specific controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForControllerInLayout(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for a specific controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearMapsForControllerInLayout(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Removes all controller maps in a specific layout for a specific controllers.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ClearAllMaps(System.Boolean)">
            <summary>
            Removes all controller maps.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Button Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Button Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Button Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Button Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstButtonMapWithAction(System.String,System.Boolean)">
            <summary>
            Get the first button ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Button Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Button Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Button Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Button Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ButtonMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumerates all button ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.Controller,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.Controller,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(Rewired.ControllerType,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetButtonMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all button ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Axis Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Axis Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Axis Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Axis Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstAxisMapWithAction(System.String,System.Boolean)">
            <summary>
            Get the first axis ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Axis Maps with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Axis Maps with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Axis Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Axis Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.AxisMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumerates all axis ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.Controller,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.Controller,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(Rewired.ControllerType,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAxisMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all axis ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Action Element Map with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Action Element Map with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Action Element Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>The first Action Element Map found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Get the first ActionElementMap for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(System.Int32,System.Boolean)">
            <summary>
            Get the first ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithAction(System.String,System.Boolean)">
            <summary>
            Get the first ActionElementMap for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Action Element Maps with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Action Element Maps with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.Controller,System.Int32,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Action Element Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.Controller,System.String,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <returns>Enumeration of Action Element Maps found with the specified Action.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(Rewired.ControllerType,System.String,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(System.Int32,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithAction(System.String,System.Boolean)">
            <summary>
            Enumerates all ActionElementMaps for any controller type that contains a specific Action.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.ControllerType,System.Int32,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionId">Id of the Action</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.ControllerType,System.Int32,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controllerType">The type of controller.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <param name="actionName">Name of the Action</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.Controller,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller that contains a specific Action.
            </summary>
            <param name="controller">The Controller.</param>
            <param name="actionId">Id of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.Controller,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller that contains a specific Action.
            </summary><param name="controller">The Controller.</param>
            <param name="actionName">Name of the Action</param>
            <param name="skipDisabledMaps">Should disabled Controller Maps and Action Element Maps be skipped?</param>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.ControllerType,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(Rewired.ControllerType,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for a specific controller type that contains a specific Action.
            This overload applies to all Controllers of the specified type assigned to the Player.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithAction(System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets a list of all ActionElementMaps for any controller type that contains a specific Action.
            </summary>
            <param name="results">The list that will be filled with the results.</param>
            <exception cref="T:System.ArgumentNullException">results is null</exception>
            <returns>Number of maps found.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Enumarates all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>IEnumerable</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.Boolean)">
            <summary>
            Get the first ActionElementMap found that maps to a specific controller element target.
            </summary>
            <param name="elementTarget"></param>
            <param name="skipDisabledMaps"></param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.Boolean)">
            <summary>
            Get the first ActionElementMap found that maps to a specific controller element target.
            </summary>
            <param name="elementTarget"></param>
            <param name="skipDisabledMaps"></param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetFirstElementMapWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean)">
            <summary>
            Gets the first ActionElementMap found that maps to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <returns>ActionElementMap</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.ControllerElementTarget,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.Int32,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionId">The id of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetElementMapsWithElementTarget(Rewired.IControllerElementTarget,System.String,System.Boolean,System.Collections.Generic.List{Rewired.ActionElementMap})">
            <summary>
            Gets all ActionElementMaps that map to a specific controller element target and a specific Action.
            </summary>
            <param name="elementTarget">Target controller element</param>
            <param name="actionName">The name of the Action</param>
            <param name="skipDisabledMaps">Should disabled ActionElementMaps be skipped?</param>
            <param name="results">The results list which will be filled with the results.</param>
            <returns>Returns the count of results returned.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapSaveData``1(System.Int32,System.Boolean)">
            <summary>
            Gets controller map save data for a specific controller. Used for saving/loading.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetMapSaveData(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            Gets controller map save data for a specific controller. Used for saving/loading.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapSaveData``1(System.Boolean)">
            <summary>
            Gets all controller map save data. Used for saving/loading.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapSaveData(Rewired.ControllerType,System.Boolean)">
            <summary>
            Gets all controller map save data for a specific controller type. Used for saving/loading.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetAllMapSaveData(System.Boolean)">
            <summary>
            Gets all controller map save data. Used for saving/loading.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetAllMapsEnabled(System.Boolean)">
            <summary>
            Set the enabled state in all controller maps.
            NOTE: This method is not a persistent flag in Player that will set controller maps
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetAllMapsEnabled(System.Boolean,Rewired.ControllerType)">
            <summary>
            Set the enabled state in all controller maps for a particular controller type.
            NOTE: This method is not a persistent flag in Player that will set controller maps
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetAllMapsEnabled(System.Boolean,Rewired.Controller)">
            <summary>
            Set the enabled state in all controller maps for a particular controller.
            NOTE: This method is not a persistent flag in Player that will set controller maps
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controller">The Controller.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetAllMapsEnabled(System.Boolean,Rewired.ControllerType,System.Int32)">
            <summary>
            Set the enabled state in all controller maps for a particular controller.
            NNOTE: This method is not a persistent flag in Player that will set controller maps
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <param name="controllerId">Controller id - Get this from the Controller.id property. For Keyboard and Mouse, just use 0.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,System.Int32)">
            <summary>
            Set the enabled state in all controller maps in a particular category.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="categoryId">The id of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,System.String)">
            <summary>
            Set the enabled state in all controller maps in a particular category.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="categoryName">The name of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,System.String,System.String)">
            <summary>
            Set the enabled state in all controller maps in a particular category and layout.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="categoryName">The name of the category.</param>
            <param name="layoutName">The name of the layout.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.ControllerType,System.Int32)">
            <summary>
            Set the enabled state in all controller maps in a category for a particular controller type.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <param name="categoryId">The id of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.ControllerType,System.String)">
            <summary>
            Set the enabled state in all controller maps in a category for a particular controller type.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <param name="categoryName">The name of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller type.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <param name="categoryId">The id of the category.</param>
            <param name="layoutId">The id of the layout.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.ControllerType,System.String,System.String)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller type.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controllerType">The controller type.</param>
            <param name="categoryName">The name of the category.</param>
            <param name="layoutName">The name of the layout.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.Controller,System.Int32)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controller">The Controller.</param>
            <param name="categoryId">The id of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.Controller,System.Int32,System.Int32)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controller">The Controller.</param>
            <param name="categoryId">The id of the category.</param>
            <param name="layoutId">The id of the layout.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.Controller,System.String)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controller">The Controller.</param>
            <param name="categoryName">The name of the category.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.SetMapsEnabled(System.Boolean,Rewired.Controller,System.String,System.String)">
            <summary>
            Set the enabled state in all controller maps in a category and layout for a particular controller.
            NOTE: This method is not a persistent flag in Player that will set a certain category of map
            enabled/disabled upon loading. It is simply a shortcut for the iterating the controller maps
            currently loaded in the Player and set them enabled/disabled at the time the method is called.
            When new Controller Maps are loaded in the Player, either manually or when a Joystick is assigned,
            the newly loaded maps will be enabled/disabled based on the default enabled state settings for
            these maps on the Player page in the Rewired Input Manager, not based on previous calls to
            SetMapsEnabled. Read the documentation on Controller Maps for more information.
            If you need persistent enabled state management, use <see cref="T:Rewired.ControllerMapEnabler"/>.
            If <see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that affect the Controller Maps you are attempting to change the enabled state on, you should not use this function and instead use the functions in <see cref="T:Rewired.ControllerMapEnabler"/>.
            </summary>
            <param name="state">The enabled state.</param>
            <param name="controller">The Controller.</param>
            <param name="categoryName">The name of the category.</param>
            <param name="layoutName">The name of the layout.</param>
            <returns>Number of maps that changed state.</returns>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.LoadDefaultMaps(Rewired.ControllerType)">
            <summary>
            Loads the maps defined in the Rewired Editor and assigned to this player for the specified controller type.
            All existing maps will be cleared and replaced with the default maps.
            The Enabled state of each map will attempt to be preserved, but if you have
            added or removed maps through scripting, the result may not be as expected and you should set the Enabled states manually.
            For Joysticks that have been previously assigned to this Player but are no longer assigned at the time this method is called, the Joystick Map history for
            these Joysticks will be cleared so the next time the Joystick is assigned to this Player, the default Joystick Maps will be loaded instead of Joystick Maps
            stored in the history.
            If <see cref="T:Rewired.ControllerMapEnabler"/>.<see cref="P:Rewired.ControllerMapEnabler.enabled"/> is set to true and rules exist that apply to the map, the enabled state will be set based on those settings.
            </summary>
            <param name="controllerType">The controller type.</param>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ContainsMapInCategory(Rewired.InputMapCategory)">
            <summary>
            Determines if any maps exist in a particular Map Category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ContainsMapInCategory(System.Int32)">
            <summary>
            Determines if any maps exist in a particular Map Category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ContainsMapInCategory(System.String)">
            <summary>
            Determines if any maps exist in a particular Map Category.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.ContainsMapInCategory(Rewired.ControllerType,System.Int32)">
            <summary>
            Determines if any maps exist in a particular Map Category for a specific controller type.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetInputBehavior(System.Int32)">
            <summary>
            Gets a specific InputBehavior.
            </summary>
        </member>
        <member name="M:Rewired.Player.ControllerHelper.MapHelper.GetInputBehavior(System.String)">
            <summary>
            Gets a specific InputBehavior.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.MapHelper.layoutManager">
            <summary>
            Manages loading and unloading of Controller Maps in a Player based on user settings to force the specified Layouts to be used.
            This must be enabled before use by setting <see cref="P:Rewired.ControllerMapLayoutManager.enabled"/> to true, otherwise Controller Map
            enabled states in the Player will be unmanaged.
            This can be used to make specific Controller Maps be loaded in a Player with specific Layouts, for example when changing from one Controller
            Layout to another. These settings will persist and be inherited by new Controllers assigned to the Player.
            This will enforce a single Layout per managed Map Category be loaded in the Player. This cannot manage mutliple simultaneous
            Layouts in the same Map Category being loaded in the Player.
            To manage the enabled states, use <see cref="P:Rewired.Player.ControllerHelper.MapHelper.mapEnabler"/>.
            It is recommended that you use both <see cref="P:Rewired.Player.ControllerHelper.MapHelper.mapEnabler"/> and <see cref="P:Rewired.Player.ControllerHelper.MapHelper.layoutManager"/> together to manage
            both loading and enabled states of Controller Maps.
            When both are enabled, <see cref="P:Rewired.Player.ControllerHelper.MapHelper.layoutManager"/> will load/unload Controller Maps first, then <see cref="P:Rewired.Player.ControllerHelper.MapHelper.mapEnabler"/> will enable/disable
            the Controller Maps based on the rules you've set up in each..
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.MapHelper.mapEnabler">
            <summary>
            Enforces persistent enabled states on Controller Maps in a Player based on user settings.
            This must be enabled before use by setting <see cref="P:Rewired.ControllerMapEnabler.enabled"/> to true, otherwise Controller Map
            enabled states in the Player will be unmanaged.
            This can be used to make specific Controller Maps be enabled or disabled in a Player,
            for example when changing game modes that require user input to change.
            These settings will persist and be inherited by new Controllers assigned to the Player.
            Enabled states will be sync'd when new Controllers are added, when Controller Maps are loaded, etc.
            When using <see cref="T:Rewired.ControllerMapEnabler"/>, you should not manually set enabled states
            on Controller Maps that are managed by this class, but instead change all settings within this class.
            </summary>
        </member>
        <member name="P:Rewired.Player.ControllerHelper.MapHelper.InputBehaviors">
            <summary>
            Gets a list of all InputBehaviors in this Player.
            </summary>
        </member>
        <member name="T:Rewired.Player.ControllerHelper.PollingHelper">
            <summary>
            Provides access to all controller element polling related members.
            This should only be used for controller mapping or other non-gameplay-related code.
            The polling system is expensive and should not be used during gameplay.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.LoggedInUser">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.ControllerInformation">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.PadControllerInformation">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.PadDeviceClassExtendedInformation">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.PadStickInformation">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.Internal.PadTouchPadInformation">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.PS4.PS4AimExtension">
            <summary>
            Allows access to Aim-specific functions.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS4.PS4ControllerExtension">
            <summary>
            Allows access to controller-specific functions.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetAccelerometerValueRaw">
            <summary>
            Gets the raw value from the accelerometer as reported by the device.
            Note: Device coordinate system does not match Unity's.
            </summary>
            <returns>Raw accelerometer data</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetAccelerometerValue">
            <summary>
            Gets the value from the accelerometer converted to Unity's coordinate system.
            The value returned could be thought of as a gravity vector and user acceleration combined.
            If using this value to apply a force in the direction of the vector, invert each axis first.
            This value represents the last value reported by the accelerometer.
            </summary>
            <returns>Accelerometer data</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetLastGyroscopeValueRaw">
            <summary>
            Gets the raw value from the gyroscope as reported by the device.
            Note: Device coordinate system does not match Unity's.
            </summary>
            <returns>Raw gyroscope data</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetLastGyroscopeValue">
            <summary>
            Gets the value from the gyroscope converted to Unity's coordinate system.
            </summary>
            <returns>Gyroscope data</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetOrientationRaw">
            <summary>
            Gets the raw orientation as reported by the device.
            Note: Device coordinate system does not match Unity's.
            </summary>
            <returns>Raw orientation</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.GetOrientation">
            <summary>
            Gets the orientation converted to Unity's coordinate system.
            </summary>
            <returns>Orientation</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.ResetOrientation">
            <summary>
            Resets the orientation.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetMotionSensorState(System.Boolean)">
            <summary>
            Sets the motion sensor state.
            </summary>
            <param name="enabled">The state</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetTiltCorrectionState(System.Boolean)">
            <summary>
            Sets the tilt correction state.
            </summary>
            <param name="enabled">The state</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetAngularVelocityDeadbandState(System.Boolean)">
            <summary>
            Sets the angular velocity deadband state.
            </summary>
            <param name="enabled">The state</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetLightColor(UnityEngine.Color)">
            <summary>
            Sets the light color. Alpha can be used to set intensity.
            Final light color may be modified by the PS4.
            Brigtness cannot be set below a certain value on this platform.
            </summary>
            <param name="color">Light color</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetLightColor(System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            Final light color may be modified by the PS4.
            Brigtness cannot be set below a certain value on this platform.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.SetLightColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the light color.
            Final light color may be modified by the PS4.
            Brigtness cannot be set below a certain value on this platform.
            </summary>
            <param name="red">Red channel [0.0 - 1.0]</param>
            <param name="green">Green channel [0.0 - 1.0]</param>
            <param name="blue">Blue channel [0.0 - 1.0]</param>
            <param name="intensity">Intensity [0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4ControllerExtension.ResetLight">
            <summary>
            Resets the light to the default settings.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.deviceHandle">
            <summary>
            Gets the PS4 device handle.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userStatusCode">
            <summary>
            Gets the PS4 user status code.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userIsPrimary">
            <summary>
            Is this PS4 user the primary user?
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userId">
            <summary>
            Gets the PS4 user id.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userColor">
            <summary>
            Gets the PS4 user color.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userColorId">
            <summary>
            Gets the PS4 user color id.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.userName">
            <summary>
            Gets the PS4 user name.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4ControllerExtension.vibrationMotorCount">
            <summary>
            The number of vibration motors in this controller.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.GetVibration(Rewired.Platforms.PS4.PS4AimMotorType)">
            <summary>
            Gets vibration level for a specific motor.
            </summary>
            <param name="motor">Motor type</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.SetVibration(Rewired.Platforms.PS4.PS4AimMotorType,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.SetVibration(Rewired.Platforms.PS4.PS4AimMotorType,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.SetVibration(Rewired.Platforms.PS4.PS4AimMotorType,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="strongMotorLevel">float: 0.0 - 1.0</param>
            <param name="weakMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4AimExtension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="strongMotorLevel">float: 0.0 - 1.0</param>
            <param name="weakMotorLevel">float: 0.0 - 1.0</param>
            <param name="strongMotorDuration">Length of time in seconds to activate the left motor before it stops. [0 = Infinite]</param>
            <param name="weakMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="T:Rewired.Platforms.PS4.PS4AimMotorType">
            <summary>
            PS4 Aim motors. Used for vibration.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4AimMotorType.StrongMotor">
            <summary>
            Strong motor
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4AimMotorType.WeakMotor">
            <summary>
            Weak motor
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS4.PS4GamepadExtension">
            <summary>
            Allows access to gamepad-specific functions.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetTouchId(System.Int32)">
            <summary>
            Gets the touch id for the touch at the specified index.
            </summary>
            <param name="index">Index of the touch</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetTouchPosition(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetTouchPositionByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id normalized to a 0 - 1 range. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch [0 - 1]</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetTouchPositionAbsolute(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular index in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="index">The index of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at index is currently touching. False if there is no touch at index.</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetTouchPositionAbsoluteByTouchId(System.Int32,UnityEngine.Vector2@)">
            <summary>
            Gets the touch position for a particular touch id in absolute units as returned by the device. (Left = 0, Bottom = 0)
            </summary>
            <param name="touchId">The id of the touch for which to return position.</param>
            <param name="position">X/Y position of the touch in absolute units.</param>
            <returns>True if the touch at touchId is currently touching. False if there is no touch at touchId.</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.IsTouching(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="index">The index of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.IsTouchingByTouchId(System.Int32)">
            <summary>
            Determines if the current touch id is valid for any currently active touch.
            </summary>
            <param name="touchId">The id of the touch</param>
            <returns>True/False</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.GetVibration(Rewired.Platforms.PS4.PS4GamepadMotorType)">
            <summary>
            Gets vibration level for a specific motor.
            </summary>
            <param name="motor">Motor type</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.SetVibration(Rewired.Platforms.PS4.PS4GamepadMotorType,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.SetVibration(Rewired.Platforms.PS4.PS4GamepadMotorType,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.SetVibration(Rewired.Platforms.PS4.PS4GamepadMotorType,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4GamepadExtension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="leftMotorDuration">Length of time in seconds to activate the left motor before it stops. [0 = Infinite]</param>
            <param name="rightMotorDuration">Length of time in seconds to activate the right motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.connectionType">
            <summary>
            Gets the controller connection type as an int.
            This can be cast to UnityEngine.PS4Input.ConnectionType.
            </summary>
            <returns>Connection type as int</returns>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.maxTouches">
            <summary>
            Number of simultaneous touches supported by this device.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.touchpadPixelDensity">
            <summary>
            Gets the pixel density of the touchpad.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.touchpadResolution">
            <summary>
            Gets the touchpad resolution in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.touchpadResolutionX">
            <summary>
            Gets the touchpad X resolution in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.touchpadResolutionY">
            <summary>
            Gets the touchpad Y resolution in pixels.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.PS4.PS4GamepadExtension.touchCount">
            <summary>
            The current touch count.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.PS4.PS4GamepadMotorType">
            <summary>
            PS4 game pad motors. Used for vibration.
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4GamepadMotorType.LeftMotor">
            <summary>
            Left motor (stronger motor)
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4GamepadMotorType.StrongMotor">
            <summary>
            Left motor (stronger motor)
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4GamepadMotorType.RightMotor">
            <summary>
            Right motor (weaker motor)
            </summary>
        </member>
        <member name="F:Rewired.Platforms.PS4.PS4GamepadMotorType.WeakMotor">
            <summary>
            Right motor (weaker motor)
            </summary>
        </member>
        <member name="M:Rewired.Platforms.PS4.PS4InputSource.Joystick.TryGetControllerTypeFromDeviceClass(System.Int32,Rewired.Platforms.PS4.PS4InputSource.Joystick.ControllerType@)">
            <summary>
            This exists because I do not know what the device classes are so I have to parse the string and guess.
            </summary>
        </member>
        <member name="T:Rewired.ReInput">
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
            <summary>
            The main class for accessing all input-related information.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.Reset">
            <summary>
            Completely clears and reinitializes the Input Manager.
            This is equivalent to destroying the Rewired Input Manager and reinstantiating it.
            The current input configuration (Joystick ids, controller assignments, modified Controller Maps) will be reset.
            All stored references to Rewired objects (Player, Joystick, ReInput.ControllerHelper, etc.) will become invalid.
            All event listeners will be cleared.
            </summary>
        </member>
        <member name="F:Rewired.ReInput.currentFrame">
            <summary>
            Frame count for current loop.
            </summary>
        </member>
        <member name="F:Rewired.ReInput.previousFrame">
            <summary>
            Previous frame count for current loop.
            </summary>
        </member>
        <member name="F:Rewired.ReInput.absFrame">
            <summary>
            Total frame count of all update loops combined.
            Valid value starts at 1, not 0.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.PreUpdate(Rewired.UpdateLoopType)">
            <summary>
            This runs in every update loop regardless of whether or not update is allowed in that loop.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.TimeUpdate(Rewired.UpdateLoopType)">
            <summary>
            This runs every Update or FixedUpdate regardless of the Config Vars settings for Rewired.
            This is so tracking Unity variables works even FixedUpdate is not enabled.
            </summary>
            <param name="updateLoop"></param>
        </member>
        <member name="M:Rewired.ReInput.UnityMainThreadUpdate">
            <summary>
            This runs every once every main Unity thread update at the beginning
            of FixedUpdate or Update, whichever runs first.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.ApplicationFocusChanged(System.Boolean)">
            <summary>
            This gets called regardless of whether or not Rewired is initialized.
            Nothing else should be done here except to pass the event to UnityVariableWatcher.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.GetUnityUnscaledDeltaTime_TimeManagerOnly">
            <summary>
            Gets the current value of the Unity unscaled delta time from UnityVariableWatcher.
            This should only be called by TimeManager.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ControllerConnectedEvent">
            <summary>
            Event triggered when a controller is conected.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ControllerPreDisconnectEvent">
            <summary>
            Event triggered just before a controller is disconnected. You can use this event to save controller maps before the controller is removed.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ControllerDisconnectedEvent">
            <summary>
            Event triggered after a controller is disconnected.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.InputSourceUpdateEvent">
            <summary>
            Event triggered before all input sources are updated. Use this event to update the element values Custom Controllers.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.EditorRecompileEvent">
            <summary>
            Event triggered when editor begins recompiling scripts.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.PreShutDownEvent">
            <summary>
            Event triggered immediately before Rewired shuts down.
            Rewired objects are still valid during this event.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ShutDownEvent">
            <summary>
            Event triggered after Rewired shuts down.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.InitializedEvent">
            <summary>
            Event triggered after Rewired initializes.
            Event listeners are never cleared from this event when Rewired is shut down so
            you can subscribe once and receive events every time Rewired initializes.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ApplicationFocusChangedEvent">
            <summary>
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.EarlyUpdateEvent">
            <summary>
            This fires every once every main Unity thread update at the beginning
            of FixedUpdate or Update, whichever runs first.
            This event always executes on the main thread.
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.BeforeTimeManagerUpdateEvent">
            <summary>
            This event fires every update loop before Time Manager updates.
            THIS EVENT IS NOT FED WHEN REWIRED IS RESET OR DESTROYED!
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.UpdateStartedEvent">
            <summary>
            This event fires every update loop before Rewired's core update.
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.UpdateEndedEvent">
            <summary>
            This event fires every update loop after Rewired's core update is finished.
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.LateUpdateEvent">
            <summary>
            This event fires every Unity LateUpdate.
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ApplicationIsFullScreenChangedEvent">
            <summary>
            /// This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.ApplicationRunInBackgroundChangedEvent">
            <summary>
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.TimeScalePauseChangedEvent">
            <summary>
            /// This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.SceneLoadedEvent">
            <summary>
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="E:Rewired.ReInput.EditorPauseChangedEvent">
            <summary>
            This is thread-safe and can be unsubcribed in a destructor.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.players">
            <summary>
            Gets an object that contains all player-related members.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.controllers">
            <summary>
            Gets an object that contains all controller-related members.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.mapping">
            <summary>
            Gets an object that contains all mapping-related members.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.touch">
            <summary>
            Gets an object that contains all touch-related members.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.time">
            <summary>
            Gets an object that provides access to time-related data. This is mostly for time comparisons for button and axis active/inactive time measurement.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.userDataStore">
            <summary>
            Gets the UserDataStore component attached to the Rewired Input Manager if any. Use to access data saving and loading.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.configuration">
            <summary>
            Gets an object that provides access to configuration-related data.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.programVersion">
            <summary>
            Gets the current Rewired version number as a string.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.usingUnityInput">
            <summary>
            Is Unity (fallback) input currently being used to drive input?
            </summary>
        </member>
        <member name="P:Rewired.ReInput.unityJoystickIdentificationRequired">
            <summary>
            Does the current platform require manual joystick identification?
            </summary>
        </member>
        <member name="P:Rewired.ReInput.isReady">
            <summary>
            Is the input system ready?
            </summary>
        </member>
        <member name="P:Rewired.ReInput.id">
            <summary>
            The unique id of the Rewired instance. Every time Rewired is initialized, the id is incremented.
            This is used for version checking on Rewred objects.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.configVars">
            <summary>
            DO NOT CALL THIS FROM A PLUGIN!!!!
            Use pluginConfigVars instead.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.UserData">
            <summary>
            DO NOT CALL THIS FROM A PLUGIN!!!!
            Use pluginConfigVars instead.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.currentUnityFrame">
            <summary>
            The current Unity frame.
            This only updates once per main thread frame in either FixedUpdate or Update, whichever runs first.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.isAllowedEditorWindowFocused">
            <summary>
            Determines if an editor window where input is allowed has focus.
            This does not incorporate whether the Unity Editor has focus.
            It also doesn't incorporate the ignore input when app not in focus stuff.
            </summary>
        </member>
        <member name="T:Rewired.ReInput.ConfigHelper">
            <summary>
            Provides access to time-related data. This is mostly for accurate unscaled time comparisons for button and axis times.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.useXInput">
            <summary>
            Toggles the use of XInput in Windows Standalone and Windows UWP during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.updateLoop">
            <summary>
            Changes the Update Loop setting during runtime. Rewired will be completely reset if this value is changed.
            This can be set to multiple values simultaneously.
            Note: Update is required. Update will be enabled even if you unset the Update flag.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.windowsStandalonePrimaryInputSource">
            <summary>
            Changes the primary input source in Windows Standalone during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.osxStandalonePrimaryInputSource">
            <summary>
            Changes the primary input source in OSX Standalone during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.linuxStandalonePrimaryInputSource">
            <summary>
            Changes the primary input source in Linux Standalone during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.windowsUWPPrimaryInputSource">
            <summary>
            Changes the primary input source in Windows 10 Universal during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.windowsUWPSupportHIDDevices">
            <summary>
            Toggles support for HID devices in Windows UWP. This includes older gamepads, gamepads made for Android, flight controllers, racing wheels,
            etc. In order to use this feature, you must add support for HID gamepads and joysticks to the app manifest file.
            Please see the Special Platform Support -> Windows 10 Universal documentation for details.
            Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.xboxOnePrimaryInputSource">
            <summary>
            Changes the primary input source in Xbox One during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.ps4PrimaryInputSource">
            <summary>
            Changes the primary input source in PS4 during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.webGLPrimaryInputSource">
            <summary>
            Changes the primary input source in WebGL during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.alwaysUseUnityInput">
            <summary>
            Toggles the use of Unity input during runtime. Rewired will be completely reset if this value is changed.
            This is an alias for disableNativeInput.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.disableNativeInput">
            <summary>
            Toggles the use of Unity input during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.nativeMouseSupport">
            <summary>
            Toggles the use of native mouse handling during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.nativeKeyboardSupport">
            <summary>
            Toggles the use of native keyboard handling during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.enhancedDeviceSupport">
            <summary>
            Toggles the use of enhanced device support during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.joystickRefreshRate">
            <summary>
            The joystick refresh rate in frames per second. [0 - 2000] [0 = Default]
            Set this to a higher value if you need higher precision input timing at high frame rates such as for a music beat game. Higher values result in higher CPU usage. Note that setting this to a very high value when the game is running at a low frame rate will not result in higher precision input.
            This settings only applies to input sources that use a separate thread to poll for joystick input values (currently XInput and Direct Input). This setting does not apply to event-based input sources such as Raw Input.
            This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.ignoreInputWhenAppNotInFocus">
            <summary>
            Ignores input if the application is not in focus This setting has no effect on some platforms.
            NOTE: Disabling this does not guarantee that input will be processed when the application is out of focus.
            Whether input is received by the application or not is dependent on A) the input device type B) the current platform C) the input source(s) being used.
            This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.android_supportUnknownGamepads">
            <summary>
            Toggles the support of unknown gamepads on the Android platform during runtime. Rewired will be completely reset if this value is changed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.defaultJoystickAxis2DDeadZoneType">
            <summary>
            Changes the default dead zone type for 2D joystick axes for recognized controllers. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.defaultJoystickAxis2DSensitivityType">
            <summary>
            Changes the default sensitivity type for 2D joystick axes for recognized controllers. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.defaultAxisSensitivityType">
            <summary>
            Changes the default axis sensitivity type for axes. This setting can be changed without resetting Rewired.
            Changing this setting will not change the AxisSensitivityType on Controllers already connected during the game session.
            It will also not change the AxisSensitivityType in saved user data that is loaded.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.force4WayHats">
            <summary>
            Force all 8-way hats on recognized joysticks to be treated as 4-way hats.
            If enabled, the corner directions on all hats will activate the adjacent 2 cardinal direction buttons instead of the corner button.
            This is useful if you need joystick hats to behave like D-Pads instead of 8-way hats.
            This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.defaultAbsoluteAxisPollingDeadZone">
            <summary>
            The default polling dead zone used when polling Absolute coordinate mode axes.
            In order for the axis to be detected when polling, the change in absolute value
            of the axis over the polling period must be greater than this amount.
            Do not set this value too low or noisy axes will be detected.
            This only applies to axes that use an Absolute coordinate system such as joysticks.
            Each indivisual axis may override this default value.
            [Default = 0.7]
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.defaultRelativeAxisPollingDeadZone">
            <summary>
            The default polling dead zone used when polling Relative coordinate mode axes.
            In order for the axis to be detected when polling, the change in absolute value
            of the axis over the polling period must be greater than this amount.
            Do not set this value too low or noisy axes will be detected.
            This only applies to axes that use a Relative coordinate system such as mouse axes.
            Each indivisual axis may override this default value.
            [Default = 100]
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.activateActionButtonsOnNegativeValue">
            <summary>
            Determines how button values are calculated by Player Actions.
            If enabled, Actions with either a negative or positive Axis value will return True when queried with player.GetButton.
            If disabled, Actions with a negative Axis value will always return False when queried with player.GetButton, and must be queried with player.GetNegativeButton.
            This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.throttleCalibrationMode">
            <summary>
            Determines how throttles on recognized controllers are calibrated.
            By default, throttles are calibrated for a range of 0 to +1. This is suitable for most flight and racing games.
            Some games may require a range of -1 to +1 such as space flight games where a negative value denotes a reverse thrust.
            Changing this setting will revert all throttle calibrations to the default values for the chosen calibration mode.
            This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.deferControllerConnectedEventsOnStart">
            <summary>
            Defer controller connected events for controllers already connected when Rewired initializes until the Start event instead of
            during initialization. Normally, it's impossible to receive controller connection events at the start of runtime because Rewired
            initializes before any other script is able to subscribe to the controller connected event. Enabling this will defer the controller
            connected events until the Start event, allowing your scripts to subscribe to the controller connected event in Awake and still
            receive the event callback. If disabled, controller connection events for controllers already connected before runtime starts will be missed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.autoAssignJoysticks">
            <summary>
            Toggles joystick auto-assignment during runtime. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.maxJoysticksPerPlayer">
            <summary>
            Set the max number of joysticks assigned to each Player by joystick auto-assignment during runtime. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.distributeJoysticksEvenly">
            <summary>
            Toggles even joystick auto-assignment distribution among Players during runtime. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.assignJoysticksToPlayingPlayersOnly">
            <summary>
            Toggles even joystick auto-assignment to Players with isPlayer = True only during runtime. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.reassignJoystickToPreviousOwnerOnReconnect">
            <summary>
            Toggles joystick auto-reassignment when re-connected to the last owning Player during runtime. This setting can be changed without resetting Rewired.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ConfigHelper.logLevel">
            <summary>
            Determines the level of internal logging.
            </summary>
        </member>
        <member name="T:Rewired.ReInput.ControllerHelper">
            <summary>
            Provides access to all controller-related members.
            </summary>
        </member>
        <member name="F:Rewired.ReInput.ControllerHelper.polling">
            <summary>
            Provides access to controller element polling-related members.
            This should only be used for controller mapping or other non-gameplay-related code.
            The polling system is expensive and should not be used during gameplay.
            </summary>
        </member>
        <member name="F:Rewired.ReInput.ControllerHelper.conflictChecking">
            <summary>
            Provides access to Controller Map conflict checking-related members.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetController``1(System.Int32)">
            <summary>
            Gets a controller of type by id.
            </summary>
            <typeparam name="T">Type of Controller</typeparam>
            <param name="controllerId">The controller id</param>
            <returns>A controller of type T</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetControllerCount(Rewired.ControllerType)">
            <summary>
            Gets the number of controllers that exist of a specific type.
            </summary>
            <param name="controllerType">Type of controller</param>
            <returns>Number of controllers of a specific type</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetController(Rewired.ControllerType,System.Int32)">
            <summary>
            Gets a controller of a specific type with a specific id.
            </summary>
            <param name="controllerType">Type of controller</param>
            <param name="controllerId">Controller id</param>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetController(Rewired.ControllerIdentifier)">
            <summary>
            Gets a controller that matches a Controller Idnetifier.
            </summary>
            <param name="controllerIdentifier">Controller Identifier</param>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetControllers(Rewired.ControllerType)">
            <summary>
            Get a collection of connected controllers.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>An array of all Controllers of this type</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetControllerNames(Rewired.ControllerType)">
            <summary>
            Get an array of connected controller names.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>An array of the names of all controllers of this type</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsControllerAssigned(Rewired.ControllerType,Rewired.Controller)">
            <summary>
            Is the specified controller assigned to any players?
            </summary>
            <param name="controllerType">Type of controller</param>
            <param name="controller">The controller</param>
            <returns>Boolean determining whether this controller is assigned to any player</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsControllerAssigned(Rewired.ControllerType,System.Int32)">
            <summary>
            Is the specified controller assigned to any players?
            </summary>
            <param name="controllerType">Type of controller</param>
            <param name="controllerId">Id of the controller</param>
            <returns>Boolean determining whether this controller is assigned to any player</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsControllerAssignedToPlayer(Rewired.ControllerType,System.Int32,System.Int32)">
            <summary>
            Is the specified controller assigned to the specified player?
            </summary>
            <param name="controllerType">Type of controller</param>
            <param name="controllerId">Id of the controller</param>
            <param name="playerId">Id of the player</param>
            <returns>Boolean determining whether this controller is assigned to the player</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveControllerFromAllPlayers(Rewired.Controller,System.Boolean)">
            <summary>
            De-assigns the specified controller from all players.
            </summary>
            <param name="controller">The controller</param>
            <param name="includeSystemPlayer">Do we de-assign from the System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveControllerFromAllPlayers(Rewired.ControllerType,System.Int32,System.Boolean)">
            <summary>
            De-assigns the specified controller from all players.
            </summary>
            <param name="controllerType">Tyoe of the controller</param>
            <param name="controllerId">Id of the controller</param>
            <param name="includeSystemPlayer">Do we de-assign from the System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetJoystick(System.Int32)">
            <summary>
            Gets a specific joystick.
            </summary>
            <param name="joystickId">The id of the joystick</param>
            <returns>The Joystick</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetJoysticks">
            <summary>
            Gets a collection of connected joysticks.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>Array of Joysticks</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetJoystickNames">
            <summary>
            Gets an array of connected joystick names.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>Array of joystick names</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsJoystickAssigned(Rewired.Joystick)">
            <summary>
            Is a specific Joystick assigned to any players?
            </summary>
            <param name="joystick">The Joystick</param>
            <returns>Boolean determining if the specified joystick is assigned to any players</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsJoystickAssigned(System.Int32)">
            <summary>
            Is a specific Joystick assigned to any players?
            </summary>
            <param name="joystickId">Id of the Joystick</param>
            <returns>Boolean determining if the specified joystick is assigned to any players</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsJoystickAssignedToPlayer(System.Int32,System.Int32)">
            <summary>
            Is a specific Joystick assigned to a specific player?
            </summary>
            <param name="joystickId">Id of the Joystick</param>
            <param name="playerId">Id of the Player</param>
            <returns>Boolean determining if the specified joystick is assigned to the specified player</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveJoystickFromAllPlayers(Rewired.Joystick,System.Boolean)">
            <summary>
            De-assigns a specific Joystick from all Players
            </summary>
            <param name="joystick">The Joystick</param>
            <param name="includeSystemPlayer">De-assign from System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveJoystickFromAllPlayers(System.Int32,System.Boolean)">
            <summary>
            De-assigns a specific Joystick from all Players
            </summary>
            <param name="joystickId">Id of the Joystick</param>
            <param name="includeSystemPlayer">De-assign from System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetUnityJoystickIdFromAnyButtonPress">
            <summary>
            Returns the 0 based id of the Unity joystick whose button was pressed. -1 if no button was pressed on any joystick.
            Use this to identify joysticks when using Unity's input system.
            This has no effect if Unity Input is not handling input on the current platform.
            </summary>
            <returns>0-based index of the Unity joystick whose button was pressed</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetUnityJoystickIdFromAnyButtonOrAxisPress(System.Single,System.Boolean)">
            <summary>
            Returns the 0 based id of the Unity joystick whose button or axis was pressed. -1 if no button or axis was pressed on any joystick.
            Use this to identify joysticks when using Unity's input system.
            This has no effect if Unity Input is not handling input on the current platform.
            </summary>
            <returns>0-based index of the Unity joystick whose button or axis was pressed</returns>
            <param name="axisThreshold">Any axis value below this threshold will be ignored.</param>
            <param name="positiveAxesOnly">Ignore negative axis values.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.SetUnityJoystickId(System.Int32,System.Int32)">
            <summary>
            Sets a Unity joystick as the input source of a Joystick.
            Use this to remap a joystick to its source when reconnected on platforms that use Unity Input.
            This has no effect if Unity Input is not handling input on the current platform.
            </summary>
            <param name="joystickId">The id of the Joystick whose input source you are remapping.</param>
            <param name="unityJoystickId">The 0 based index of the Unity joystick which will become the Joystick's new input source.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.SetUnityJoystickIdFromAnyButtonPress(System.Int32)">
            <summary>
            Sets a Unity joystick as the input source of a Joystick.
            The first Unity joystick that returns a button press will be assigned to the Joystick.
            While no buttons are pressed, this will return False. When a button press is detected, it will return True and assign the joystick id.
            </summary>
            <param name="joystickId">The id of the Joystick</param>
            <returns>True if a joystick button was pressed and a joystick id was assigned.</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.SetUnityJoystickIdFromAnyButtonOrAxisPress(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets a Unity joystick as the input source of a Joystick.
            The first Unity joystick that returns a button or axis press will be assigned to the Joystick.
            While no buttons or axes are pressed, this will return False. When a press is detected, it will return True and assign the joystick id.
            </summary>
            <param name="joystickId">The id of the Joystick</param>
            <returns>True if a joystick button was pressed and a joystick id was assigned.</returns>
            <param name="axisThreshold">Any axis value below this threshold will be ignored.</param>
            <param name="positiveAxesOnly">Ignore negative axis values.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetCustomController(System.Int32)">
            <summary>
            Gets a specific custom controller
            </summary>
            <param name="customControllerId">The id of the custom controller</param>
            <returns>The Custom Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetCustomControllers">
            <summary>
            Get a collection of connected custom controllers.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>CustomController[]</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetCustomControllerNames">
            <summary>
            Get an array of connected custom controller names.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <returns>string[]</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsCustomControllerAssigned(Rewired.CustomController)">
            <summary>
            Is a specific Custom Controller assigned to any players?
            </summary>
            <param name="customController">The Custom Controller</param>
            <returns>Boolean determining if the specified custom controller is assigned to any players</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsCustomControllerAssigned(System.Int32)">
            <summary>
            Is a specific Custom Controller assigned to any players?
            </summary>
            <param name="customControllerId">Id of the Custom Controller</param>
            <returns>Boolean determining if the specified custom controller is assigned to any players</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.IsCustomControllerAssignedToPlayer(System.Int32,System.Int32)">
            <summary>
            Is a specific Custom Controller assigned to a specific player?
            </summary>
            <param name="customControllerId">Id of the Custom Controller</param>
            <param name="playerId">Id of the Player</param>
            <returns>Boolean determining if the specified custom controller is assigned to the specified player</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveCustomControllerFromAllPlayers(Rewired.CustomController,System.Boolean)">
            <summary>
            De-assigns a specific Custom Controller from all Players
            </summary>
            <param name="customController">The Custom Controller</param>
            <param name="includeSystemPlayer">De-assign from System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveCustomControllerFromAllPlayers(System.Int32,System.Boolean)">
            <summary>
            De-assigns a specific Custom Controller from all Players
            </summary>
            <param name="customControllerId">Id of the Custom Controller</param>
            <param name="includeSystemPlayer">De-assign from System player also?</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.CreateCustomController(System.Int32)">
            <summary>
            Create a new CustomController object from a source definition in the Rewired Input Manager.
            </summary>
            <param name="sourceControllerId">Source id of the CustomController definition</param>
            <returns>CustomController</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.CreateCustomController(System.Int32,System.String)">
            <summary>
            Create a new CustomController object from a source definition in the Rewired Input Manager.
            </summary>
            <param name="sourceControllerId">Source id of the CustomController definition</param>
            <param name="tag">Tag to assign</param>
            <returns>CustomController</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.DestroyCustomController(Rewired.CustomController)">
            <summary>
            Destroys a CustomController.
            </summary>
            <param name="customController">The Custom Controller</param>
            <returns>Sucess/fail</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetFirstCustomControllerWithSourceId(System.Int32)">
            <summary>
            Finds the first CustomController that has a matching source id.
            </summary>
            <param name="sourceId">Source id of the CustomController definition</param>
            <returns>CustomController</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetFirstCustomControllerWithTag(System.String)">
            <summary>
            Finds the first CustomController that has a matching tag.
            </summary>
            <param name="tag">Tag of the CustomController</param>
            <returns>CustomController</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.CustomControllersWithSourceId(System.Int32)">
            <summary>
            Enumerates all CustomControllers with a matching source id.
            </summary>
            <param name="sourceId">Source id of the CustomController definition</param>
            <returns>CustomControllers enumeration</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.CustomControllersWithTag(System.String)">
            <summary>
            Enumerates all CustomControllers with a matching tag.
            </summary>
            <param name="tag">Tag of the CustomController</param>
            <returns>CustomControllers enumeration</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetControllerTemplates``1">
            <summary>
            Gets a list of all Controller Templates in connected Controllers that match the type.
            </summary>
            <typeparam name="TInterface">Controller Template interface type. Note: You must use the interface of the Controller Template and not the concrete class.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetLastActiveController">
            <summary>
            Get the last controller that produced input.
            If there is no last active controller, the Keyboard will be returned.
            </summary>
            <returns>Last active Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetLastActiveController(Rewired.ControllerType)">
            <summary>
            Get the last controller that produced input.
            If there is no last active controller of the specified type, the return value will be null.
            </summary>
            <param name="controllerType">The controller type.</param>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetLastActiveController``1">
            <summary>
            Get the last controller that produced input.
            If there is no last active controller of the specified type, the return value will be null.
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <returns>Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetLastActiveControllerType">
            <summary>
            Get the controller type of the last controllerthat produced input.
            If there is no last active controller, ControllerType.Keyboard is returned.
            </summary>
            <returns>Last active Controller</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.AddLastActiveControllerChangedDelegate(Rewired.ActiveControllerChangedDelegate)">
            <summary>
            Add a delegate to receive a callback every time the last active controller changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.AddLastActiveControllerChangedDelegate(Rewired.ActiveControllerChangedDelegate,Rewired.ControllerType)">
            <summary>
            Add a delegate to receive a callback every time the last active controller of a specific type changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="controllerType">The controller type for which to listen for changes.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveLastActiveControllerChangedDelegate(Rewired.ActiveControllerChangedDelegate)">
            <summary>
            Remove a delegate to no longer receive callbacks when the last active controller changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.RemoveLastActiveControllerChangedDelegate(Rewired.ActiveControllerChangedDelegate,Rewired.ControllerType)">
            <summary>
            Remove a delegate to no longer receive callbacks when the last active controller of a specific type changes.
            </summary>
            <param name="callback">The delegate that will be called.</param>
            <param name="controllerType">The controller type for which to listen for changes.</param>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.ClearLastActiveControllerChangedDelegates">
            <summary>
            Remove all delegates to no longer receive any callbacks when the last active controller changes.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButton">
            <summary>
            Get the button held state of all buttons on all controllers. Returns TRUE if any button is held.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <returns>Button held state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButton(Rewired.ControllerType)">
            <summary>
            Get the button held state of all buttons on all controllers of a specified type. Returns TRUE if any button is held.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>Button held state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonDown">
            <summary>
            Get the button just pressed state of all buttons on all controllers. This will only return TRUE only on the first frame a button is pressed.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <returns>Button just pressed state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonDown(Rewired.ControllerType)">
            <summary>
            Get the button just pressed state of all buttons on all controllers of a specified type. This will only return TRUE only on the first frame a button is pressed.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>Button just pressed state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonUp">
            <summary>
            Get the button just released state of all buttons on all controllers of a specified type. This will only return TRUE only on the first frame a button is released.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <returns>Button just released state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonUp(Rewired.ControllerType)">
            <summary>
            Get the button just released state of all buttons on all controllers of a specified type. This will only return TRUE only on the first frame a button is released.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>Button just released state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonChanged">
            <summary>
            Returns true if any button has changed state from the previous frame to the current.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <returns>Button changed state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonChanged(Rewired.ControllerType)">
            <summary>
            Returns true if any button has changed state from the previous frame to the current.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>Button changed state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonPrev">
            <summary>
            Get the previous button held state of all buttons on all controllers. Returns TRUE if any button was held in the previous frame.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <returns>Previous button held state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.GetAnyButtonPrev(Rewired.ControllerType)">
            <summary>
            Get the previous button held state of all buttons on all controllers of a specified type. Returns TRUE if any button was held in the previous frame.
            This retrieves the value from the actual hardware buttons, not Actions as mapped by Controller Maps in Player.
            </summary>
            <param name="controllerType">Controller type</param>
            <returns>Previous button held state</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.AutoAssignJoystick(Rewired.Joystick)">
            <summary>
            Auto-assigns a Joystick to a Player based on the joystick auto-assignment settings in the Rewired Input Manager.
            If the Joystick is already assigned to a Player, the Joystick will not be re-assigned.
            </summary>
            <param name="joystick">Joystick to assign to a Player.</param>
            <returns>True if the Joystick was assigned to a Player.</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.AutoAssignJoysticks">
            <summary>
            Auto-assigns all unassigned Joysticks to Players based on the joystick auto-assignment settings in the Rewired Input Manager.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.controllerCount">
            <summary>
            The number of controllers of all types currently connected.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.Controllers">
            <summary>
            Gets a collection of connected controllers of all types.
            </summary>
            <returns>IList of Controller</returns>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.Mouse">
            <summary>
            Gets the primary Mouse controller.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.Keyboard">
            <summary>
            Gets the primary Keyboard controller.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.keyboardEnabled">
            <summary>
            Enabled or disables keyboard input processing. Disabling keyboard input can improve performance on mobile devices.
            Also useful for joystick games on Android where certain joystick buttons return keyboard keycodes. Disabling keyboard input on Android will
            still allow certain keyboard keys to return values if triggered by a button press on a joystick, but no keyboard maps will ever be processed.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.joystickCount">
            <summary>
            The number of joysticks currently connected.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.Joysticks">
            <summary>
            Get a collection of connected joysticks.
            </summary>
            <returns>List of Joysticks</returns>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.customControllerCount">
            <summary>
            The number of custom controllers
            </summary>
        </member>
        <member name="P:Rewired.ReInput.ControllerHelper.CustomControllers">
            <summary>
            Get a collection of connected custom controllers.
            </summary>
            <returns>List of Custom Controllers</returns>
        </member>
        <member name="T:Rewired.ReInput.ControllerHelper.PollingHelper">
            <summary>
            Provides access to controller element polling-related members.
            This should only be used for controller mapping or other non-gameplay-related code.
            The polling system is expensive and should not be used during gameplay.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.PollingHelper.PollAllControllersForFirstElement">
            <summary>
            Poll every connected controller and gets information about the first element that is activated.
            Does not return Player information. If you need information about the Player, poll through Player instead.
            </summary>
            <returns>ControllerPollingInfo</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.PollingHelper.PollAllControllersForAllElements">
            <summary>
            Poll every connected controller and gets information about all elements that are activated.
            Does not return Player information. If you need information about the Player, poll through Player instead.
            </summary>
            <returns>IEnumerable of ControllerPollingInfo</returns>
        </member>
        <member name="M:Rewired.ReInput.ControllerHelper.PollingHelper.PollAllCustomControllersForFirstElement">
            <summary>
            Poll every connected customController and get information about the first element that is activated.
            Does not return Player information. If you need information about the Player, poll through Player instead.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Rewired.ReInput.MappingHelper">
            <summary>
            Provides access to all mapping-related data defined in the Rewired Editor.
            This data is read-only. Data created in the Rewired Editor cannot be changed at run time.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMapCategory(System.Int32)">
            <summary>
            Gets a specific map category
            </summary>
            <param name="mapCategoryId">Map Category id</param>
            <returns>Map Category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMapCategory(System.String)">
            <summary>
            Gets a specific map category
            </summary>
            <param name="name">Map Category name</param>
            <returns>Map Category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMapCategoryId(System.String)">
            <summary>
            Gets id of a specific map category
            </summary>
            <param name="name">Map Category name</param>
            <returns>Map Category id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.MapCategoriesWithTag(System.String)">
            <summary>
            Enumerates all map categories with matching tag
            </summary>
            <param name="tag">Tag</param>
            <returns>IEnumerable of Map Categories with tag</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableMapCategoriesWithTag(System.String)">
            <summary>
            Enumerates all user-assignable map categories with matching tag
            </summary>
            <param name="tag">Tag</param>
            <returns>IEnumerable of user-assignable Map Categories with tag</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.IsMapCategoryUserAssignable(System.Int32)">
            <summary>
            Is the specified map category user assignable?
            </summary>
            <param name="mapCategoryId">Map Category id</param>
            <returns>True = is user assignable</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetActionCategory(System.Int32)">
            <summary>
            Gets a specific action category
            </summary>
            <param name="mapCategoryId">Action Category id</param>
            <returns>Action Category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetActionCategory(System.String)">
            <summary>
            Gets a specific action category
            </summary>
            <param name="name">Action Category name</param>
            <returns>Action Category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetActionCategoryId(System.String)">
            <summary>
            Gets the id of a specific action category
            </summary>
            <param name="name">Action Category name</param>
            <returns>Id of the Action Category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionCategoriesWithTag(System.String)">
            <summary>
            Enumerates all action categories with matching tag
            </summary>
            <param name="tag">Tag</param>
            <returns>IEnumerable of Action Categories with tag</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableActionCategoriesWithTag(System.String)">
            <summary>
            Enumerates all user-assignable action categories with matching tag
            </summary>
            <param name="tag">Tag</param>
            <returns>IEnumerable of user-assignable Action Categories with tag</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.IsActionCategoryUserAssignable(System.Int32)">
            <summary>
            Is the specified action category user-assignable?
            </summary>
            <param name="mapCategoryId">Action Category id</param>
            <returns>True = is user assignable</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetLayout(Rewired.ControllerType,System.Int32)">
            <summary>
            Gets a layout by specifying the controller type and layout id
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="layoutId">Layout id</param>
            <returns>Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetLayout(Rewired.ControllerType,System.String)">
            <summary>
            Gets a layout by specifying the controller type and layout name
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="name">Layout name</param>
            <returns>Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetLayoutId(Rewired.ControllerType,System.String)">
            <summary>
            Gets id of a layout by controller type
            </summary>
            <param name="controllerType">Controller type</param>
            <param name="name">Layout name</param>
            <returns>Layout id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickLayout(System.Int32)">
            <summary>
            Gets a joystick layout
            </summary>
            <param name="layoutId">Layout id</param>
            <returns>Joystick Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickLayout(System.String)">
            <summary>
            Gets a joystick layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Joystick Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickLayoutId(System.String)">
            <summary>
            Gets the id of a joystick layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Joystick Layout id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardLayout(System.Int32)">
            <summary>
            Gets a keyboard layout
            </summary>
            <param name="layoutId">Layout id</param>
            <returns>Keyboard Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardLayout(System.String)">
            <summary>
            Gets a keyboard layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Keyboard layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardLayoutId(System.String)">
            <summary>
            Gets the id of a keyboard layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Keyboard Layout id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseLayout(System.Int32)">
            <summary>
            Get a mouse layout
            </summary>
            <param name="layoutId">Layout id</param>
            <returns>Mouse Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseLayout(System.String)">
            <summary>
            Gets a mouse layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Mouse Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseLayoutId(System.String)">
            <summary>
            Gets the id of a mouse layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Mouse Layout id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerLayout(System.Int32)">
            <summary>
            Gets a custom controller layout
            </summary>
            <param name="layoutId">Layout id</param>
            <returns>Custom Controller Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerLayout(System.String)">
            <summary>
            Gets a custom controller layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Custom Controller Layout</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerLayoutId(System.String)">
            <summary>
            Gets the id of a custom controller layout
            </summary>
            <param name="name">Layout name</param>
            <returns>Custom Controller id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.MapLayouts(Rewired.ControllerType)">
            <summary>
            Gets a list of all map layouts for the specified controller type
            </summary>
            <param name="controllerType">Type of controller</param>
            <returns>List of map layouts</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetAction(System.Int32)">
            <summary>
            Gets a specific action
            </summary>
            <param name="actionId">Action id</param>
            <returns>Action</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetAction(System.String)">
            <summary>
            Gets a specific action
            </summary>
            <param name="name">Action name</param>
            <returns>Action</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetActionId(System.String)">
            <summary>
            Gets the id of a specific action
            </summary>
            <param name="name">Action name</param>
            <returns>Action id</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionsInCategory(System.String)">
            <summary>
            Enumerates all actions in a specific category
            </summary>
            <param name="mapCategoryName">Category name</param>
            <returns>IEnumerable of actions in category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionsInCategory(System.String,System.Boolean)">
            <summary>
            Enumerates all actions in a specific category
            </summary>
            <param name="mapCategoryName">Category name</param>
            <param name="sort">Sorts results as shown in Rewired Input Manager</param>
            <returns>IEnumerable of actions in category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionsInCategory(System.Int32)">
            <summary>
            Enumerates all actions in a specific category
            </summary>
            <param name="mapCategoryId">Caregory id</param>
            <returns>IEnumerable of actions in category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionsInCategory(System.Int32,System.Boolean)">
            <summary>
            Enumerates all actions in a specific category
            </summary>
            <param name="mapCategoryId">Caregory id</param>
            <param name="sort">Sorts results as shown in Rewired Input Manager</param>
            <returns>IEnumerable of actions in category</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.ActionsInCategoriesWithTag(System.String)">
            <summary>
            Enumerates all actions with a tag
            </summary>
            <param name="tag">Tag</param>
            <returns>IEnumerable of actions with tag</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableActionsInCategory(System.Int32)">
            <summary>
            Enumerates all user-assignable actions in a specific category
            </summary>
            <param name="mapCategoryId">Category id</param>
            Enumerates all user-assignable actions in a specific category
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableActionsInCategory(System.Int32,System.Boolean)">
            <summary>
            Enumerates all user-assignable actions in a specific category
            </summary>
            <param name="mapCategoryId">Category id</param>
            <param name="sort">Sorts results as shown in Rewired Input Manager</param>
            Enumerates all user-assignable actions in a specific category
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableActionsInCategory(System.String)">
            <summary>
            Enumerates all user-assignable actions in a specific category
            </summary>
            <param name="mapCategoryName">Category name</param>
            Enumerates all user-assignable actions in a specific category
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.UserAssignableActionsInCategory(System.String,System.Boolean)">
            <summary>
            Enumerates all user-assignable actions in a specific category
            </summary>
            <param name="mapCategoryName">Category name</param>
            <param name="sort">Sorts results as shown in Rewired Input Manager</param>
            Enumerates all user-assignable actions in a specific category
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetInputBehaviors(System.Int32)">
            <summary>
            Gets a list of input behaviors from a specific player
            </summary>
            <param name="playerId">Player id</param>
            <returns>List of input behaviors from the player</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetSystemPlayerInputBehaviors">
            <summary>
            Gets a list of input behaviors from the system player
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetInputBehavior(System.Int32,System.Int32)">
            <summary>
            Gets a specific input behavior from a specific player
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorId">Input Behavior id</param>
            <returns>Input Behavior from the player</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetInputBehavior(System.Int32,System.String)">
            <summary>
            Gets a specific input behavior from a specific player
            </summary>
            <param name="playerId">Player id</param>
            <param name="behaviorName">Input Behavior name</param>
            <returns>Input Behavior from the player</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetSystemPlayerInputBehavior(System.Int32)">
            <summary>
            Gets a specific input behavior from the System player
            </summary>
            <param name="behaviorId">Input Behavior id</param>
            <returns>Input Behavior from the System player</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetSystemPlayerInputBehavior(System.String)">
            <summary>
            Gets a specific input behavior from the System player
            </summary>
            <param name="behaviorName">Input Behavior name</param>
            <returns>Input Behavior from the System player</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetInputBehaviorId(System.String)">
            <summary>
            Gets the id of a specific input behavior
            </summary>
            <param name="behaviorName">Input Behavior name</param>
            <returns></returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMap(System.Int32)">
            <summary>
            Gets the Controller Map with the specified id from
            existing Controller Maps loaded in all Players.
            </summary>
            <param name="id">The unique id of the Controller Map.</param>
            <returns>Controller Map with the specified id.</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetActionElementMap(System.Int32)">
            <summary>
            Gets the Action Element Map with the specified id from
            existing Action Element Maps in all Players.
            </summary>
            <param name="id">The unique id of the Action Element Map.</param>
            <returns>Action Element Map with the specified id.</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstance(Rewired.Controller,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the default Controller Map setup in the Rewired Input Manager.
            </summary>
            <param name="controller">Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstance(Rewired.Controller,System.String,System.String)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the default Controller Map setup in the Rewired Input Manager.
            </summary>
            <param name="controller">Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstance(Rewired.ControllerIdentifier,System.String,System.String)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the default Controller Map setup in the Rewired Input Manager.
            This overload can be used when no Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstance(Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the default Controller Map setup in the Rewired Input Manager.
            This overload can be used when no Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(Rewired.Joystick,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Joystick Map.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            </summary>
            <param name="joystick">Joystick for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(Rewired.Joystick,System.String,System.String)">
            <summary>
            Gets a copy of a Joystick Map.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            </summary>
            <param name="joystick">Joystick for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(System.Guid,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a joystick map from the default controller maps.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="joystickTypeGuid">Joystick GUID for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(System.Guid,System.String,System.String)">
            <summary>
            Gets a copy of a joystick map from the default controller maps.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="joystickTypeGuid">Joystick GUID for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a joystick map from the default controller maps.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstance(Rewired.ControllerIdentifier,System.String,System.String)">
            <summary>
            Gets a copy of a joystick map from the default controller maps.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default Joystick Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardMapInstance(System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Keyboard Map.
            This can be used to view the default Keyboard Map setup in the Rewired Input Manager.
            </summary>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Keyboard Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardMapInstance(System.String,System.String)">
            <summary>
            Gets a copy of a Keyboard Map.
            This can be used to view the default Keyboard Map setup in the Rewired Input Manager.
            </summary>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Keyboard Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseMapInstance(System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Mouse Map.
            This can be used to view the default Mouse Map setup in the Rewired Input Manager.
            </summary>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Mouse Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseMapInstance(System.String,System.String)">
            <summary>
            Gets a copy of a Mouse Map.
            This can be used to view the default Mouse Map setup in the Rewired Input Manager.
            </summary>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Mouse Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstance(Rewired.CustomController,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Custom Controller Map.
            This can be used to view the default Custom Controller Map setup in the Rewired Input Manager.
            </summary>
            <param name="customController">Custom Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>CustomController Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstance(Rewired.CustomController,System.String,System.String)">
            <summary>
            Gets a copy of a Custom Controller Map.
            This can be used to view the default Custom Controller Map setup in the Rewired Input Manager.
            </summary>
            <param name="customController">Custom Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>CustomController Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstance(Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a custom controller map from the default controller maps.
            This overload can be used when no Custom Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default CustomController Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>CustomController Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstance(Rewired.ControllerIdentifier,System.String,System.String)">
            <summary>
            Gets a copy of a custom controller map from the default controller maps.
            This overload can be used when no Custom Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the default CustomController Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            This method can only be used to load Controller Maps for recognized Controllers. Unrecognized Controllers are not supported.
            </summary>
            <param name="controllerIdentifier">Controller for which to retrieve the map.</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>CustomController Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstanceSavedOrDefault(System.Int32,Rewired.Controller,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controller">Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstanceSavedOrDefault(System.Int32,Rewired.Controller,System.String,System.String)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controller">Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            This overload can be used when no Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controllerIdentifier">The Controller Idenfitier that defines the Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.String,System.String)">
            <summary>
            Gets a copy of a Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            This overload can be used when no Controller is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controllerIdentifier">The Controller Idenfitier that defines the Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstanceSavedOrDefault(System.Int32,Rewired.Joystick,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Joystick Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="joystick">Joystick for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstanceSavedOrDefault(System.Int32,Rewired.Joystick,System.String,System.String)">
            <summary>
            Gets a copy of a Joystick Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="joystick">Joystick for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.Int32,System.Int32)">
            <summary>
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controllerIdentifier">The Controller Idenfitier that defines the Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetJoystickMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.String,System.String)">
            <summary>
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            This overload can be used when no Joystick is actually connected and available to be used to look up the correct Controller Maps to load.
            The Controller Map returned by this method is not guarateed to be consistent with the Controller Map that would be loaded
            were the actual device to be connected. This is due to the fact that different Controller Maps may be loaded depending on the
            actual device connected, properties returned by this device, the current input source(s) in use, and more factors.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            NOTE: Element indices in ActionElementMaps may not match to to a Controller Map created with the actual controller connected.
            Do not rely on ActionElementMap.elementIndex being accurate in Controller Maps returned by this method.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="controllerIdentifier">The Controller Idenfitier that defines the Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Joystick Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstanceSavedOrDefault(System.Int32,Rewired.CustomController,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Custom Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="customController">Custom Controller for which to retrieve the map</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>CustomController Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstanceSavedOrDefault(System.Int32,Rewired.CustomController,System.String,System.String)">
            <summary>
            Gets a copy of a Custom Controller Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="customController">Custom Controller for which to retrieve the map</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>CustomController Map</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.ReInput.MappingHelper.GetCustomControllerMapInstanceSavedOrDefault(System.Int32,Rewired.ControllerIdentifier,System.String,System.String)" -->
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardMapInstanceSavedOrDefault(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Keyboard Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Keyboard Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetKeyboardMapInstanceSavedOrDefault(System.Int32,System.String,System.String)">
            <summary>
            Gets a copy of a Keyboard Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Keyboard Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseMapInstanceSavedOrDefault(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Mouse Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Mouse Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetMouseMapInstanceSavedOrDefault(System.Int32,System.String,System.String)">
            <summary>
            Gets a copy of a Mouse Map.
            This can be used to view the Controller Map saved in user data if available or the default Controller Map setup in the Rewired Input Manager.
            The Controller Map will be first loaded from <see cref="T:Rewired.Data.UserDataStore"/>. If none is found, it will be loaded from the Rewired Input Manager defaults.
            <see cref="T:Rewired.Data.UserDataStore"/> must implement <see cref="T:Rewired.Interfaces.IControllerMapStore"/> or data cannot be loaded from saved user data.
            </summary>
            <param name="playerId">The Player id. This is used when loading from UserDataStore.</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Mouse Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetFirstJoystickTemplateElementIdentifier(Rewired.Joystick,System.Int32)">
            <summary>
            Gets the first template Element Identifier on the first joystick template found that maps to the joystick's Element Identifier.
            NOTE: It is discouraged to use this method as the mapping template system wasn't designed for this use. This method has been added
            as a short-term solution to the problem of trying to identify controller elements as generic Gamepad elements for use in displaying
            visual help to users. A better solution will be available in the future and this method will be deprecated at that time.
            </summary>
            <param name="joystick">The joystick</param>
            <param name="joystickElementIdentifierId">The joystick element identifier id.</param>
            <returns>ControllerElementIdentifier</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetFirstJoystickTemplateElementIdentifier(System.Guid,System.Int32)">
            <summary>
            Gets the first template Element Identifier on the first joystick template found that maps to the joystick's Element Identifier.
            </summary>
            <param name="joystickTypeGuid">The joystick hardware Guid identifier. Get from Joystick.hardwareTypeGuid.</param>
            <param name="joystickElementIdentifierId">The joystick element identifier id.</param>
            <returns>ControllerElementIdentifier</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerTemplateMapInstance(System.Guid,System.Int32,System.Int32)">
            <summary>
            Gets a copy of a Controller Template Map from the default controller maps.
            This can be used to view the default Controller Template Map setup in the Rewired Input Manager.
            </summary>
            <param name="templateTypeGuid">Controller Template type guid</param>
            <param name="mapCategoryId">Map Category Id</param>
            <param name="layoutId">Layout Id</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerTemplateMapInstance(System.Guid,System.String,System.String)">
            <summary>
            Gets a copy of a Controller Template Map from the default controller maps.
            This can be used to view the default Controller Template Map setup in the Rewired Input Manager.
            </summary>
            <param name="templateTypeGuid">Controller Template type guid</param>
            <param name="mapCategoryName">Map Category Name</param>
            <param name="layoutName">Layout Name</param>
            <returns>Controller Map</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapLayoutManagerRuleSetInstance(System.Int32)">
            <summary>
            Gets a copy of the Controller Map Layout Manager Rule Set at the specified id.
            </summary>
            <param name="id">The id of the Controller Map Layout Manager Rule Set.</param>
            <returns>An instance of the Controller Map Layout Manager Rule Set at the specified id.</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapLayoutManagerRuleSetInstance(System.String)">
            <summary>
            Gets a copy of the Controller Map Layout Manager Rule Set with the specified name.
            </summary>
            <param name="name">The name of the Controller Map Layout Manager Rule Set.</param>
            <returns>A copy of the Controller Map Layout Manager Rule Set with the specified name.</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapEnablerRuleSetInstance(System.Int32)">
            <summary>
            Gets a copy of the Controller Map Enabler Rule Set at the specified id.
            </summary>
            <param name="id">The id of the Controller Map Enabler Rule Set.</param>
            <returns>A copy of the Controller Map Enabler Rule Set at the specified id.</returns>
        </member>
        <member name="M:Rewired.ReInput.MappingHelper.GetControllerMapEnablerRuleSetInstance(System.String)">
            <summary>
            Gets a copy of the Controller Map Enabler Rule Set with the specified name.
            </summary>
            <param name="name">The name of the Controller Map Enabler Rule Set.</param>
            <returns>A copy of the Controller Map Enabler Rule Set with the specified name.</returns>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.MapCategories">
            <summary>
            Gets list of all map categories
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.UserAssignableMapCategories">
            <summary>
            Enumerates all user-assignable map categories
            </summary>
            <returns>IEnumerable of user-assignable Map Categories</returns>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.ActionCategories">
            <summary>
            Gets list of all action categories
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.UserAssignableActionCategories">
            <summary>
            Enumerates all user-assignable action categories
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.JoystickLayouts">
            <summary>
            Gets a list of all joystick layouts
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.KeyboardLayouts">
            <summary>
            Gets a list of all keyboard layouts
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.MouseLayouts">
            <summary>
            Gets a list of all mouse layouts
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.CustomControllerLayouts">
            <summary>
            Gets a list of all custom controller layouts
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.Actions">
            <summary>
            Gets a list of all actions
            </summary>
        </member>
        <member name="P:Rewired.ReInput.MappingHelper.UserAssignableActions">
            <summary>
            Enumerates all user-assignable actions
            </summary>
        </member>
        <member name="T:Rewired.ReInput.PlayerHelper">
            <summary>
            Provides access to all player-related members.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayers(System.Boolean)">
            <summary>
            Gets a list of Players.
            </summary>
            <param name="includeSystemPlayer">Optionally include the System player</param>
            <returns>Player collection</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayer(System.Int32)">
            <summary>
            Gets a Player at a specific id
            </summary>
            <param name="playerId">The id of the player</param>
            <returns>Player with id</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayer(System.String)">
            <summary>
            Gets a Player by name
            </summary>
            <param name="name">The name of the player</param>
            <returns>Player with name</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetSystemPlayer">
            <summary>
            Gets the System Player
            </summary>
            <returns>The system player</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayerId(System.String)">
            <summary>
            Gets the id of a Player by name
            </summary>
            <param name="playerName">The name of the player</param>
            <returns>Id of the Player</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayerNames(System.Boolean)">
            <summary>
            Gets an array of player names. Optionally includes the System player.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <param name="includeSystemPlayer"></param>
            <returns>Player names</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayerDescriptiveNames(System.Boolean)">
            <summary>
            Gets an array of player descriptive names. Optionally includes the System player.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <param name="includeSystemPlayer"></param>
            <returns>Player descriptive names</returns>
        </member>
        <member name="M:Rewired.ReInput.PlayerHelper.GetPlayerIds(System.Boolean)">
            <summary>
            Gets an array of player ids. Optionally includes System player.
            Allocates an array, so use sparingly to reduce garbage collection.
            </summary>
            <param name="includeSystemPlayer"></param>
            <returns>Player ids</returns>
        </member>
        <member name="P:Rewired.ReInput.PlayerHelper.playerCount">
            <summary>
            Count of Players excluding system player
            </summary>
            <returns>Count of Players excluding system player</returns>
        </member>
        <member name="P:Rewired.ReInput.PlayerHelper.allPlayerCount">
            <summary>
            Count of all players including system player
            </summary>
            <returns>Count of all players including system player</returns>
        </member>
        <member name="P:Rewired.ReInput.PlayerHelper.Players">
            <summary>
            List of all Players excluding System player
            </summary>
            <returns>Player collection excluding the system player</returns>
        </member>
        <member name="P:Rewired.ReInput.PlayerHelper.AllPlayers">
            <summary>
            List of all Players including System player
            </summary>
            <returns>Player collection including the system player</returns>
        </member>
        <member name="P:Rewired.ReInput.PlayerHelper.SystemPlayer">
            <summary>
            The System player
            </summary>
            <returns>System player</returns>
        </member>
        <member name="T:Rewired.ReInput.TimeHelper">
            <summary>
            Provides access to time-related data. This is mostly for accurate unscaled time comparisons for button and axis times.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.TimeHelper.unscaledDeltaTime">
            <summary>
            Unscaled time since the last update in the current update loop.
            Always use this when doing current time comparisons for button and axis active/inactive times instead of Time.time or Time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.TimeHelper.unscaledTime">
            <summary>
            Current unscaled time since start of the game.
            Always use this when doing current time comparisons for button and axis active/inactive times instead of Time.time or Time.unscaledTime.
            </summary>
        </member>
        <member name="P:Rewired.ReInput.TimeHelper.currentFrame">
            <summary>
            The current frame in the current update loop.
            This value does not match UnityEngine.Time.frameCount.
            </summary>
        </member>
        <member name="T:Rewired.ReInput.TimeManager">
            <summary>
            Manages unscaled time.
            </summary>
        </member>
        <member name="T:Rewired.ReInput.UnityTouch">
            <summary>
            Provides access to touch-related members.
            </summary>
        </member>
        <member name="T:Rewired.ReInput.UnityVariableWatcher">
            <summary>
            Allows accessing Unity variables from another thread.
            Values are retrieved on Update and made available.
            Also provides a way to detect when a value changes.
            </summary>
        </member>
        <member name="M:Rewired.ReInput.UnityVariableWatcher.Update">
            <summary>
            Called in the first of either Update or FixedUpdate every thread frame.
            </summary>
        </member>
        <member name="F:Rewired.InputSources.SDL2.SDL.SDL_EventType.SDL_USEREVENT">
            Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,
            and should be allocated with SDL_RegisterEvents()
        </member>
        <member name="F:Rewired.InputSources.SDL2.SDL.SDL_EventType.SDL_LASTEVENT">
            This last event is only for bounding internal arrays
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_CommonEvent">
            \brief Fields shared by every event
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_WindowEvent">
            \brief Window state change event data (event.window.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_KeyboardEvent">
            \brief Keyboard button event structure (event.key.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_TextEditingEvent">
            \brief Keyboard text editing event structure (event.edit.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_MouseMotionEvent">
            \brief Mouse motion event structure (event.motion.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_MouseButtonEvent">
            \brief Mouse button event structure (event.button.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_MouseWheelEvent">
            \brief Mouse wheel event structure (event.wheel.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_JoyAxisEvent">
            \brief Joystick axis motion event structure (event.jaxis.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_JoyBallEvent">
            \brief Joystick trackball motion event structure (event.jball.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_JoyHatEvent">
            \brief Joystick hat position change event structure (event.jhat.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_JoyButtonEvent">
            \brief Joystick button event structure (event.jbutton.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_JoyDeviceEvent">
            \brief Joystick device event structure (event.jdevice.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_ControllerAxisEvent">
            \brief Game controller axis motion event structure (event.caxis.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_ControllerButtonEvent">
            \brief Game controller button event structure (event.cbutton.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_ControllerDeviceEvent">
            \brief Controller device event structure (event.cdevice.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_TouchFingerEvent">
            \brief Touch finger event structure (event.tfinger.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_MultiGestureEvent">
            \brief Multiple Finger Gesture Event (event.mgesture.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_DollarGestureEvent">
            \brief Dollar Gesture Event (event.dgesture.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_DropEvent">
            \brief An event used to request a file open by the system (event.drop.*)
                   This event is disabled by default, you can enable it with SDL_EventState()
            \note If you enable this event, you must free the filename in the event.
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_QuitEvent">
            \brief The "quit requested" event
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_OSEvent">
            \brief OS Specific event
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_UserEvent">
            \brief A user-defined event type (event.user.*)
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_SysWMEvent">
              \brief A video driver dependent system event (event.syswm.*)
                     This event is disabled by default, you can enable it with SDL_EventState()
            
              \note If you want to use this event, you should include SDL_syswm.h.
        </member>
        <member name="T:Rewired.InputSources.SDL2.SDL.SDL_Event">
            \brief General event structure
        </member>
        <member name="F:Rewired.InputSources.SDL2.SDL.SDL_Scancode.SDL_SCANCODE_A">
              \name Usage page 0x07
            
              These values are from usage page 0x07 (USB keyboard page).
        </member>
        <member name="F:Rewired.InputSources.SDL2.SDL.SDL_Scancode.SDL_SCANCODE_AUDIONEXT">
              \name Usage page 0x0C
            
              These values are mapped from usage page 0x0C (USB consumer page).
        </member>
        <member name="F:Rewired.InputSources.SDL2.SDL.SDL_Scancode.SDL_SCANCODE_BRIGHTNESSDOWN">
              \name Walther keys
            
              These are values that Christian Walther added (for mac keyboard?).
        </member>
        <member name="M:Rewired.InputSources.SDL2.SDL2Joystick.ProcessAxisValue(System.Int32)">
            <summary>
            Convert from +/- 32768 to +/- 1.0f
            </summary>
        </member>
        <member name="M:Rewired.InputSources.SDL2.SDL2InputSource.GetGameControllerCount">
            <summary>
            The value returned cannot be used to iterate! Always use GetJoystickCount!
            </summary>
            <returns>Number of Game Controllers</returns>
        </member>
        <member name="T:Rewired.Dev.Tools.DirectInputJoystickElementIdentifier">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Dev.Tools.JoystickElementIdentifier">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Dev.Tools.OSXJoystickElementIdentifier">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Dev.Tools.RawInputJoystickElementIdentifier">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Dev.Tools.UnityJoystickElementIdentifier">
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.ADictionary`2">
            <summary>
            Modified version of Dictionary that uses custom equality comparers to prevente heap allocations on iOS when doing lookups.
            Can use custom equality comparers. Default comparers for primitives don't generate allocations.
            Can be iterated and accessed by index. Read by index speed is nearly as fast as a List in a build.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ADictionary`2._entries">
            <summary>
            Exposed for speed. DO NOT MODIFY ANYTHING!
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ADictionary`2._count">
            <summary>
            Exposed for speed. DO NOT MODIFY!
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.Utils.Classes.Data.ADictionary`2.Add(`0,`1)" -->
        <!-- Badly formed XML comment ignored for member "M:Rewired.Utils.Classes.Data.ADictionary`2.Clear" -->
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/> contains the specified key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>.</param>
            <returns>true if the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/> contains an element with the specified key; otherwise, false.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.ContainsValue(`1)">
            <summary>
            Determines whether the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/> contains a specific value.
            </summary>
            <param name="value">The value to locate in the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>. The value can be null for reference types.</param>
            <returns>true if the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/> contains an element with the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>.
            </summary>
            <returns>A <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2.Enumerator"/> structure for the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.Remove(`0)">
            <summary>
            Removes the value with the specified key from the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if key is not found in the <see cref="T:Rewired.Utils.Classes.Data.ADictionary`2"/>.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Rewired.Utils.Classes.Data.ADictionary`2.TryGetValue(`0,`1@)" -->
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetValueSafe(`0)">
            <summary>
            Gets the value associated wit hthe specified key.
            Does not throw an exception if the key does not exist.
            </summary>
            <param name="key">The key of the value to get.</param>
            <returns>Returns the value associated with the specified key, if the key is found; otherwise, the default value.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.IndexOfKey(`0)">
            <summary>
            Gets the index of the entry with the specified key.
            </summary>
            <param name="key">The key</param>
            <returns>Returns the index of the entry with the specified key. Returns -1 if the key was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.IndexOfValue(`1)">
            <summary>
            Gets the index of the first entry with the specified value.
            </summary>
            <param name="value">The value</param>
            <returns>Returns the index of the first entry with the specified value. Returns -1 if the value was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.IsValidAt(System.Int32)">
            <summary>
            Determines if the entry at the specified index is valid.
            Invalid entries are not used by the dictionary.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <returns>Returns true if the entry at the specified index is valid. Returns false if invalid.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetKeyAt(System.Int32)">
            <summary>
            Gets the key at the specified index.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <returns>Returns the key at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of range.</exception>
            <exception cref="T:System.ArgumentException">index points to an invalid entry.</exception>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetValueAt(System.Int32)">
            <summary>
            Gets the value at the specified index.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <returns>Returns the value at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of range.</exception>
            <exception cref="T:System.ArgumentException">index points to an invalid entry.</exception>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetEntryAt(System.Int32)">
            <summary>
            Gets the entry at the specified index.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <returns>Returns the entry at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is out of range.</exception>
            <exception cref="T:System.ArgumentException">index points to an invalid entry.</exception>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.TryGetKeyAt(System.Int32,`0@)">
            <summary>
            Gets the key at the specified index.
            This is the fastest method to use for indexed access when the dictionary is full and no items have been removed.
            Up to 50% faster than GetNext... on a full dictionary.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <param name="key">The key</param>
            <returns>Returns true if the entry at the index was valid. Returns false if not.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.TryGetValueAt(System.Int32,`1@)">
            <summary>
            Gets the value at the specified index.
            This is the fastest method to use for indexed access when the dictionary is full and no items have been removed.
            Up to 50% faster than GetNext... on a full dictionary.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <param name="value">The value</param>
            <returns>Returns true if the entry at the index was valid. Returns false if not.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.TryGetEntryAt(System.Int32,System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Gets the entry at the specified index.
            This is the fastest method to use for indexed access when the dictionary is full and no items have been removed.
            Up to 50% faster than GetNext... on a full dictionary.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <param name="entry">The entry</param>
            <returns>Returns true if the entry at the index was valid. Returns false if not.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetNextIndex(System.Int32@)">
            <summary>
            Gets the index of the next valid entry. Index is incremented to match the index of the item.
            Usage: for(int i = -1; dict.GetNextIndex(ref i);) { }
            </summary>
            <param name="index">The index. This should be -1 when starting an iteration at the beginning.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetNextIndex(System.Int32)">
            <summary>
            Gets the index of the next valid entry.
            Usage: for(int i = dict.IndexOfFirst; dict.TryGetValueAt(i, out value); i = dict.GetNextIndex(i);) { }
            </summary>
            <param name="index">The index.</param>
            <returns>Returns the index of the next valid entry in the collection. Returns -1 if no more valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetNextKey(System.Int32@,`0@)">
            <summary>
            Gets the next valid key. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = -1; dict.GetNextKey(ref i, out key);) { }
            </summary>
            <param name="index">The index. This should be -1 when starting an iteration at the beginning.</param>
            <param name="key">The key.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetNextValue(System.Int32@,`1@)">
            <summary>
            Gets the next valid value. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = -1; dict.GetNextValue(ref i, out value);) { }
            </summary>
            <param name="index">The index. This should be -1 when starting an iteration at the beginning.</param>
            <param name="value">The value.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetNextEntry(System.Int32@,System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Gets the next valid entry. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = -1; dict.GetNextEntry(ref i, out entry);) { }
            </summary>
            <param name="index">The index. This should be -1 when starting an iteration at the beginning.</param>
            <param name="entry">The entry.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetPreviousIndex(System.Int32@)">
            <summary>
            Gets the index of the previous valid entry. Index is incremented to match the index of the item.
            Usage: for(int i = dict.TotalCount; dict.GetPreviousIndex(ref i);) { }
            </summary>
            <param name="index">The index. This should be set to <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/>  when starting an iteration at the end.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetPreviousIndex(System.Int32)">
            <summary>
            Gets the index of the previous valid entry.
            Usage: for(int i = dict.IndexOfLast; dict.TryGetValue(i, out value); i = dict.GetPreviousIndex(i);) { }
            </summary>
            <param name="index">The index.</param>
            <returns>Returns the index of the previous valid entry in the collection. Returns -1 if no more valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetPreviousKey(System.Int32@,`0@)">
            <summary>
            Gets the previous valid key. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = dict.TotalCount; dict.GetPreviousKey(ref i, out key);) { }
            </summary>
            <param name="index">The index. This should be set to <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/>  when starting an iteration at the end.</param>
            <param name="key">The key.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetPreviousValue(System.Int32@,`1@)">
            <summary>
            Gets the previous valid value. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = dict.TotalCount; dict.GetPreviousValue(ref i, out value);) { }
            </summary>
            <param name="index">The index. This should be set to <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/>  when starting an iteration at the end.</param>
            <param name="value">The value.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.GetPreviousEntry(System.Int32@,System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Gets the previous valid entry. Index is incremented to match the index of the item.
            This is the fastest method to use for indexed access if many entries have been removed from the dictionary
            because it will skip those that have become invalid without a separate function call for each.
            Usage: for(int i = dict.TotalCount; dict.GetPreviousEntry(ref i, out entry);) { }
            </summary>
            <param name="index">The index. This should be set to <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/>  when starting an iteration at the end.</param>
            <param name="entry">The entry.</param>
            <returns>Returns true if there was another valid entry found in the collection. Returns false if no valid entries were found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ADictionary`2.RemoveAt(System.Int32)">
            <summary>
            Removes the entry at the specified index.
            </summary>
            <param name="index">The index. Use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> to get the count for iteration.</param>
            <returns>Returns true if the entry at the specified index was removed. Returns false if the entry was invalid.</returns>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ADictionary`2.Count">
            <summary>
            Returns the count of valid entries in the dictionary.
            WARNING: Do not use Count when iterating for index accessing. Count does not
            represent the total size of the indexed entries.
            Always use <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount"/> instead when accessing entries by index.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ADictionary`2.TotalCount">
            <summary>
            Returns the count of all entries in the dictionary including invalid entries.
            Always use this instead of <see cref="P:Rewired.Utils.Classes.Data.ADictionary`2.Count"/> when accessing entries by index.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ADictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value for the specified key.</returns>
            <exception cref="T:System.ArgumentNullException">key is null</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key does not exist in the collection.</exception>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ADictionary`2.IndexOfFirst">
            <summary>
            Gets the index of the first valid entry.
            Returns -1 if no valid entry was found.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ADictionary`2.IndexOfLast">
            <summary>
            Gets the index of the last valid entry.
            Returns -1 if no valid entry was found.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.IndexedDictionary`2">
            <summary>
            A Dictionary that stores data sequentially and can be indexed.
            Key lookups are as fast as a Dictionary.
            Does not generate garbage on iOS.
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.RingBuffer`1">
            <summary>
            A fixed-length ring buffer.
            Old items are overwritten when new items are added when the buffer is full.
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.#ctor(System.Int32)">
            <summary>
            Creates an instance of this class.
            </summary>
            <param name="capacity">The maximum capacity of the buffer.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Enqueue(`0)">
            <summary>
            Adds an item to the head of the buffer.
            </summary>
            <param name="item">The item to add to the buffer.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.EnqueueIfUnique(`0)">
            <summary>
            Adds an item to the head of the buffer if it does not already exist in the buffer.
            </summary>
            <param name="item">The item to add to the buffer.</param>
            <returns>True if the item was added or false if the item already exists in the buffer.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Dequeue">
            <summary>
            Removes the oldest item from the buffer.
            </summary>
            <returns>The oldest item in the buffer.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Peek">
            <summary>
            Gets the oldest item in the buffer but does not remove it.
            </summary>
            <returns>The oldest item in the buffer.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Contains(`0)">
            <summary>
            Determines if the buffer contains the specified item.
            </summary>
            <param name="item">The item to search for in the buffer.</param>
            <returns>True if the item exists in the buffer or false if it does not.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Contains(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Determines if the buffer contains the specified item.
            </summary>
            <param name="item">The item to search for in the buffer.</param>
            <param name="comparer">The equality comparer to be used to determine if the item is in the buffer.</param>
            <returns>True if the item exists in the buffer or false if it does not.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.IndexOf(`0)">
            <summary>
            Gets the index of the first matching item in the buffer.
            </summary>
            <param name="item">The item to search for in the buffer.</param>
            <returns>The index of the item or -1 if the item was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.IndexOf(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Gets the index of the first matching item in the buffer.
            </summary>
            <param name="item">The item to remove from the buffer.</param>
            <param name="comparer">The equality comparer to be used to determine if the item is in the buffer.</param>
            <returns>The index of the item or -1 if the item was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Remove(`0)">
            <summary>
            Removes the first matching item from the buffer.
            </summary>
            <param name="item">The item to remove from the buffer.</param>
            <returns>True if the item was removed or false if the item was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes the first matching item from the buffer.
            </summary>
            <param name="item">The item to remove from the buffer.</param>
            <param name="comparer">The equality comparer to be used to determine if the item is in the buffer.</param>
            <returns>True if the item was removed or false if the item was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index from the buffer.
            </summary>
            <param name="index">The index of the item to remove.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.RemoveAll(`0)">
            <summary>
            Removes all matching items from the buffer.
            </summary>
            <param name="item">The item to remove from the buffer.</param>
            <returns>The number of items removed from the buffer.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.RemoveAll(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Removes all matching items from the buffer.
            </summary>
            <param name="item">The item to remove from the buffer.</param>
            <param name="comparer">The equality comparer to be used to determine if the item is in the buffer.</param>
            <returns>The number of items removed from the buffer.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.RingBuffer`1.Clear">
            <summary>
            Clears the buffer.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.RingBuffer`1.Count">
            <summary>
            The number of items in the buffer.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.RingBuffer`1.Capacity">
            <summary>
            The maximum capacity of the buffer.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.RingBuffer`1.OverrunCount">
            <summary>
            The number of overruns that have occurred since the last dequeue.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.RingBuffer`1.EqualityComparer">
            <summary>
            The equality comparer used in equality comparisons.
            Set this to null to restore the default equality comparer.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.RingBuffer`1.Item(System.Int32)">
            <summary>
            Gets or sets the item at the specified index.
            </summary>
            <param name="index">The index of the item to be get or set.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.AList`1">
            <summary>
            A modified List implementation. Allows for fixed-length and capped-length expandable lists.
            </summary>
            <typeparam name="T">Type</typeparam>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor">
            <summary>
            Creates an expandable list with default expansion options.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor(System.Int32)">
            <summary>
            Creates an expandable list with the starting capacity default expansion options.
            </summary>
            <param name="startingCapacity">The starting capacity of the list.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a list with the starting capacity default expansion options.
            If maxCapacity is non-zero, list expansion will be capped to this value.
            </summary>
            <param name="startingCapacity">The starting capacity of the list. This cannot be 0 if a fixed-length list.</param>
            <param name="maxCapacity">The maximum capacity of the list. 0 = unlimited. If non-zero, must be >= startingCapacity.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a list with the starting capacity custom expansion options.
            If maxCapacity is non-zero, list expansion will be capped to this value.
            </summary>
            <param name="startingCapacity">The starting capacity of the list. This cannot be 0 if a fixed-length list.</param>
            <param name="maxCapacity">The maximum capacity of the list. 0 = unlimited. If non-zero, must be >= startingCapacity.</param>
            <param name="expansionIncrement">The number of elements added with each expansion. 0 = Use default expansion algorithm.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a list from a collection with default expansion options.
            </summary>
            <param name="collection">Collection to copy</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Creates a list with the starting capacity custom expansion options.
            If maxCapacity is non-zero, list expansion will be capped to this value.
            </summary>
            <param name="collection">Collection to copy</param>
            <param name="maxCapacity">The maximum capacity of the list. 0 = unlimited. If non-zero, must be >= startingCapacity.</param>
            <param name="expansionIncrement">The number of elements added with each expansion. 0 = Use default expansion algorithm.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.AddToFirstOpenSpace(`0)">
            <summary>
            Adds to first space that equals default(T) or a new space if none found..
            </summary>
            <param name="item">Item to add</param>
            <returns>Index where item added. -1 if not added.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.AList`1.AddToFirstOpenSpace(`0,`0)">
            <summary>
            Adds to first space that equals openSpaceEquals or a new space if none found..
            </summary>
            <param name="item">Item to add</param>
            <param name="openSpaceEquals">Definition of an open space</param>
            <returns>Index where item added. -1 if not added.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.Add``1(System.String,``0,Rewired.Utils.Classes.Data.SerializedObject.FieldOptions)">
            <summary>
            Adds or replaces a value.
            </summary>
            <typeparam name="T">The object type.</typeparam>
            <param name="fieldName">The key.</param>
            <param name="value">The value.</param>
            <param name="options">Field options.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.Add(System.Type,System.String,System.Object,Rewired.Utils.Classes.Data.SerializedObject.FieldOptions)">
            <summary>
            Adds or replaces a value.
            </summary>
            <param name="type">The object type.</param>
            <param name="fieldName">The key.</param>
            <param name="value">The value.</param>
            <param name="options">Field options.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.Add(System.String,System.Object)">
            <summary>
            Adds or replaces a value.
            </summary>
            <param name="fieldName">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.GetDataType(System.String)">
            <summary>
            Gets the data type of the original object.
            If the object was deserialized without a known type, this will return null.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.GetOriginalValue(System.String)">
            <summary>
            Gets the original value. Does not do any conversion.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.GetOriginalValue(System.Int32)">
            <summary>
            Gets the original value. Does not do any conversion.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.GetOriginalValue``1(System.String)">
            <summary>
            Gets the original value. Does not do any conversion.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.GetOriginalValue``1(System.Int32)">
            <summary>
            Gets the original value. Does not do any conversion.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.TryGetDeserializedValue``1(System.String,``0@)">
            <summary>
            Gets the value and deserializes it into an object and performs conversion when necessary.
            Every time this is called, if the object is converted from another type, a new instance of deserialized object will be created.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.TryGetDeserializedValue``1(System.Int32,``0@)">
            <summary>
            Gets the value and deserializes it into an object and performs conversion when necessary.
            Every time this is called, if the object is converted from another type, a new instance of deserialized object will be created.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.TryGetDeserializedValueByRef``1(System.String,``0@)">
            <summary>
            Gets the value and deserializes it into an object and performs conversion when necessary.
            Every time this is called, if the object is converted from another type, a new instance of deserialized object will be created.
            If the object is not found or the deserialization fails, ref value will not be modified.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.SerializedObject.TryGetDeserializedValueByRef``1(System.Int32,``0@)">
            <summary>
            Gets the value and deserializes it into an object and performs conversion when necessary.
            Every time this is called, if the object is converted from another type, a new instance of deserialized object will be created.
            If the object is not found or the deserialization fails, ref value will not be modified.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.SerializedObject.Item(System.Int32)">
            <summary>
            Returns the original values.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.NativeBuffer">
            <summary>
            Creates a buffer in native memory.
            WARNING: Data writes are unsafe and will result in crashes 
            or memory corruption if incoming pointers are not valid.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.DumpToHexString">
            <summary>
            Dumps memory to a hex string.
            </summary>
            <returns>Hex string reresentation of the block of memory.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.ReadBit(System.Int32,System.Byte)">
            <summary>
            Get the value of a single bit at a certain byte index.
            </summary>
            <param name="byteIndex">Index of the byte in the buffer.</param>
            <param name="bit">Bit to retrieve. [0 - 7]</param>
            <returns>Bit value</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.TryReadBytes(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Read bytes into the buffer.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.TryReadBytes(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Read bytes into the buffer.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.WriteBit(System.Int32,System.Byte,System.Boolean)">
            <summary>
            Set the value of a single bit at a certain byte index.
            </summary>
            <param name="byteIndex">Index of the byte in the buffer.</param>
            <param name="bit">Bit to write. [0 - 7]</param>
            <param name="value">Bit value</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.TryWriteBytes(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Writes until buffer is full.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.TryWriteBytes(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Writes until buffer is full.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.TryFill(System.Byte,System.Int32,System.Int32)">
            <summary>
            Writes a repeating value to the buffer.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.Resize(System.Int32,System.Boolean)">
            <summary>
            Resizes the buffer.
            </summary>
            <param name="size">The new buffer size.</param>
            <param name="preserveData">If true, memory will be copied to the new buffer. If the new buffer is smaller than the previous, the data will be truncated.</param>
            <returns>True if the buffer was resized or is already the target size. False if there was an error.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.Clear">
            <summary>
            Zero fills the memory.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.Release">
            <summary>
            Frees the native memory.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.CopyFrom(Rewired.Utils.Classes.Data.NativeBuffer)">
            <summary>
            Copies data from another NativeBuffer.
            </summary>
            <param name="other">The buffer to copy from.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeBuffer.Copy(Rewired.Utils.Classes.Data.NativeBuffer,Rewired.Utils.Classes.Data.NativeBuffer)">
            <summary>
            Copies one buffer to another.
            The destination buffer will be resized if necessary.
            </summary>
            <param name="source">The buffer from which the data will be copied..</param>
            <param name="destination">The buffer to which the data will be copied.</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.NativeRingBuffer">
            <summary>
            Creates a byte ring buffer in native memory.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.#ctor(System.Int32)">
            <summary>
            Creates a native ring buffer.
            </summary>
            <param name="capacity">Size of the buffer in bytes</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Allocate(System.Int32,System.Boolean,System.UInt32@)">
            <summary>
            Allocates space in the buffer.
            </summary>
            <returns>Pointer to the start of the allocated space.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Write(System.IntPtr,System.Int32,System.Int32,System.Int32@,System.UInt32@)">
            <summary>
            Write data to the buffer.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Write(System.Byte[],System.Int32,System.Int32@,System.UInt32@)">
            <summary>
            Write data to the buffer.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Write(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Write data to the buffer.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Write(System.Byte[],System.Int32)">
            <summary>
            Write data to the buffer.
            </summary>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Read(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Read data from the buffer from the end forward.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.Read(System.Byte[],System.Int32)">
            <summary>
            Read data from the buffer from the end forward.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.RandomRead(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Read data from the buffer at an index.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.RandomRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read data from the buffer at an index.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.GetPointerFromReadPosition(System.Int32)">
            <summary>
            Gets a pointer offset from the read position.
            Result will wrap when offset would move the head beyond memory range.
            </summary>
            <param name="offset">Offset in bytes from the read head position.</param>
            <returns>Pointer offset from the read position.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.GetOffsetFromReadPosition(System.Int32)">
            <summary>
            Gets an index offset from the read position.
            Result will wrap when offset would move the head beyond memory range.
            </summary>
            <param name="offset">Offset in bytes from the read head position.</param>
            <returns>Offset read position.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.CopyFrom(Rewired.Utils.Classes.Data.NativeRingBuffer)">
            <summary>
            Copies data from another NativeRingBuffer.
            </summary>
            <param name="other">The buffer to copy dara from.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.AdvanceWritePosition(System.Int32)">
            <summary>
            Do not call this anywhere except within Write
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.NativeRingBuffer.AdvanceReadPosition(System.Int32)">
            <summary>
            Do not call this anywhere except within Read
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.NativeRingBuffer.ReadPosition">
            <summary>
            Returns the offset from the beginning of memory of the read head.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.NativeRingBuffer.WritePosition">
            <summary>
            Returns the offset from the beginning of memory of the write head.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.NativeMemoryBlock">
            <summary>
            Creates a block of native memory which can be then allocated into smaller blocks.
            When the buffer is out of space, it will wrap and allocate new blocks
            from the beginning. There is no guarantee any block previously allocated
            won't be overwritten by a new block.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.ScreenRect">
            <summary>
            A rect with the 0, 0 position in the bottom-left corner.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.ScreenRect.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a ScreenRect.
            </summary>
            <param name="left">The left-most boundary.</param>
            <param name="bottom">The bottom-most boundary.</param>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ScreenRect.xMin">
            <summary>
            The left-most boundary.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ScreenRect.yMin">
            <summary>
            The bottom-most boundary.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ScreenRect.width">
            <summary>
            The height of the rect.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Data.ScreenRect.height">
            <summary>
            The width of the rect.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ScreenRect.xMax">
            <summary>
            The right-most boundary.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ScreenRect.yMax">
            <summary>
            The top-most boundary.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.ScreenRect.center">
            <summary>
            The center of the rect.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.GetSetValue`1">
            <summary>
            Gets or sets a value using delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Rewired.Utils.Classes.Data.KeyedGetSetValueStore`1">
            <exclude></exclude>
            <summary>
            Class for accessing GetSetValue.
            This is a concrete class without an interface to make it more versatile
            because IL2CPP cannot handle generic methods on interfaces.
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.KeyedGetSetValueStore`1.#ctor(System.Collections.Generic.Dictionary{`0,System.Object},System.Boolean)">
            <param name="valueDelegates">Must contain objects that implement IGetSetValue.</param>
            <param name="isReadOnlyCollection">If true, the collection is read-only and cannot be modified. Values can still be set.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Data.KeyedGetSetValueStore`1.#ctor(System.Boolean)">
            <param name="isReadOnlyCollection">If true, the collection is read-only and cannot be modified. Values can still be set.</param>
        </member>
        <member name="P:Rewired.Utils.Classes.Data.KeyedGetSetValueStore`1.isReadOnlyCollection">
            <summary>
            If true, the collection is read-only and cannot be modified. Values can still be set.
            </summary>
        </member>
        <member name="M:Rewired.Utils.ExtensionMethods.IsNullOrDestroyed(System.Object)">
            <summary>
            Used to determine if an interface on an object that inherits from
            UnityEngine.Object is null or has been destroyed.
            This is to make up for the fact that the UnityEngine.Object's
            overloaded == operator does  not work on interfaces.
            This can be called directly on a null object because it's a static
            extension method.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Libraries.TinyJson.SerializeAttribute">
            <exclude></exclude>
            <summary>
            Serialize and deserialize a field/property with a different name.
            If used on a private field, performs the same function as SerializeAttribute as well.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Libraries.TinyJson.SerializeAttribute.Name">
            <summary>
            An optional substitute name to use when serialized and deserialized.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Libraries.TinyJson.JsonTools">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonTools.Clone``1(``0)">
            <summary>
            Creates a serialized clone of an object.
            </summary>
            <param name="obj">The object to copy</param>
            <returns>The copy.</returns>
        </member>
        <member name="T:Rewired.Utils.Libraries.TinyJson.JsonParser">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonParser.FromJson``1(System.String)">
            <exclude></exclude>
            <summary>
            Converts a json string to an object.
            WARNING: Class types inside DLLs that you use this on MUST use the Rewired.Utils.Attributes.PreserveAttribute on the class if the default constructor
            is never actively used in code or the default constructor will be stripped out by IL2CPP!
            [Preserve]
            </summary>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonParser.FromJson``1(System.String,System.Type)">
            <exclude></exclude>
            <summary>
            Converts a json string to an object.
            WARNING: Class types inside DLLs that you use this on MUST use the Rewired.Utils.Attributes.PreserveAttribute on the class if the default constructor
            is never actively used in code or the default constructor will be stripped out by IL2CPP!
            [Preserve]
            </summary>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonParser.FromJson(System.Type,System.String)">
            <exclude></exclude>
            <summary>
            Converts a json string to an object.
            WARNING: Class types inside DLLs that you use this on MUST use the Rewired.Utils.Attributes.PreserveAttribute on the class if the default constructor
            is never actively used in code or the default constructor will be stripped out by IL2CPP!
            [Preserve]
            </summary>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonParser.FromJson(System.Type,System.String,System.Type)">
            <exclude></exclude>
            <summary>
            Converts a json string to an object.
            WARNING: Class types inside DLLs that you use this on MUST use the Rewired.Utils.Attributes.PreserveAttribute on the class if the default constructor
            is never actively used in code or the default constructor will be stripped out by IL2CPP!
            [Preserve]
            </summary>
        </member>
        <member name="T:Rewired.Utils.Libraries.TinyJson.JsonWriter">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Utils.Libraries.TinyJson.JsonWriter.ToJson(System.Object)">
            <exclude></exclude>
        </member>
        <member name="M:Rewired.Utils.Libraries.JoyShock.Motion.Update(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            The gyro inputs should be calibrated degrees per second but have no other processing
            </summary>
        </member>
        <member name="T:Rewired.Utils.SafeDelegate">
            <summary>
            Base class for custom delegate.
            </summary>
        </member>
        <member name="T:Rewired.Utils.SafeDelegate`1">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
            <typeparam name="T">Type of the underlying delegate. This must inherit from System.Delegate.</typeparam>
        </member>
        <member name="M:Rewired.Utils.SafeDelegate`1.RemoveDelegateOrAllDelegatesFromAnObject(System.Object)">
            <summary>
            Removes delegates from the list.
            </summary>
            <param name="obj">Can be a delegate or the owning object of delegates in the list.</param>
        </member>
        <member name="T:Rewired.Utils.SafeAction">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
        </member>
        <member name="T:Rewired.Utils.SafeAction`1">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
            <typeparam name="T">Argument type</typeparam>
        </member>
        <member name="T:Rewired.Utils.SafeAction`2">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
            <typeparam name="T">Argument type 1</typeparam>
            <typeparam name="T2">Argument type 2</typeparam>
        </member>
        <member name="T:Rewired.Utils.SafeFunc`2">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
            <typeparam name="T">Argument type</typeparam>
            <typeparam name="TResult">Return type</typeparam>
        </member>
        <member name="T:Rewired.Utils.SafePredicate`1">
            <summary>
            Custom delegate system.
            Survives exceptions thrown by listeners.
            Removes listeners when they throw an exception.
            Removes listners owned by a UnityEngine.Object class
            when the UnityEngine.Object has been destroyed.
            </summary>
            <typeparam name="T">Argument type</typeparam>
        </member>
        <member name="M:Rewired.Utils.TempListPool.Clear">
            <summary>
            Clears everything and frees memory.
            </summary>
        </member>
        <member name="M:Rewired.Utils.TempListPool.Clear(System.Type)">
            <summary>
            Clear lists of the specified type and free memory.
            </summary>
            <param name="listType">The list type to clear.</param>
        </member>
        <member name="M:Rewired.Utils.TempListPool.TListPool.Clear">
            <summary>
            Clears the pool and frees memory.
            </summary>
        </member>
        <member name="M:Rewired.Utils.TempListPool.TListPool.Clear(System.Type)">
            <summary>
            Clear lists of the specified type and free memory.
            </summary>
            <param name="listType">The list type to clear.</param>
        </member>
        <member name="T:Rewired.Utils.TempListPool.TList`1">
            <summary>
            A <see cref="T:System.Collections.Generic.List`1"/> wrapper that implements <see cref="T:System.IDisposable"/>.
            Always call Dispose or use the using pattern when working with <see cref="T:Rewired.Utils.TempListPool.TList`1"/> to avoid garbage.
            When disposed, the object will be returned to the pool for reuse. Do not keep any references around
            because the <see cref="T:Rewired.Utils.TempListPool.TList`1"/> may be reused for another list.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Rewired.Utils.TempListPool.TList`1.#ctor">
            <summary>
            Creates a new instance of the class.
            </summary>
        </member>
        <member name="M:Rewired.Utils.TempListPool.TList`1.Rewired#Utils#TempListPool#ITListSetter{T}#SetList(System.Collections.Generic.List{`0})">
            <summary>
            This is used by the pool to set the list value.
            FOR INTERNAL USE ONLY. DO NOT CALL THIS METHOD.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Rewired.Utils.InputTools.TransformAxis2DComponentValue(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Only does the first part of transforming the axis to the new range.
            Does not apply deadzone or deadzone transformation.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.SByte,System.SByte)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Byte,System.Byte)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Int16,System.Int16)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.UInt16,System.UInt16)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Int32,System.Int32)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.UInt32,System.UInt32)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Int64,System.Int64)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.UInt64,System.UInt64)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Single,System.Single)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(System.Double,System.Double)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.SByte,System.SByte)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Byte,System.Byte)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Int16,System.Int16)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.UInt16,System.UInt16)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Int32,System.Int32)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.UInt32,System.UInt32)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Int64,System.Int64)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.UInt64,System.UInt64)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Single,System.Single)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(System.Double,System.Double)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MaxMagnitude(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Compares absolute values. If magnitude of a >= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MathTools.MinMagnitude(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Compares absolute values. If magnitude of a &lt;= b, a will be returned.
            </summary>
        </member>
        <member name="M:Rewired.Utils.MiscTools.CreateGuidHashSHA256(System.String)">
            <summary>
            Generate a GUID from a string by first creating a SHA256 hash, then truncating to the first 16 bytes to create the GUID.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Rewired.Utils.MiscTools.Tick(System.UInt32)">
            <summary>
            Increment a UInt32 tick. Wraps to 1. Zero is not a valid UInt32 tick.
            </summary>
            <param name="counter">The current tick count</param>
            <returns>Incremented tick</returns>
        </member>
        <member name="M:Rewired.Utils.MiscTools.Tick(System.Int32)">
            <summary>
            Increment an Int32 tick. Wraps to 0. Negative values are not valid Int32 ticks.
            </summary>
            <param name="counter">The current tick count</param>
            <returns>Incremented tick</returns>
        </member>
        <member name="M:Rewired.Utils.MiscTools.TickPrev(System.UInt32)">
            <summary>
            Decrements a UInt32 tick. Wraps to 1. Zero is not a valid UInt32 tick.
            </summary>
            <param name="counter">The current tick count</param>
            <returns>Incremented tick</returns>
        </member>
        <member name="M:Rewired.Utils.MiscTools.TickPrev(System.Int32)">
            <summary>
            Decrements an Int32 tick. Wraps to 0. Negative values are not valid Int32 ticks.
            </summary>
            <param name="counter">The current tick count</param>
            <returns>Incremented tick</returns>
        </member>
        <member name="M:Rewired.Utils.ReflectionTools.IsAssemblyLoaded(System.String,System.Boolean,System.Boolean)">
            <summary>
            Must use this to check whether assemblies are loaded prior to calling System.Type.GetType or
            the assembly will get dynamically loaded in the .NET 4.6 backend!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.DetermineWebplayerPlatformType(Rewired.Platforms.Platform,Rewired.Platforms.EditorPlatform)">
            <summary>
            Only works if called from within #if UNITY_WEBPLAYER so we KNOW this a webplayer.
            Always call before setting platform to Webplayer.
            Platform should have info about the real system platform based on #ifs
            </summary>
            <returns></returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Transform)">
            <summary>
            Gets all Components in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Component)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.GameObject)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Transform,System.Boolean)">
            <summary>
            Gets all Components in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Component,System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.Transform)">
            <summary>
            Gets all Components in the object's children.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.Component)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.GameObject)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.Transform)">
            <summary>
            Gets all Components in the object's parents.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.Component)">
            <summary>
            Gets all Components or Interfaces in the object's parents.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.GameObject)">
            <summary>
            Gets all Components or Interfaces in the object's parents.
            Also works with Interfaces on Components.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.Transform)">
            <summary>
            Gets all Components in the object's parents.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.Component)">
            <summary>
            Gets all Components or Interfaces in the object's parents.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.GameObject)">
            <summary>
            Gets all Components or Interfaces in the object's parents.
            Memory allocations!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.Transform,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.Component,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.GameObject,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.Transform,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.Component,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents``1(UnityEngine.GameObject,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.Transform,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.Component,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.GameObject,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.Transform,System.Type,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object of a specific type.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.Component,System.Type,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object of a specific type.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponents(UnityEngine.GameObject,System.Type,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object of a specific type.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren(UnityEngine.Transform,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren(UnityEngine.Component,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren(UnityEngine.GameObject,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.Transform,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.Component,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.GameObject,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.Transform,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.Component,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInSelfAndChildren``1(UnityEngine.GameObject,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in this object and all children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Transform,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Component,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.GameObject,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Transform,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.Component,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren``1(UnityEngine.GameObject,System.Boolean,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.Transform,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components in the object's children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.Component,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInChildren(UnityEngine.GameObject,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Gets all Components or Interfaces in the object's children.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.Transform,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.Component,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents``1(UnityEngine.GameObject,System.Collections.Generic.List{``0},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            Also works with Interfaces on Components.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.Transform,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.Component,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.GetComponentsInParents(UnityEngine.GameObject,System.Collections.Generic.List{UnityEngine.Component},System.Boolean)">
            <summary>
            Get all Components on an object's parents.
            No memory allocations in Unity 5.x+.
            Warning: Memory allocations in Unity 4.x!
            </summary>
            <returns>Number of components</returns>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.Transform,System.Action{``0},System.Boolean)">
            <summary>
            Invokes a delegate on Components in the object and/or its children.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.Transform,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.Component,System.Action{``0},System.Boolean)">
            <summary>
            Invokes a delegate on Components in the object.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.Component,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.GameObject,System.Action{``0},System.Boolean)">
            <summary>
            Invokes a delegate on Components in the object.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponent``1(UnityEngine.GameObject,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponentInChildren``1(UnityEngine.Transform,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object's children.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponentInChildren``1(UnityEngine.Component,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object's children.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="M:Rewired.Utils.UnityTools.ForEachComponentInChildren``1(UnityEngine.GameObject,System.Action{``0})">
            <summary>
            Invokes a delegate on Components in the object's children.
            Also works with Interfaces on Components.
            Warning: Memory allocations in Unity 4.x!
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.Locker">
            <summary>
            Locks the target and unlocks on Dispose.
            Safe to use with a null lock object.
            Use with using statement.
            THIS WILL RESULT IN AN UNBOXING PENALTY BECAUSE IT IS A STRUCT THAT IMPLEMENTS AN INTERFACE on .NET 3.5 scripting backend. .NET 4.6 fixed this.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.LockedObject`1">
            <summary>
            A reusable locker that holds an object.
            Best used with the using pattern.
            This is a class and can be reused.
            Useful for exposing an object for consumption that has to be locked within another class.
            </summary>
            <typeparam name="T">Contained object type.</typeparam>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.Start(System.Boolean)">
            <summary>
            Starts the thread.
            </summary>
            <param name="wait">Should the executing thread wait until the thread starts?</param>
            <returns>Returns false if the thread is already running or if an exception occurs while starting the thread.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.Stop(System.Boolean)">
            <summary>
            Stops the thread.
            </summary>
            <param name="wait">Wait for the thread to stop before continuing?</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.EnqueueAction(System.Action)">
            <summary>
            Enqueues an Action to be run on the thread.
            </summary>
            <param name="action">The Action to invoke.</param>
            <returns>Returns false if the thread is not running or the Action is null.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.InvokeActionSync(System.Action)">
            <summary>
            Invokes the incoming Action on the thread synchronously.
            The calling thread will halt until execution of the Action is finished.
            If there are other Actions in the queue, all Actions will be processed
            before execution is resumed in the calling thread.
            </summary>
            <param name="action">The Action to invoke.</param>
            <returns>Returns false if the thread is not running or the Action is null.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.WaitForActionQueueToFinish">
            <summary>
            Stops the calling thread execution until all Actions in the queue have finished processing.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadHelper.ResetTimeout">
            <summary>
            Resets the timeout timer so the thread does not self-terminate.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.isRunning">
            <summary>
            Is the thread currently running?
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.isStopped">
            <summary>
            Is the thread stopped?
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.useHighPrecitionTimer">
            <summary>
            Is the high precision timer being used? This greatly increases CPU resources because the thread does not sleep.
            Note: This is enabled automatically if using a fixed time step and FPS is set to the FORCE_HIGH_PRECISION_TIMER_AT_FPS threshold or above.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.useFixedTimeStep">
            <summary>
            Is the thread running on a fixed time step?
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.fixedTimeStepFPS">
            <summary>
            The thread fixed time step interval in frames per second. [0 = Continuous]
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.timeoutMS">
            <summary>
            The self-termination timeout in milliseconds. [0 = No timeout]
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ThreadHelper.tick">
            <summary>
            The number of thread ticks that have elapsed since the thread was started.
            </summary>
        </member>
        <member name="E:Rewired.Utils.Classes.Utility.ThreadHelper.ThreadUpdateEvent">
            <summary>
            Event fires once per thread tick.
            This event is fired from the thread.
            </summary>
        </member>
        <member name="E:Rewired.Utils.Classes.Utility.ThreadHelper.ThreadStartedEvent">
            <summary>
            Fires when the thread starts.
            This event is fired from the thread.
            </summary>
        </member>
        <member name="E:Rewired.Utils.Classes.Utility.ThreadHelper.ThreadPreStopEvent">
            <summary>
            Fires just before the thread stops.
            This event is fired from the thread.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ThreadedMessageQueue`1">
            <summary>
            Creates a dedicated thread to send messages.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedMessageQueue`1.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Action{`0})">
            <summary>
            Creates a threaded message queue.
            </summary>
            <param name="maxQueueSize">Max size of the queue. 0 = No limit.</param>
            <param name="threadRefreshRateFPS">Update rate of the thread. 0 = Do not thread sleep.</param>
            <param name="threadAutoKillTimeoutMS">Time in MS before the thread will auto-destruct if no messages are received. 0 = Do not auto-destruct.</param>
            <param name="threadBlockOnStartAndStop">Block the calling thread until the thread is started or stopped?</param>
            <param name="messageReceiverDelegate">Delegate to receive the message from the thread. Must be threadsafe!</param>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer">
            <summary>
            Creates a thread to retrieve data and store it in a ring buffer.
            Data is stored in reports/pages of a fixed size.
            The data can then be read from another thread.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Action{System.Byte[]})">
            <summary>
            Creates a threaded ring buffer.
            </summary>
            <param name="entryByteLength">Size in bytes of each data entry.</param>
            <param name="entryCapacity">Number of data entries that the buffer can hold before overflowing.</param>
            <param name="threadRefreshRateFPS">Update rate of the thread. 0 = Do not thread sleep.</param>
            <param name="threadAutoKillTimeoutMS">Time in MS before the thread will auto-destruct if no messages are received. 0 = Do not auto-destruct.</param>
            <param name="threadBlockOnStartAndStop">Block the calling thread until the thread is started or stopped?</param>
            <param name="threadRetrieveDataDelegate">Delegate to retrieve data. This will be called by the thread.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer.Read">
            <summary>
            Call StartRead before reading to fill the buffer with new data.
            Read data into the ReadBuffer property.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer.Read(System.Byte[])">
            <summary>
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <param name="buffer">Buffer to fill with data</param>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer.Read(System.IntPtr,System.Int32)">
            <summary>
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <param name="buffer">Buffer to fill with data</param>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ThreadedRingReportBuffer.StartRead">
            <summary>
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <returns>Number of bytes in the buffer</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.DualRingReportBuffer">
            <summary>
            A pair of ring buffers, input and output. Writing can be done from another thread.
            Data is stored in reports/pages of a fixed size.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.#ctor(System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="entryByteLength">Size in bytes of each data entry.</param>
            <param name="entryCapacity">Number of data entries that the buffer can hold before overflowing.</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.StartRead">
            <summary>
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <returns>Number of bytes in the buffer</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.Read">
            <summary>
            Read data into the ReadBuffer array.
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.Read(System.Byte[],System.Int32)">
            <summary>
            Read data from the buffer into the incoming buffer array.
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <param name="buffer">Buffer to fill with data</param>
            <param name="numBytesToRead">Number of bytes to read into the buffer</param>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.Read(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Read data from the buffer into the incoming buffer pointer.
            Call StartRead before reading to fill the buffer with new data.
            </summary>
            <param name="buffer">Buffer to fill with data</param>
            <param name="bufferLength">The length of the buffer in bytes.</param>
            <param name="numBytesToRead">Number of bytes to read into the buffer</param>
            <returns>Number of bytes read</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.Write(System.Byte[],System.Int32)">
            <summary>
            Write data to the buffer from the incoming buffer array.
            This can be called by a separate thread.
            </summary>
            <param name="buffer">Buffer from which to write.</param>
            <param name="numBytesToWrite">Number of bytes to write to the buffer.</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualRingReportBuffer.Write(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Write data to the buffer from the incoming buffer array.
            This can be called by a separate thread.
            </summary>
            <param name="buffer">Buffer from which to write.</param>
            <param name="bufferLength">The length of the buffer in bytes.</param>
            <param name="numBytesToWrite">Number of bytes to write to the buffer.</param>
            <returns>Number of bytes written</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ObjectInstanceTracker">
            <summary>
            Stores instances and assigns unique ids.
            This is used for static function pointer callback handling due to IL2CPP's inability to marshal a function pointer to an instance method.
            Objects must be unregistered when no longer needed or you will get a MEMORY LEAK.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ObjectInstanceTracker.Register(System.Object)">
            <summary>
            Registers the object and returns a new instance id.
            </summary>
            <returns>New instance id.</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ObjectInstanceTracker.Wrapper`1">
            <summary>
            A wrapper for an object that registers the object with a tracker
            and automatically unregisters it when the wrapper goes out of scope or is disposed.
            This is so a class doesn't have to store its own id and so it can unregister properly
            without having to implement IDisposable and be disposed manually.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue">
            <summary>
            An event queue that handles creation of events on a separate thread from consumption.
            Creation thread must not call any of the non T_ methods or properties because they are not
            thread safe. Consumption thread must not call any of the T_ methods.
            Update must be called before consumption to copy new events into the consumption queue,
            or use <see cref="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.ProcessNewEvents"/> to copy new events to consumption queue and enumerate all new events.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.currentEvent">
            <summary>
            The current event being processed by <see cref="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.ProcessNewEvents"/>.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.T_CreateEvent">
            <summary>
            Creates a new event.
            Thread-safe. Locks the queues until event is populated.
            Must be used with the using() pattern.
            using(var helper = obj.T_CreateEvent()) { ... populate event data }
            Lock will be released when using calls Dispose.
            Event is no longer valid once outside the using scope.
            </summary>
            <returns>Event wrapper object for population of event data. Must be used in using() pattern.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.Update">
            <summary>
            Copies new events from the input thread to the consumer thread.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.Clear">
            <summary>
            Clears all events.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.ProcessNewEvents">
            <summary>
            Updates the queue and processes the next new event in the queue.
            Should be called in a while loop to process all the events.
            Should only be called by the consumer thread.
            Get the current event from <see cref="F:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.currentEvent"/>.
            </summary>
            <returns>True if an event was found, false if no events remain.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.StopProcessingEvents">
            <summary>
            Must be called if you do not finish processing all events after calling ProcessNewEvents.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.lastProcessedEventId">
            <summary>
            The event id of the last event processed by <see cref="M:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.ProcessNewEvents"/>.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.count">
            <summary>
            The count of events in the consumer queue. This includes events that have already been processed.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.NewEventWrapper">
            <summary>
            Wrapper around the event that makes sure the threads are locked while the event is populated.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.DualThreadLowLevelInputEventQueue.INewEventWrapper">
            <summary>
            Interface for wrapping a new event during population for thread safety.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.LowLevelInputEventQueue">
            <summary>
            This uses native buffers even though they're slower read/write than byte[] or int/double[]
            because it means we can allocate a lot of memeory and release it without garbage
            collection.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.SetAndRestoreVar`1">
            <summary>
            Sets a value temporarily. Value is restored when destroyed.
            Use with using statement.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.Stopwatch">
            <summary>
            A stopwatch class that wraps System.Diagnostics.Stopwatch.
            Supports a global stopwatch that always runs and time offset.
            </summary>
        </member>
        <member name="F:Rewired.Utils.Classes.Utility.Stopwatch.Global">
            <summary>
            Gets the Global Stopwatch instance.
            This Stopwatch is started automatically in the static constructor
            and continues to run forever. It cannot be stopped or reset.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.#cctor">
            <summary>
            Static constructor for Stopwatch.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.StartNew">
            <summary>
            Creates a new stopwatch and starts it.
            </summary>
            <returns>Stopwatch</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.ConvertTo100NSTicks(System.Int64)">
            <summary>
            Converts Stopwatch ticks to 100 ns ticks.
            </summary>
            <param name="ticks">Number of Stopwatch ticks.</param>
            <returns>100 ns ticks.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.#ctor">
            <summary>
            Creates an instance of the Stopwatch class.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.Stop">
            <summary>
            Stops the stopwatch.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.Start">
            <summary>
            Starts the stopwatch
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.Stopwatch.Reset">
            <summary>
            Resets the stopwatch
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.frequency">
            <summary>
            The frequency of all stopwatches in ticks per second.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.offsetSeconds">
            <summary>
            Time in seconds to offset all returned time values.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.offsetTicks">
            <summary>
            The time in ticks to offset all returned time values.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedSeconds">
            <summary>
            Time in seconds since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedSecondsRaw">
            <summary>
            Time in seconds since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedMilliseconds">
            <summary>
            Time in milliseconds since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedMillisecondsRaw">
            <summary>
            Time in milliseconds since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedTicks">
            <summary>
            The number of ticks that have elapsed since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.elapsedTicksRaw">
            <summary>
            The number of ticks that have elapsed since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.Stopwatch.isRunning">
            <summary>
            Is the stopwatch currently running?
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.UnityStopwatch">
            <summary>
            A hacked replacement for System.Diagnostics.Stopwatch based on UnityEngine.Time.realtimeSinceStartup
            because of major Xbox One System.Diagnostics.Stopwatch error.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.StartNew">
            <summary>
            Creates a new stopwatch and starts it.
            </summary>
            <returns>Stopwatch</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.ConvertTo100NSTicks(System.Int64)">
            <summary>
            Converts Stopwatch ticks to 100 ns ticks.
            </summary>
            <param name="ticks">Number of Stopwatch ticks.</param>
            <returns>100 ns ticks.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.#ctor">
            <summary>
            Creates an instance of the Stopwatch class.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.#ctor(System.Boolean)">
            <summary>
            Creates an instance of the Stopwatch class.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.Stop">
            <summary>
            Stops the stopwatch.
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.Start">
            <summary>
            Starts the stopwatch
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.Reset">
            <summary>
            Resets the stopwatch
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.Global">
            <summary>
            Gets the Global Stopwatch instance.
            This Stopwatch is started automatically in the static constructor
            and continues to run forever. It cannot be stopped or reset.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.frequency">
            <summary>
            The frequency of all stopwatches in ticks per second.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.offsetSeconds">
            <summary>
            Time in seconds to offset all returned time values.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.offsetTicks">
            <summary>
            The time in ticks to offset all returned time values.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedSeconds">
            <summary>
            Time in seconds since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedSecondsRaw">
            <summary>
            Time in seconds since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedMilliseconds">
            <summary>
            Time in milliseconds since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedMillisecondsRaw">
            <summary>
            Time in milliseconds since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedTicks">
            <summary>
            The number of ticks that have elapsed since the stopwatch was started.
            This value is modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.elapsedTicksRaw">
            <summary>
            The number of ticks that have elapsed since the stopwatch was started.
            This value is not modified by the offset property.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.UnityStopwatch.isRunning">
            <summary>
            Is the stopwatch currently running?
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.UnityStopwatch.Stopwatch.Update">
            <summary>
            Only call this from the main Unity thread!
            </summary>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.EnumNameValueCache`1.GetName(System.Int64)">
            <summary>
            Gets the name from the value.
            You must cast the enum to a long using unchecked((long)value).
            This is done to prevent garbage generated by EqualityComparer&lt;T&gt;.Equals on enums.
            </summary>
            <param name="value">The enum value cast to a long. You must cast the enum to a long using unchecked((long)value).</param>
            <returns>The name.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.EnumNameValueCache`1.TryGetName(System.Int64,System.String@)">
            <summary>
            Tries to get the name from the value.
            You must cast the enum to a long using unchecked((long)value).
            This is done to prevent garbage generated by EqualityComparer&lt;T&gt;.Equals on enums.
            </summary>
            <param name="value">The enum value cast to a long. You must cast the enum to a long using unchecked((long)value).</param>
            <param name="name">The name.</param>
            <returns>True if successful, otherwise false.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.EnumNameValueCache`1.IndexOf(System.Int64)">
            <summary>
            Gets the index of the value.
            You must cast the enum to a long using unchecked((long)value).
            This is done to prevent garbage generated by EqualityComparer&lt;T&gt;.Equals on enums.
            </summary>
            <param name="value">The enum value cast to a long. You must cast the enum to a long using unchecked((long)value).</param>
            <returns>The index of the value. Returns -1 if the value was not found.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.EnumNameValueCache`1.Contains(System.Int64)">
            <summary>
            Determines if the specified value exists in the enum.
            You must cast the enum to a long using unchecked((long)value).
            This is done to prevent garbage generated by EqualityComparer&lt;T&gt;.Equals on enums.
            </summary>
            <param name="value">The enum value cast to a long. You must cast the enum to a long using unchecked((long)value).</param>
            <returns>True if the value exists, otherwise false.</returns>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ValueWatcher">
            <summary>
            Watches a value for changes and can trigger an event when it changes.
            </summary>
        </member>
        <member name="T:Rewired.Utils.Classes.Utility.ValueWatcher`1">
            <summary>
            Watches a value for changes and can trigger an event when it changes.
            </summary>
            <typeparam name="T">Value type.</typeparam>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.#ctor(`0,System.Boolean)">
            <summary>
            Creates an instance.
            </summary>
            <param name="initialValue">The initial value.</param>
            <param name="autoTriggerEvent">Should the changed event be triggered immediately when the value changes?</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.#ctor(`0,System.Func{`0},System.Boolean)">
            <summary>
            Creates an instance.
            </summary>
            <param name="initialValue">The initial value.</param>
            <param name="getValueDelegate">The delegate used to retrieve the value when <see cref="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.Update"/> is called.</param>
            <param name="autoTriggerEvent">Should the changed event be triggered immediately when the value changes?</param>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.Update">
            <summary>
            Updates the value from the delegate.
            </summary>
            <returns>True if the value changed, false otherwise.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.Use">
            <summary>
            Uses the event. Changed is set to false.
            </summary>
            <returns>True if the value was previously changed, false if there was no change to use.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.TriggerEvent">
            <summary>
            Triggers the changed event if the value has changed and uses it.
            </summary>
            <returns>True if the event fired, false otherwise.</returns>
        </member>
        <member name="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.Set(`0)">
            <summary>
            Sets the value.
            </summary>
            <param name="value">The new value.</param>
            <returns>True if the value changed, false otherwise.</returns>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ValueWatcher`1.autoTriggerEvent">
            <summary>
            Should the changed event be triggered immediately when the value changes?
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ValueWatcher`1.getValueDelegate">
            <summary>
            Gets or sets the delegate used to retrieve the value when <see cref="M:Rewired.Utils.Classes.Utility.ValueWatcher`1.Update"/> is called.
            </summary>
        </member>
        <member name="P:Rewired.Utils.Classes.Utility.ValueWatcher`1.value">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="E:Rewired.Utils.Classes.Utility.ValueWatcher`1.ChangedEvent">
            <summary>
            Event that triggers when the value changes.
            </summary>
        </member>
        <member name="T:Rewired.Utils.EqualityComparerNoAlloc`1">
            <summary>
            Custom replacements for primitive equality comparers due to Mono bugs on iOS that cause memory allocations.
            This bug may not exist anymore with IL2CPP. Not sure.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XboxOne.IXboxOneInputSource">
            <summary>
            Interface for Xbox One input source for accessing special functions.
            </summary>
            <exclude></exclude>
        </member>
        <member name="T:Rewired.Platforms.XboxOne.XboxOneGamepadExtension">
            <summary>
            Allows access to platform-specific controller functions such as vibration.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Int32,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Int32,System.Single,System.Single)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Int32,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for a motor at a specified index with a timeout.
            </summary>
            <param name="motorIndex">Motor index</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Length of time in seconds to activate the motor before it stops. [0 = Infinite]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.GetVibration(System.Int32)">
            <summary>
            Gets vibration level for a motor at a specified index.
            </summary>
            <param name="motorIndex">Motor index</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.GetVibration(Rewired.Platforms.XboxOne.XboxOneGamepadMotorType)">
            <summary>
            Gets vibration level for a specific motor.
            </summary>
            <param name="motor">Motor type</param>
            <returns>Motor level [float: 0.0 - 1.0]</returns>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.StopVibration">
            <summary>
            Stops vibration on all motors.
            </summary>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(Rewired.Platforms.XboxOne.XboxOneGamepadMotorType,System.Single)">
            <summary>
            Sets vibration leves on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(Rewired.Platforms.XboxOne.XboxOneGamepadMotorType,System.Single,System.Boolean)">
            <summary>
            Sets vibration level on an individual motor.
            </summary>
            <param name="motor">Motor type</param>
            <param name="motorLevel">Motor level [float: 0.0 - 1.0]</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Single,System.Single)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Single,System.Single,System.Boolean)">
            <summary>
            Sets vibration level for left and right motors.
            </summary>
            <param name="leftMotorLevel">float: 0.0 - 1.0</param>
            <param name="rightMotorLevel">float: 0.0 - 1.0</param>
            <param name="stopOtherMotors">Stop other motors?</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.SetVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets vibration levels on all 4 motors.
            </summary>
            <param name="leftMotorLevel">Left motor level [float: 0.0 - 1.0]</param>
            <param name="rightMotorLevel">Right motor level [float: 0.0 - 1.0]</param>
            <param name="leftTriggerLevel">Left trigger level [float: 0.0 - 1.0]</param>
            <param name="rightTriggerLevel">Right trigger level [float: 0.0 - 1.0]</param>
        </member>
        <member name="M:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.PulseVibrateMotor(Rewired.Platforms.XboxOne.XboxOneGamepadMotorType,System.Single,System.Single,System.Single)">
            <summary>
            Pulses the vibration motor for a specified duration.
            </summary>
            <param name="motor">Motor type</param>
            <param name="startLevel">Start motor level [float: 0.0 - 1.0]</param>
            <param name="endLevel">End motor level [float: 0.0 - 1.0]</param>
            <param name="duration">Duration in seconds</param>
        </member>
        <member name="P:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.xboxOneUserId">
            <summary>
            The Xbox One user id to which this controller is assigned.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.xboxOneJoystickId">
            <summary>
            The Xbox One joystick id for this controller.
            </summary>
        </member>
        <member name="P:Rewired.Platforms.XboxOne.XboxOneGamepadExtension.vibrationMotorCount">
            <summary>
            The number of vibration motors in this controller.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XboxOne.XboxOneGamepadMotorType">
            <summary>
            XBox One game pad motors. Used for vibration.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XboxOne.XboxOneGamepadVibration">
            <summary>
            For passing Xbox One gamepad vibration data.
            </summary>
        </member>
        <member name="T:Rewired.Platforms.XboxOne.XboxOneInputSource">
            <summary>
            Input source for the Xbox One platform.
            </summary>
        </member>
    </members>
</doc>
